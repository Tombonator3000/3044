<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometry 3044 - Enhanced Arcade Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        
        body {
            background: #000;
            color: #00ffff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            border: none;
        }
        
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            background: #000;
        }
        
        #menuScreen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(180deg, rgba(26, 0, 51, 0.95) 0%, rgba(51, 0, 102, 0.9) 30%, rgba(102, 0, 153, 0.8) 60%, rgba(0, 0, 51, 0.95) 100%),
                repeating-linear-gradient(
                    90deg,
                    transparent,
                    transparent 98px,
                    rgba(255, 0, 150, 0.03) 100px
                );
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            overflow: hidden;
        }
        
        #menuScreen::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: 
                repeating-linear-gradient(
                    0deg,
                    transparent 0px,
                    rgba(255, 0, 150, 0.1) 2px,
                    transparent 4px,
                    transparent 40px
                ),
                repeating-linear-gradient(
                    90deg,
                    transparent 0px,
                    rgba(255, 0, 150, 0.15) 1px,
                    transparent 2px,
                    transparent 50px
                );
            transform: perspective(200px) rotateX(45deg);
            z-index: -1;
        }
        
        #menuScreen::after {
            content: '';
            position: absolute;
            top: 10%;
            left: 0;
            right: 0;
            height: 40%;
            background: 
                radial-gradient(ellipse 50% 20% at 20% 80%, rgba(102, 0, 153, 0.4) 0%, transparent 50%),
                radial-gradient(ellipse 50% 20% at 80% 70%, rgba(255, 0, 150, 0.3) 0%, transparent 50%),
                radial-gradient(ellipse 30% 15% at 60% 85%, rgba(0, 255, 255, 0.2) 0%, transparent 50%);
            z-index: -1;
            filter: blur(2px);
        }
        
        .logo {
            font-size: 5em;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            margin-bottom: 0.3em;
            background: linear-gradient(45deg, #ffffff, #e6e6e6, #ffffff, #cccccc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 
                0 0 10px rgba(255, 255, 255, 0.8),
                0 0 20px rgba(255, 255, 255, 0.6),
                0 0 30px rgba(255, 255, 255, 0.4),
                0 4px 8px rgba(0, 0, 0, 0.8);
            animation: chrome-pulse 3s ease-in-out infinite;
            position: relative;
            z-index: 5;
        }
        
        .logo::before {
            content: 'GEOMETRY';
            position: absolute;
            top: 2px;
            left: 2px;
            background: linear-gradient(45deg, #ff0080, #ff0040, #ff0080);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            z-index: -1;
            filter: blur(1px);
        }
        
        .logo .year {
            background: linear-gradient(45deg, #ff0080, #ff4da6, #ff0080, #e6005c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 
                0 0 10px rgba(255, 0, 128, 0.8),
                0 0 20px rgba(255, 0, 128, 0.6),
                0 0 30px rgba(255, 0, 128, 0.4),
                0 4px 8px rgba(0, 0, 0, 0.8);
            animation: neon-glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes chrome-pulse {
            0%, 100% { 
                filter: brightness(1) contrast(1);
                text-shadow: 
                    0 0 10px rgba(255, 255, 255, 0.8),
                    0 0 20px rgba(255, 255, 255, 0.6),
                    0 0 30px rgba(255, 255, 255, 0.4),
                    0 4px 8px rgba(0, 0, 0, 0.8);
            }
            50% { 
                filter: brightness(1.2) contrast(1.1);
                text-shadow: 
                    0 0 15px rgba(255, 255, 255, 1),
                    0 0 25px rgba(255, 255, 255, 0.8),
                    0 0 35px rgba(255, 255, 255, 0.6),
                    0 4px 8px rgba(0, 0, 0, 0.8);
            }
        }
        
        @keyframes neon-glow {
            0% { 
                filter: brightness(1) saturate(1);
                text-shadow: 
                    0 0 10px rgba(255, 0, 128, 0.8),
                    0 0 20px rgba(255, 0, 128, 0.6),
                    0 0 30px rgba(255, 0, 128, 0.4),
                    0 4px 8px rgba(0, 0, 0, 0.8);
            }
            100% { 
                filter: brightness(1.3) saturate(1.2);
                text-shadow: 
                    0 0 15px rgba(255, 0, 128, 1),
                    0 0 25px rgba(255, 0, 128, 0.8),
                    0 0 35px rgba(255, 0, 128, 0.6),
                    0 4px 8px rgba(0, 0, 0, 0.8);
            }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }
        
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 25px;
            z-index: 5;
        }
        
        .btn {
            padding: 18px 50px;
            font-size: 1.3em;
            font-weight: 700;
            text-transform: uppercase;
            background: linear-gradient(45deg, rgba(0, 255, 255, 0.1), rgba(255, 0, 150, 0.1));
            color: #00ffff;
            border: 2px solid transparent;
            background-clip: padding-box;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            letter-spacing: 0.15em;
            position: relative;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            box-shadow: 
                0 0 20px rgba(0, 255, 255, 0.3),
                inset 0 0 20px rgba(0, 255, 255, 0.1);
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #00ffff, #ff0080, #00ffff, #ff0080);
            border-radius: inherit;
            z-index: -1;
            animation: border-dance 3s linear infinite;
        }
        
        .btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.6s;
            z-index: 1;
        }
        
        .btn:hover {
            color: #ffffff;
            transform: scale(1.05) translateY(-2px);
            text-shadow: 
                0 0 20px rgba(255, 255, 255, 0.8),
                0 0 30px rgba(0, 255, 255, 0.6);
            background: linear-gradient(45deg, rgba(0, 255, 255, 0.2), rgba(255, 0, 150, 0.2));
            box-shadow: 
                0 0 30px rgba(0, 255, 255, 0.6),
                0 0 50px rgba(255, 0, 150, 0.4),
                inset 0 0 30px rgba(255, 255, 255, 0.1),
                0 8px 25px rgba(0, 0, 0, 0.5);
        }
        
        .btn:hover::after {
            left: 100%;
        }
        
        /* 🌟 ENHANCED MENU EFFECTS */
        .menu-particle-system {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            overflow: hidden;
            z-index: 1;
        }

        .neon-particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #00ffff;
            box-shadow: 0 0 10px currentColor;
            animation: fall-particle 8s linear infinite;
            opacity: 0;
        }

        .neon-particle:nth-child(odd) { background: #ff00ff; }
        .neon-particle:nth-child(3n) { background: #ffff00; }
        .neon-particle:nth-child(5n) { background: #00ff00; }

        @keyframes fall-particle {
            0% {
                opacity: 0;
                transform: translateY(-100vh) translateX(0) scale(0);
            }
            5% {
                opacity: 1;
                transform: translateY(-90vh) translateX(10px) scale(1);
            }
            95% {
                opacity: 1;
                transform: translateY(100vh) translateX(-10px) scale(0.5);
            }
            100% {
                opacity: 0;
                transform: translateY(110vh) translateX(0) scale(0);
            }
        }

        .floating-geometry {
            position: absolute;
            border: 2px solid;
            background: transparent;
            animation: float-rotate 15s linear infinite;
            opacity: 0.1;
        }

        .floating-geometry:nth-child(even) {
            animation: float-rotate-reverse 20s linear infinite;
            opacity: 0.15;
        }

        @keyframes float-rotate {
            0% {
                transform: translateY(100vh) rotate(0deg);
            }
            100% {
                transform: translateY(-200px) rotate(360deg);
            }
        }

        @keyframes float-rotate-reverse {
            0% {
                transform: translateY(100vh) rotate(360deg);
            }
            100% {
                transform: translateY(-200px) rotate(0deg);
            }
        }

        .menu-scanlines {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 255, 255, 0.03) 2px,
                rgba(0, 255, 255, 0.03) 4px
            );
            pointer-events: none;
            z-index: 8;
            animation: scanline-drift 3s ease-in-out infinite alternate;
        }

        @keyframes scanline-drift {
            0% { transform: translateY(0px); }
            100% { transform: translateY(4px); }
        }

        .digital-rain {
            position: absolute;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #00ff00;
            opacity: 0.2;
            animation: matrix-fall 6s linear infinite;
            white-space: nowrap;
            text-shadow: 0 0 5px currentColor;
        }

        @keyframes matrix-fall {
            0% {
                opacity: 0;
                transform: translateY(-100px);
            }
            10% {
                opacity: 0.6;
            }
            90% {
                opacity: 0.6;
            }
            100% {
                opacity: 0;
                transform: translateY(100vh);
            }
        }

        .holographic-interference {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(90deg, 
                    transparent 0%, 
                    rgba(0, 255, 255, 0.02) 25%, 
                    transparent 50%, 
                    rgba(255, 0, 255, 0.02) 75%, 
                    transparent 100%);
            animation: interference-sweep 4s ease-in-out infinite;
            pointer-events: none;
            z-index: 2;
        }

        @keyframes interference-sweep {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }

        .neon-streak {
            position: absolute;
            height: 1px;
            background: linear-gradient(90deg, 
                transparent, 
                #00ffff, 
                #ff00ff, 
                #ffff00, 
                transparent);
            box-shadow: 0 0 10px currentColor;
            animation: streak-across 3s ease-in-out infinite;
            opacity: 0;
        }

        @keyframes streak-across {
            0% {
                opacity: 0;
                transform: translateX(-100vw) scaleX(0.5);
            }
            5% {
                opacity: 1;
                transform: translateX(-50vw) scaleX(1);
            }
            95% {
                opacity: 1;
                transform: translateX(150vw) scaleX(1);
            }
            100% {
                opacity: 0;
                transform: translateX(200vw) scaleX(0.5);
            }
        }

        .cyber-grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                repeating-linear-gradient(
                    90deg,
                    transparent 0px,
                    transparent 99px,
                    rgba(0, 255, 255, 0.05) 100px,
                    rgba(0, 255, 255, 0.05) 101px
                ),
                repeating-linear-gradient(
                    0deg,
                    transparent 0px,
                    transparent 99px,
                    rgba(255, 0, 255, 0.05) 100px,
                    rgba(255, 0, 255, 0.05) 101px
                );
            animation: grid-pulse 6s ease-in-out infinite alternate;
            pointer-events: none;
            z-index: 1;
        }

        @keyframes grid-pulse {
            0% { opacity: 0.3; }
            100% { opacity: 0.7; }
        }

        /* Synthwave decorative elements */
        .synthwave-sun {
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: radial-gradient(circle, #ff6b00 0%, #ff0080 70%, transparent 100%);
            box-shadow: 
                0 0 50px rgba(255, 107, 0, 0.6),
                0 0 100px rgba(255, 0, 128, 0.4),
                inset 0 0 50px rgba(255, 255, 255, 0.1);
            animation: sun-glow 4s ease-in-out infinite alternate;
            z-index: 1;
        }
        
        .synthwave-sun::before {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            border-radius: 50%;
            background: linear-gradient(45deg, transparent, rgba(255, 0, 128, 0.3), transparent);
            animation: sun-rotate 10s linear infinite;
        }
        
        .synthwave-mountains {
            position: absolute;
            bottom: 35%;
            left: 0;
            right: 0;
            height: 150px;
            background: 
                linear-gradient(to right, transparent 0%, rgba(102, 0, 153, 0.6) 20%, rgba(102, 0, 153, 0.8) 40%, rgba(102, 0, 153, 0.6) 60%, transparent 80%),
                linear-gradient(45deg, transparent 40%, rgba(51, 0, 102, 0.8) 45%, rgba(51, 0, 102, 0.9) 55%, transparent 60%);
            clip-path: polygon(0% 100%, 10% 70%, 20% 85%, 30% 60%, 40% 75%, 50% 45%, 60% 65%, 70% 40%, 80% 55%, 90% 75%, 100% 100%);
            z-index: 2;
        }
        
        @keyframes sun-glow {
            0% { 
                box-shadow: 
                    0 0 50px rgba(255, 107, 0, 0.6),
                    0 0 100px rgba(255, 0, 128, 0.4),
                    inset 0 0 50px rgba(255, 255, 255, 0.1);
                filter: brightness(1);
            }
            100% { 
                box-shadow: 
                    0 0 70px rgba(255, 107, 0, 0.8),
                    0 0 120px rgba(255, 0, 128, 0.6),
                    inset 0 0 60px rgba(255, 255, 255, 0.2);
                filter: brightness(1.2);
            }
        }
        
        @keyframes sun-rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes border-dance {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.9; transform: scale(1.02); }
        }
        
        #gameUI {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: none;
            z-index: 5;
        }
        
        .ui-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .ui-element {
            font-size: 1.2em;
            font-weight: 700;
            text-transform: uppercase;
            text-shadow: 0 0 10px currentColor;
        }
        
        .score { color: #0ff; }
        .lives { color: #0f0; }
        .bombs { color: #ff0; }
        .wave { color: #f0f; }
        
        #highScore {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.1em;
            font-weight: 700;
            color: #ffff00;
            text-transform: uppercase;
            text-shadow: 
                0 0 10px rgba(255, 255, 0, 0.8),
                0 0 20px rgba(255, 255, 0, 0.4);
            background: linear-gradient(45deg, rgba(255, 255, 0, 0.1), rgba(255, 0, 150, 0.1));
            padding: 12px 20px;
            border: 1px solid rgba(255, 255, 0, 0.5);
            border-radius: 5px;
            backdrop-filter: blur(5px);
            box-shadow: 
                0 0 15px rgba(255, 255, 0, 0.3),
                inset 0 0 10px rgba(255, 255, 0, 0.1);
        }
        
        .controls {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 0.9em;
            color: #0ff;
            opacity: 0.7;
        }
        
        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }
        
        #highScoreEntryScreen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 25;
        }
        
        #highScoreListScreen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 25;
        }
        
        .high-score-title {
            font-size: 3em;
            font-weight: 900;
            color: #ffff00;
            text-transform: uppercase;
            margin-bottom: 30px;
            text-shadow: 0 0 30px #ffff00;
            animation: pulse 2s ease-in-out infinite;
        }
        
        .initial-input {
            display: flex;
            gap: 20px;
            margin: 30px 0;
        }
        
        .initial-letter {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #00ffff;
            color: #00ffff;
            font-size: 2em;
            font-weight: 900;
            font-family: 'Courier New', monospace;
            text-align: center;
            text-transform: uppercase;
            box-shadow: 0 0 20px #00ffff;
            outline: none;
            cursor: text;
        }
        
        .initial-letter:focus {
            outline: none;
            border-color: #ffff00;
            color: #ffff00;
            box-shadow: 0 0 30px #ffff00;
        }
        
        .high-score-list {
            font-family: 'Courier New', monospace;
            font-size: 1.4em;
            color: #00ffff;
            text-align: center;
            margin: 20px 0;
            min-height: 400px;
        }
        
        .high-score-entry {
            display: flex;
            justify-content: space-between;
            width: 500px;
            margin: 10px 0;
            padding: 10px 20px;
            border: 1px solid #00ffff;
            background: rgba(0, 255, 255, 0.1);
        }
        
        .high-score-entry.new-entry {
            border-color: #ffff00;
            color: #ffff00;
            background: rgba(255, 255, 0, 0.2);
            text-shadow: 0 0 15px #ffff00;
            animation: flash 1s ease-in-out infinite;
        }
        
        @keyframes flash {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.6; }
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }
        
        #continueScreen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 30;
            color: #ff0000;
            font-family: 'Courier New', monospace;
            text-align: center;
        }
        
        .continue-title {
            font-size: 3em;
            font-weight: 900;
            text-transform: uppercase;
            margin-bottom: 30px;
            text-shadow: 0 0 30px #ff0000;
            animation: pulse 1s ease-in-out infinite;
        }
        
        .continue-timer {
            font-size: 2em;
            color: #ffff00;
            margin: 20px 0;
            text-shadow: 0 0 20px #ffff00;
        }
        
        .continue-instruction {
            font-size: 1.5em;
            color: #00ff00;
            margin-bottom: 20px;
            text-shadow: 0 0 15px #00ff00;
            animation: blink 0.5s ease-in-out infinite;
        }
        
        .rank { width: 50px; text-align: left; }
        .initials { width: 80px; text-align: center; font-weight: 900; }
        .score { width: 150px; text-align: right; }
        
        /* 🌟 BONUS ROUND STYLING */
        .bonus-round-title {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4em;
            font-weight: 900;
            text-transform: uppercase;
            color: transparent;
            background: linear-gradient(45deg, #ff00ff, #00ffff, #ffff00, #ff00ff);
            -webkit-background-clip: text;
            background-clip: text;
            animation: rainbow-shift 2s linear infinite;
            text-shadow: 0 0 40px rgba(255, 255, 255, 0.8);
            z-index: 100;
            pointer-events: none;
        }
        
        @keyframes rainbow-shift {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }
        
        @media (max-width: 768px) {
            .high-score-entry { width: 90%; }
            .high-score-title { font-size: 2em; }
        }
        
        #pauseOverlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            font-weight: 900;
            color: #ff0;
            text-shadow: 0 0 30px #ff0;
            display: none;
            z-index: 15;
            text-transform: uppercase;
        }
        
        #mobileControls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            display: none;
            z-index: 20;
            pointer-events: none;
        }
        
        .touch-button {
            position: absolute;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: #0ff;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
        }
        
        #touchJoystick {
            width: 120px;
            height: 120px;
            bottom: 20px;
            left: 20px;
        }
        
        #touchFire {
            width: 80px;
            height: 80px;
            bottom: 40px;
            right: 120px;
        }
        
        #touchBomb {
            width: 60px;
            height: 60px;
            bottom: 40px;
            right: 30px;
        }
        
        @media (max-width: 768px) {
            .logo { font-size: 3em; }
            .btn { font-size: 1em; padding: 12px 30px; }
            .ui-element { font-size: 1em; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="menuScreen">
            <!-- 🌟 ENHANCED MENU EFFECTS -->
            <div class="menu-particle-system" id="menuParticleSystem"></div>
            <div class="cyber-grid-overlay"></div>
            <div class="holographic-interference"></div>
            <div class="menu-scanlines"></div>
            
            <!-- Synthwave decorative elements -->
            <div class="synthwave-sun"></div>
            <div class="synthwave-mountains"></div>
            
            <h1 class="logo">Geometry <span class="year">3044</span></h1>
            <div class="menu-buttons">
                <button class="btn" onclick="startGame()" id="startGameBtn">Start Game</button>
            </div>
            
            <div id="creditsDisplay">
                CREDITS: <span id="creditsCount">3</span>
            </div>
            
            <div id="insertCoinText">
                INSERT COIN
            </div>
            
            <div class="controls">
                WASD/Arrows: Move | Space: Shoot | B: Bomb | P: Pause<br>
                <span>C: INSERT COIN</span>
            </div>
        </div>
        
        <div id="gameOverScreen">
            <h2 style="font-size: 3em; margin-bottom: 30px; text-transform: uppercase; animation: pulse 1s ease-in-out infinite; background: linear-gradient(45deg, #ff006e, #ff4e50, #fc466b, #ff006e); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-shadow: 0 0 40px #ff006e;">GAME OVER MAN, GAME OVER!</h2>
            <div style="font-size: 1.5em; color: #00ffff; margin-bottom: 20px; text-shadow: 0 0 20px #00ffff;">
                Final Score: <span id="finalScoreDisplay">0</span>
            </div>
            <div style="font-size: 1.2em; color: #ffff00; margin-bottom: 20px; text-shadow: 0 0 15px #ffff00;">
                Wave Reached: <span id="finalWaveDisplay">1</span>
            </div>
            <div style="font-size: 1.2em; color: #ff00ff; margin-bottom: 40px; text-shadow: 0 0 15px #ff00ff;">
                Max Combo: <span id="finalComboDisplay">0</span>
            </div>
            <button class="btn" onclick="restartGame()">Play Again</button>
            <button class="btn" onclick="backToMenu()" style="margin-top: 20px;">Main Menu</button>
        </div>
        
        <div id="highScoreEntryScreen">
            <div class="high-score-title">🏆 NEW HIGH SCORE! 🏆</div>
            <div style="font-size: 2em; color: #00ffff; margin-bottom: 20px; text-shadow: 0 0 20px #00ffff;">
                Score: <span id="newHighScoreValue">0</span>
            </div>
            <div style="font-size: 1.4em; color: #ffff00; margin-bottom: 30px; text-transform: uppercase;">
                Enter Your Initials
            </div>
            <div class="initial-input">
                <input type="text" class="initial-letter" id="initial1" maxlength="1">
                <input type="text" class="initial-letter" id="initial2" maxlength="1">
                <input type="text" class="initial-letter" id="initial3" maxlength="1">
            </div>
            <button class="btn" onclick="submitHighScore()" style="margin-top: 30px;">Submit Score</button>
            <div style="font-size: 0.9em; color: #666; margin-top: 20px;">
                Press ENTER to submit or ESC to skip
            </div>
        </div>
        
        <div id="highScoreListScreen">
            <div class="high-score-title">🏆 HIGH SCORES 🏆</div>
            <div class="high-score-list" id="highScoreList">
                <!-- High scores will be populated here -->
            </div>
            <button class="btn" onclick="closeHighScores()">Continue</button>
        </div>
        
        <div id="continueScreen">
            <div class="continue-title">CONTINUE?</div>
            <div style="font-size: 1.8em; color: #00ffff; margin-bottom: 20px; text-shadow: 0 0 20px #00ffff;">
                Final Score: <span id="continueScoreDisplay">0</span>
            </div>
            <div class="continue-timer">
                <span id="continueTimerDisplay">10</span>
            </div>
            <div class="continue-instruction">
                INSERT COIN TO CONTINUE
            </div>
            <div style="font-size: 1.2em; color: #ff00ff; text-shadow: 0 0 15px #ff00ff;">
                Press C to Insert Coin
            </div>
        </div>
        
        <div id="gameUI">
            <div class="ui-row">
                <div class="ui-element score">Score: <span id="scoreDisplay">0</span></div>
                <div class="ui-element wave">Wave: <span id="waveDisplay">1</span></div>
            </div>
            <div class="ui-row">
                <div class="ui-element lives">Lives: <span id="livesDisplay">3</span></div>
                <div class="ui-element bombs">Bombs: <span id="bombsDisplay">3</span></div>
            </div>
        </div>
        
        <div id="highScore">High Score: <span id="highScoreDisplay">0</span></div>
        <div id="pauseOverlay">PAUSED</div>
        
        <div id="mobileControls">
            <div id="touchJoystick" class="touch-button">MOVE</div>
            <div id="touchFire" class="touch-button">FIRE</div>
            <div id="touchBomb" class="touch-button">BOMB</div>
        </div>
    </div>

    <script>
        // Global variables
        let canvas, ctx;
        let gameState = null;
        let keys = {};
        
        let credits = 3;
        let coinInsertSound = null;
        let continueTimer = 0;
        let maxContinueTime = 600;
        let showingContinueScreen = false;
        
        let menuMusic = null;
        let gameMusic = null;
        let musicEnabled = false;
        
        try {
            menuMusic = new Audio("https://archive.org/download/voyager-1-synthwave/Voyager1.mp3");
            menuMusic.loop = true;
            menuMusic.volume = 0.4;
            
            gameMusic = new Audio("https://archive.org/download/neon-underworld-synthwave/NeonUnderworld.mp3");
            gameMusic.loop = true;
            gameMusic.volume = 0.4;
            
            menuMusic.addEventListener('canplaythrough', () => { 
                // Music system loaded but disabled in this version
                console.log('🎵 Synthwave music system loaded but disabled.');
            });
            menuMusic.addEventListener('error', () => { 
                console.warn('🎵 Menu music failed to load - trying fallback URLs'); 
                tryFallbackMusic();
            });
            
        } catch (error) {
            console.warn('Music system failed to initialize:', error);
            tryFallbackMusic();
        }
        
        function tryFallbackMusic() {
            try {
                menuMusic = new Audio("https://raw.githubusercontent.com/Tombonator3000/temp-mp3/main/Start%20Screen%20Arcade.mp3");
                gameMusic = new Audio("https://raw.githubusercontent.com/Tombonator3000/temp-mp3/main/Pixel%20Blitz.mp3");
                menuMusic.loop = true;
                gameMusic.loop = true;
                menuMusic.volume = 0.5;
                gameMusic.volume = 0.5;
                console.log('🎵 Using fallback music URLs');
            } catch (fallbackError) {
                console.warn('🎵 All music sources failed - running without audio');
                musicEnabled = false;
            }
        }
        
        let config = {
            width: 800,
            height: 600,
            colors: {
                player: '#00ff00',
                enemyTriangle: '#ff0066',
                enemySquare: '#0099ff', 
                enemyPentagon: '#00ff66',
                boss: '#ff00ff',
                bullet: '#ffff00',
                grid: '#00ffff',
                particle: '#ffffff'
            }
        };
        
        let touchJoystick = { active: false, startX: 0, startY: 0, currentX: 0, currentY: 0 };
        let touchButtons = { fire: false, bomb: false };
        
        let particleSystem, bulletPool, enemyBulletPool, waveManager, soundSystem;
        let attractMode = false;
        let attractModeTimer = null;
        let attractModeAI = null;
        let bossDeathTimeoutId = null;
        let gameLoopId = null;
        let musicMuted = false;
        
        let starfield = null;
        let ufoManager = null;
        let formationManager = null;
        let bonusRound = null;
        
        let newHighScoreIndex = -1;
        let highScoreFromAttractMode = false;
        
        // 🌟 DYNAMIC THEME SYSTEM
        const waveThemes = {
            1: {
                name: "MIAMI VICE",
                primary: '#ff006e', // Hot pink
                secondary: '#00ffff', // Cyan
                accent: '#8b00ff', // Purple
                bgStart: '#1a0033', // Deep purple
                bgEnd: '#330066', // Purple
                gridHue: 320, // Pink hue base
                nebulaHue: 190 // Cyan base
            },
            2: {
                name: "NEON NIGHTS",
                primary: '#00ff00', // Electric green
                secondary: '#ff0080', // Magenta
                accent: '#ffff00', // Yellow
                bgStart: '#001a00', // Dark green
                bgEnd: '#003300', // Forest green
                gridHue: 120, // Green hue
                nebulaHue: 300 // Magenta base
            },
            3: {
                name: "LASER DREAMS",
                primary: '#ff4500', // Red-orange
                secondary: '#00bfff', // Deep sky blue
                accent: '#ff1493', // Deep pink
                bgStart: '#1a0800', // Dark red
                bgEnd: '#330f00', // Dark orange
                gridHue: 20, // Orange hue
                nebulaHue: 200 // Blue base
            },
            4: {
                name: "CYBER PUNK",
                primary: '#ff00ff', // Magenta
                secondary: '#00ff88', // Spring green
                accent: '#ffff00', // Yellow
                bgStart: '#200020', // Dark magenta
                bgEnd: '#400040', // Purple
                gridHue: 300, // Magenta hue
                nebulaHue: 150 // Green base
            },
            5: {
                name: "RETRO WAVE",
                primary: '#ff6600', // Orange
                secondary: '#0066ff', // Blue
                accent: '#ff00cc', // Pink
                bgStart: '#1a0d00', // Dark orange
                bgEnd: '#331a00', // Brown-orange
                gridHue: 30, // Orange hue
                nebulaHue: 240 // Blue base
            },
            6: {
                name: "ELECTRIC STORM",
                primary: '#ffff00', // Yellow
                secondary: '#8000ff', // Violet
                accent: '#00ffff', // Cyan
                bgStart: '#1a1a00', // Dark yellow
                bgEnd: '#333300', // Olive
                gridHue: 60, // Yellow hue
                nebulaHue: 270 // Violet base
            }
        };

        function getCurrentTheme() {
            const wave = (gameState && gameState.wave) ? gameState.wave : 1;
            const themeKey = Math.min(wave, 6);
            return waveThemes[themeKey] || waveThemes[1];
        }

        // 🌟 ENHANCED STARFIELD WITH THEME SUPPORT AND MOVING NEBULAE
        class Starfield {
            constructor() {
                this.layers = [];
                this.nebulae = [];
                this.distantNebulae = [];
                this.transitionTimer = 0;
                this.currentTheme = getCurrentTheme();
                this.warpStars = [];
                
                // Create multiple star layers for depth
                for (let layer = 0; layer < 5; layer++) {
                    const stars = [];
                    const numStars = 80 - (layer * 12);
                    
                    for (let i = 0; i < numStars; i++) {
                        stars.push({
                            x: Math.random() * config.width,
                            y: Math.random() * config.height,
                            brightness: Math.random() * 0.8 + 0.2,
                            twinkleSpeed: 0.005 + Math.random() * 0.015,
                            twinklePhase: Math.random() * Math.PI * 2,
                            size: 0.5 + layer * 0.4,
                            speed: 0.1 + layer * 0.4,
                            color: Math.random() > 0.9 ? 'colored' : 'white'
                        });
                    }
                    this.layers.push(stars);
                }
                
                // Create main nebulae (closer, more detailed)
                for (let i = 0; i < 4; i++) {
                    this.nebulae.push({
                        x: Math.random() * config.width * 1.5 - config.width * 0.25,
                        y: Math.random() * config.height * 1.2 - config.height * 0.1,
                        size: 150 + Math.random() * 250,
                        baseHue: Math.random() * 90,
                        speed: 0.08 + Math.random() * 0.15,
                        opacity: 0.06 + Math.random() * 0.08, // Reduced from 0.12-0.30 to 0.06-0.14
                        pulseSpeed: 0.008 + Math.random() * 0.012,
                        pulsePhase: Math.random() * Math.PI * 2,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.002,
                        type: Math.random() > 0.5 ? 'spiral' : 'cloud'
                    });
                }
                
                // Create distant nebulae (background layer)
                for (let i = 0; i < 6; i++) {
                    this.distantNebulae.push({
                        x: Math.random() * config.width * 2 - config.width * 0.5,
                        y: Math.random() * config.height * 1.5 - config.height * 0.25,
                        size: 200 + Math.random() * 400,
                        baseHue: Math.random() * 120,
                        speed: 0.02 + Math.random() * 0.05,
                        opacity: 0.03 + Math.random() * 0.04, // Reduced from 0.06-0.14 to 0.03-0.07
                        pulseSpeed: 0.003 + Math.random() * 0.005,
                        pulsePhase: Math.random() * Math.PI * 2,
                        swayAmount: 20 + Math.random() * 40,
                        swaySpeed: 0.001 + Math.random() * 0.002,
                        swayPhase: Math.random() * Math.PI * 2
                    });
                }
                
                // Warp stars for hyperspeed effect
                for (let i = 0; i < 15; i++) {
                    this.warpStars.push({
                        x: Math.random() * config.width,
                        y: Math.random() * config.height,
                        length: 5 + Math.random() * 15,
                        speed: 8 + Math.random() * 12,
                        opacity: 0.15 + Math.random() * 0.2, // Reduced from 0.3 + 0.4
                        active: Math.random() > 0.7
                    });
                }
                
                console.log('⭐ Enhanced starfield created with', this.layers.length, 'star layers,', this.nebulae.length, 'main nebulae, and', this.distantNebulae.length, 'distant nebulae');
            }
            
            update() {
                // Check for theme change
                const newTheme = getCurrentTheme();
                if (newTheme.name !== this.currentTheme.name) {
                    this.currentTheme = newTheme;
                    this.transitionTimer = 60;
                }
                
                if (this.transitionTimer > 0) {
                    this.transitionTimer--;
                }
                
                // Update star layers
                this.layers.forEach((layer, layerIndex) => {
                    layer.forEach(star => {
                        star.y += star.speed;
                        star.twinklePhase += star.twinkleSpeed;
                        
                        if (star.y > config.height + 20) {
                            star.y = -20;
                            star.x = Math.random() * config.width;
                            star.brightness = Math.random() * 0.8 + 0.2;
                        }
                    });
                });
                
                // Update main nebulae
                this.nebulae.forEach(nebula => {
                    nebula.y += nebula.speed;
                    nebula.pulsePhase += nebula.pulseSpeed;
                    nebula.rotation += nebula.rotationSpeed;
                    
                    if (nebula.y > config.height + nebula.size) {
                        nebula.y = -nebula.size;
                        nebula.x = Math.random() * config.width * 1.5 - config.width * 0.25;
                        nebula.baseHue = Math.random() * 90;
                    }
                });
                
                // Update distant nebulae
                this.distantNebulae.forEach(nebula => {
                    nebula.y += nebula.speed;
                    nebula.pulsePhase += nebula.pulseSpeed;
                    nebula.swayPhase += nebula.swaySpeed;
                    
                    // Add horizontal swaying motion
                    nebula.swayOffset = Math.sin(nebula.swayPhase) * nebula.swayAmount;
                    
                    if (nebula.y > config.height + nebula.size) {
                        nebula.y = -nebula.size;
                        nebula.x = Math.random() * config.width * 2 - config.width * 0.5;
                    }
                });
                
                // Update warp stars
                this.warpStars.forEach(star => {
                    if (star.active) {
                        star.y += star.speed;
                        
                        if (star.y > config.height + 50) {
                            star.y = -50;
                            star.x = Math.random() * config.width;
                            star.length = 5 + Math.random() * 15;
                            star.speed = 8 + Math.random() * 12;
                            star.active = Math.random() > 0.5;
                        }
                    } else {
                        // Randomly reactivate
                        if (Math.random() < 0.002) {
                            star.active = true;
                            star.x = Math.random() * config.width;
                            star.y = -50;
                        }
                    }
                });
            }
            
            draw(ctx) {
                ctx.save();
                
                // Draw distant nebulae first (background layer)
                this.distantNebulae.forEach(nebula => {
                    const pulse = Math.sin(nebula.pulsePhase) * 0.2 + 0.8;
                    const hue = this.currentTheme.nebulaHue + nebula.baseHue;
                    const currentX = nebula.x + (nebula.swayOffset || 0);
                    
                    const gradient = ctx.createRadialGradient(
                        currentX, nebula.y, 0,
                        currentX, nebula.y, nebula.size * pulse
                    );
                    gradient.addColorStop(0, `hsla(${hue}, 60%, 40%, ${nebula.opacity * pulse * 0.4})`); // Reduced from 0.6
                    gradient.addColorStop(0.3, `hsla(${hue + 20}, 50%, 35%, ${nebula.opacity * pulse * 0.25})`); // Reduced from 0.4
                    gradient.addColorStop(0.6, `hsla(${hue + 40}, 40%, 30%, ${nebula.opacity * pulse * 0.1})`); // Reduced from 0.2
                    gradient.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(currentX, nebula.y, nebula.size * pulse, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Draw far stars (smallest, dimmest)
                this.layers[0].forEach(star => {
                    const twinkle = Math.sin(star.twinklePhase) * 0.2 + 0.8;
                    const alpha = star.brightness * twinkle * 0.15; // Reduced from 0.3
                    
                    ctx.fillStyle = `rgba(200, 220, 255, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Draw main nebulae
                this.nebulae.forEach(nebula => {
                    const pulse = Math.sin(nebula.pulsePhase) * 0.3 + 0.7;
                    const hue = this.currentTheme.nebulaHue + nebula.baseHue;
                    
                    ctx.save();
                    ctx.translate(nebula.x, nebula.y);
                    ctx.rotate(nebula.rotation);
                    
                    if (nebula.type === 'spiral') {
                        // Spiral galaxy-like nebula
                        for (let i = 0; i < 3; i++) {
                            ctx.save();
                            ctx.rotate((i * Math.PI * 2) / 3);
                            
                            const gradient = ctx.createRadialGradient(
                                0, 0, 0,
                                nebula.size * 0.8, 0, nebula.size * pulse
                            );
                            gradient.addColorStop(0, `hsla(${hue + i * 15}, 70%, 50%, ${nebula.opacity * pulse * 0.6})`); // Reduced from higher values
                            gradient.addColorStop(0.4, `hsla(${hue + i * 15 + 30}, 60%, 40%, ${nebula.opacity * pulse * 0.35})`); // Reduced
                            gradient.addColorStop(0.8, `hsla(${hue + i * 15 + 60}, 50%, 30%, ${nebula.opacity * pulse * 0.15})`); // Reduced;
                            gradient.addColorStop(1, 'transparent');
                            
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.ellipse(0, 0, nebula.size * pulse * 0.8, nebula.size * pulse * 0.3, 0, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }
                    } else {
                        // Cloud-like nebula
                        for (let i = 0; i < 4; i++) {
                            const offsetX = Math.sin(nebula.pulsePhase + i) * 20;
                            const offsetY = Math.cos(nebula.pulsePhase + i * 0.7) * 15;
                            const size = nebula.size * (0.6 + i * 0.1) * pulse;
                            
                            const gradient = ctx.createRadialGradient(
                                offsetX, offsetY, 0,
                                offsetX, offsetY, size
                            );
                            gradient.addColorStop(0, `hsla(${hue + i * 10}, 70%, 50%, ${nebula.opacity * pulse * (0.6 - i * 0.1)})`); // Reduced
                            gradient.addColorStop(0.5, `hsla(${hue + i * 10 + 30}, 60%, 40%, ${nebula.opacity * pulse * 0.25 * (0.6 - i * 0.1)})`); // Reduced;
                            gradient.addColorStop(1, 'transparent');
                            
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(offsetX, offsetY, size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    
                    ctx.restore();
                });
                
                // Draw middle distance stars
                for (let layerIndex = 1; layerIndex < 3; layerIndex++) {
                    this.layers[layerIndex].forEach(star => {
                        const twinkle = Math.sin(star.twinklePhase) * 0.3 + 0.7;
                        const alpha = star.brightness * twinkle * (0.25 + layerIndex * 0.1); // Reduced from 0.4 + 0.15
                        
                        if (star.color === 'colored') {
                            const hue = (this.currentTheme.gridHue + layerIndex * 30) % 360;
                            ctx.fillStyle = `hsla(${hue}, 80%, 70%, ${alpha})`;
                            ctx.shadowBlur = star.size * 2; // Reduced from 3
                            ctx.shadowColor = `hsla(${hue}, 80%, 70%, ${alpha * 0.6})`; // Reduced from 0.8
                        } else {
                            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                            ctx.shadowBlur = star.size * 1.5; // Reduced from 2
                            ctx.shadowColor = `rgba(255, 255, 255, ${alpha * 0.4})`; // Reduced from 0.6
                        }
                        
                        ctx.beginPath();
                        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add cross flare for bright stars
                        if (star.brightness > 0.7 && twinkle > 0.8) {
                            const flareLength = star.size * 3; // Reduced from 4
                            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.4})`; // Reduced from ctx.fillStyle
                            ctx.lineWidth = 0.4; // Reduced from 0.5
                            ctx.beginPath();
                            ctx.moveTo(star.x - flareLength, star.y);
                            ctx.lineTo(star.x + flareLength, star.y);
                            ctx.moveTo(star.x, star.y - flareLength);
                            ctx.lineTo(star.x, star.y + flareLength);
                            ctx.stroke();
                        }
                        
                        ctx.shadowBlur = 0;
                    });
                }
                
                // Draw warp stars
                this.warpStars.forEach(star => {
                    if (star.active) {
                        ctx.save();
                        ctx.globalAlpha = star.opacity;
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 1;
                        ctx.shadowBlur = 4; // Reduced from 8
                        ctx.shadowColor = '#ffffff';
                        
                        ctx.beginPath();
                        ctx.moveTo(star.x, star.y);
                        ctx.lineTo(star.x, star.y - star.length);
                        ctx.stroke();
                        
                        ctx.restore();
                    }
                });
                
                // Draw closest stars (brightest, largest)
                for (let layerIndex = 3; layerIndex < this.layers.length; layerIndex++) {
                    this.layers[layerIndex].forEach(star => {
                        const twinkle = Math.sin(star.twinklePhase) * 0.4 + 0.6;
                        const alpha = star.brightness * twinkle * (0.35 + layerIndex * 0.1); // Reduced from 0.5 + 0.15
                        
                        if (star.color === 'colored') {
                            const hue = (this.currentTheme.gridHue + layerIndex * 40) % 360;
                            ctx.fillStyle = `hsla(${hue}, 90%, 80%, ${alpha})`;
                            ctx.shadowBlur = star.size * 3; // Reduced from 4
                            ctx.shadowColor = `hsla(${hue}, 90%, 80%, ${alpha * 0.7})`; // Reduced from direct alpha
                        } else {
                            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                            ctx.shadowBlur = star.size * 2; // Reduced from 3
                            ctx.shadowColor = `rgba(255, 255, 255, ${alpha * 0.6})`; // Reduced from 0.8
                        }
                        
                        ctx.beginPath();
                        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Bright star effects
                        if (star.brightness > 0.6) {
                            ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.6})`; // Reduced from 0.8
                            ctx.beginPath();
                            ctx.arc(star.x, star.y, star.size * 0.5, 0, Math.PI * 2);
                            ctx.fill();
                            
                            if (twinkle > 0.9) {
                                const flareLength = star.size * 5; // Reduced from 6
                                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.5})`; // Reduced opacity
                                ctx.lineWidth = 0.8; // Reduced from 1
                                ctx.beginPath();
                                ctx.moveTo(star.x - flareLength, star.y);
                                ctx.lineTo(star.x + flareLength, star.y);
                                ctx.moveTo(star.x, star.y - flareLength);
                                ctx.lineTo(star.x, star.y + flareLength);
                                ctx.stroke();
                            }
                        }
                        
                        ctx.shadowBlur = 0;
                    });
                }
                
                ctx.restore();
            }
            
            resize(width, height) {
                // Update star positions for new canvas size
                this.layers.forEach(layer => {
                    layer.forEach(star => {
                        if (star.x > width) star.x = Math.random() * width;
                        if (star.y > height) star.y = Math.random() * height;
                    });
                });
                
                // Update nebula positions
                this.nebulae.forEach(nebula => {
                    if (nebula.x > width * 1.5) nebula.x = Math.random() * width * 1.5 - width * 0.25;
                    if (nebula.y > height) nebula.y = Math.random() * height * 1.2 - height * 0.1;
                });
                
                this.distantNebulae.forEach(nebula => {
                    if (nebula.x > width * 2) nebula.x = Math.random() * width * 2 - width * 0.5;
                    if (nebula.y > height) nebula.y = Math.random() * height * 1.5 - height * 0.25;
                });
                
                // Update warp stars
                this.warpStars.forEach(star => {
                    if (star.x > width) star.x = Math.random() * width;
                    if (star.y > height) star.y = Math.random() * height;
                });
            }
        }
        
        // 🎮 BONUS ROUND SYSTEM
        class BonusRound {
            constructor(wave) {
                this.diamonds = [];
                this.timer = 600; // 10 seconds
                this.collected = 0;
                this.active = true;
                this.wave = wave;
                
                // Choose pattern based on wave
                const patterns = ['circle', 'heart', 'star', 'spiral'];
                const pattern = patterns[Math.min(Math.floor(wave / 3) - 1, patterns.length - 1)];
                this.spawnPattern(pattern);
                
                // Disable player shooting during bonus round
                if (gameState && gameState.player) {
                    gameState.player.canShoot = false;
                }
                
                // Clear all enemies and bullets
                if (gameState) {
                    gameState.enemies = [];
                    if (bulletPool) bulletPool.clear();
                    if (enemyBulletPool) enemyBulletPool.clear();
                }
            }
            
            spawnPattern(type) {
                const cx = config.width / 2;
                const cy = config.height / 2;
                
                switch(type) {
                    case 'circle':
                        for (let i = 0; i < 16; i++) {
                            const angle = (Math.PI * 2 * i) / 16;
                            this.diamonds.push({
                                x: cx + Math.cos(angle) * 150,
                                y: cy + Math.sin(angle) * 150,
                                value: 500,
                                color: `hsl(${i * 22}, 100%, 50%)`,
                                collected: false,
                                size: 20,
                                pulse: Math.random() * Math.PI * 2,
                                originalX: cx + Math.cos(angle) * 150,
                                originalY: cy + Math.sin(angle) * 150
                            });
                        }
                        break;
                        
                    case 'heart':
                        for (let t = 0; t < Math.PI * 2; t += Math.PI / 8) {
                            const x = 16 * Math.pow(Math.sin(t), 3);
                            const y = -13 * Math.cos(t) + 5 * Math.cos(2*t) + 2 * Math.cos(3*t) + Math.cos(4*t);
                            this.diamonds.push({
                                x: cx + x * 8,
                                y: cy + y * 8,
                                value: 750,
                                color: '#ff1493',
                                collected: false,
                                size: 22,
                                pulse: t,
                                originalX: cx + x * 8,
                                originalY: cy + y * 8
                            });
                        }
                        break;
                        
                    case 'star':
                        for (let i = 0; i < 10; i++) {
                            const angle = (Math.PI * 2 * i) / 10;
                            const radius = i % 2 === 0 ? 180 : 80;
                            this.diamonds.push({
                                x: cx + Math.cos(angle - Math.PI/2) * radius,
                                y: cy + Math.sin(angle - Math.PI/2) * radius,
                                value: 1000,
                                color: '#ffd700',
                                collected: false,
                                size: 25,
                                pulse: angle,
                                originalX: cx + Math.cos(angle - Math.PI/2) * radius,
                                originalY: cy + Math.sin(angle - Math.PI/2) * radius
                            });
                        }
                        break;
                        
                    case 'spiral':
                        for (let i = 0; i < 20; i++) {
                            const angle = (Math.PI * 2 * i) / 5;
                            const radius = 20 + i * 10;
                            this.diamonds.push({
                                x: cx + Math.cos(angle) * radius,
                                y: cy + Math.sin(angle) * radius,
                                value: 250 * Math.ceil((i + 1) / 5),
                                color: `hsl(${i * 18}, 100%, 50%)`,
                                collected: false,
                                size: 18 + i * 0.5,
                                pulse: angle,
                                originalX: cx + Math.cos(angle) * radius,
                                originalY: cy + Math.sin(angle) * radius
                            });
                        }
                        break;
                }
            }
            
            update() {
                this.timer--;
                
                // Update diamond animations
                this.diamonds.forEach(diamond => {
                    if (!diamond.collected) {
                        diamond.pulse += 0.1;
                        diamond.x = diamond.originalX + Math.sin(diamond.pulse) * 5;
                        diamond.y = diamond.originalY + Math.cos(diamond.pulse) * 5;
                        
                        // Check collection
                        if (gameState && gameState.player) {
                            const dist = Math.hypot(
                                diamond.x - gameState.player.x,
                                diamond.y - gameState.player.y
                            );
                            
                            if (dist < diamond.size + gameState.player.size) {
                                diamond.collected = true;
                                this.collected++;
                                gameState.score += diamond.value;
                                
                                // Collection effect
                                if (particleSystem) {
                                    for (let i = 0; i < 20; i++) {
                                        const angle = (Math.PI * 2 * i) / 20;
                                        particleSystem.particles.push({
                                            x: diamond.x,
                                            y: diamond.y,
                                            vx: Math.cos(angle) * 8,
                                            vy: Math.sin(angle) * 8,
                                            color: diamond.color,
                                            life: 30,
                                            maxLife: 30,
                                            size: 3,
                                            active: true,
                                            update() {
                                                this.x += this.vx;
                                                this.y += this.vy;
                                                this.vx *= 0.9;
                                                this.vy *= 0.9;
                                                this.life--;
                                                if (this.life <= 0) this.active = false;
                                            },
                                            draw(ctx) {
                                                const alpha = this.life / this.maxLife;
                                                ctx.save();
                                                ctx.globalAlpha = alpha;
                                                ctx.fillStyle = this.color;
                                                ctx.shadowBlur = 15;
                                                ctx.shadowColor = this.color;
                                                ctx.beginPath();
                                                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                                ctx.fill();
                                                ctx.restore();
                                            }
                                        });
                                    }
                                }
                                
                                if (soundSystem) soundSystem.playPowerUp();
                                updateUI();
                            }
                        }
                    }
                });
                
                // Check if bonus round is complete
                if (this.timer <= 0 || this.diamonds.every(d => d.collected)) {
                    this.endBonusRound();
                }
            }
            
            endBonusRound() {
                this.active = false;
                
                // Calculate bonus
                const totalDiamonds = this.diamonds.length;
                const collectionRate = this.collected / totalDiamonds;
                let bonusMessage = '';
                let bonusScore = 0;
                
                if (collectionRate === 1) {
                    bonusMessage = 'PERFECT BONUS!';
                    bonusScore = 10000;
                } else if (collectionRate >= 0.8) {
                    bonusMessage = 'EXCELLENT!';
                    bonusScore = 5000;
                } else if (collectionRate >= 0.5) {
                    bonusMessage = 'GOOD JOB!';
                    bonusScore = 2500;
                } else {
                    bonusMessage = 'TRY HARDER!';
                    bonusScore = 1000;
                }
                
                if (gameState) {
                    gameState.score += bonusScore;
                    
                    // Show bonus message
                    gameState.particles.push({
                        text: bonusMessage,
                        score: `+${bonusScore}`,
                        x: config.width / 2,
                        y: config.height / 2,
                        life: 120,
                        maxLife: 120,
                        scale: 0.1,
                        active: true,
                        update() {
                            this.life--;
                            if (this.scale < 2) this.scale += 0.1;
                            if (this.life <= 0) this.active = false;
                        },
                        draw(ctx) {
                            const alpha = this.life / this.maxLife;
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.scale(this.scale, this.scale);
                            ctx.globalAlpha = alpha;
                            
                            ctx.font = 'bold 48px Courier New';
                            ctx.textAlign = 'center';
                            ctx.fillStyle = '#ffff00';
                            ctx.shadowBlur = 30;
                            ctx.shadowColor = '#ffff00';
                            ctx.fillText(this.text, 0, -20);
                            
                            ctx.font = 'bold 32px Courier New';
                            ctx.fillStyle = '#00ff00';
                            ctx.fillText(this.score, 0, 20);
                            
                            ctx.restore();
                        }
                    });
                    
                    // Re-enable shooting
                    if (gameState.player) {
                        gameState.player.canShoot = true;
                    }
                    
                    // Continue to next wave
                    setTimeout(() => {
                        if (waveManager) waveManager.nextWave();
                    }, 2000);
                }
                
                updateUI();
            }
            
            draw(ctx) {
                // Draw timer
                ctx.save();
                ctx.font = 'bold 24px Courier New';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#00ffff';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#00ffff';
                const seconds = Math.ceil(this.timer / 60);
                ctx.fillText(`TIME: ${seconds}`, config.width / 2, 40);
                
                // Draw collection progress
                ctx.fillText(`${this.collected}/${this.diamonds.length} COLLECTED`, config.width / 2, 70);
                ctx.restore();
                
                // Draw diamonds
                this.diamonds.forEach(diamond => {
                    if (!diamond.collected) {
                        ctx.save();
                        ctx.translate(diamond.x, diamond.y);
                        ctx.rotate(diamond.pulse * 0.5);
                        
                        const scale = 1 + Math.sin(diamond.pulse) * 0.2;
                        ctx.scale(scale, scale);
                        
                        // Diamond shape
                        ctx.fillStyle = diamond.color;
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = diamond.color;
                        
                        ctx.beginPath();
                        ctx.moveTo(0, -diamond.size);
                        ctx.lineTo(diamond.size * 0.7, 0);
                        ctx.lineTo(0, diamond.size);
                        ctx.lineTo(-diamond.size * 0.7, 0);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        
                        // Value text
                        ctx.font = 'bold 10px Courier New';
                        ctx.fillStyle = '#ffffff';
                        ctx.fillText(diamond.value, 0, 0);
                        
                        ctx.restore();
                    }
                });
            }
        }
        
        // UFO Manager and UFO classes remain the same...
        class UFOManager {
            constructor() {
                this.ufos = [];
                this.spawnTimer = 0;
                this.baseSpawnRate = 1800;
                this.lastSpawnTime = 0;
                this.ufoTypes = [
                    { type: 'scout', points: 1000, color: '#00ffff', size: 25, speed: 2.5 },
                    { type: 'cruiser', points: 2500, color: '#ff6600', size: 30, speed: 2 },
                    { type: 'mothership', points: 5000, color: '#ff00ff', size: 40, speed: 1.5 }
                ];
            }
            
            update() {
                this.spawnTimer++;
                
                if (this.spawnTimer > this.baseSpawnRate) {
                    if (Math.random() < 0.001 && this.ufos.length === 0) {
                        this.spawnUFO();
                        this.spawnTimer = 0;
                    }
                }
                
                this.ufos.forEach(ufo => {
                    if (ufo.active) {
                        ufo.update();
                    }
                });
                
                this.ufos = this.ufos.filter(ufo => ufo.active);
            }
            
            spawnUFO() {
                let ufoType;
                const rand = Math.random();
                if (rand < 0.6) {
                    ufoType = this.ufoTypes[0];
                } else if (rand < 0.85) {
                    ufoType = this.ufoTypes[1];
                } else {
                    ufoType = this.ufoTypes[2];
                }
                
                const direction = Math.random() < 0.5 ? 1 : -1;
                const startX = direction > 0 ? -100 : config.width + 100;
                const y = 60 + Math.random() * 100;
                
                const ufo = new UFO(startX, y, ufoType, direction);
                this.ufos.push(ufo);
                
                setTimeout(() => {
                    if (soundSystem) {
                        soundSystem.playUFOAppear();
                        
                        const voiceMessages = {
                            'scout': 'OUTSTANDING',
                            'cruiser': 'EXCELLENT', 
                            'mothership': 'RADICAL'
                        };
                        
                        setTimeout(() => {
                            soundSystem.playVoiceSample(voiceMessages[ufoType.type] || 'OUTSTANDING');
                        }, 500);
                    }
                }, 200);
            }
            
            draw(ctx) {
                this.ufos.forEach(ufo => {
                    if (ufo.active) {
                        ufo.draw(ctx);
                    }
                });
            }
        }
        
        class UFO {
            constructor(x, y, type, direction) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.direction = direction;
                this.active = true;
                this.hp = 1;
                this.size = type.size;
                this.speed = type.speed;
                this.points = type.points;
                this.color = type.color;
                this.rotation = 0;
                this.glowPulse = 0;
                this.oscillationTimer = 0;
                this.baseY = y;
                this.trailParticles = [];
                this.warpEffect = 60;
            }
            
            update() {
                if (!this.active) return;
                
                this.rotation += 0.05;
                this.glowPulse += 0.08;
                this.oscillationTimer += 0.03;
                this.warpEffect = Math.max(0, this.warpEffect - 1);
                
                this.x += this.speed * this.direction;
                this.y = this.baseY + Math.sin(this.oscillationTimer) * 15;
                
                if (Math.random() < 0.3) {
                    this.trailParticles.push({
                        x: this.x + (Math.random() - 0.5) * this.size,
                        y: this.y + (Math.random() - 0.5) * this.size,
                        vx: (Math.random() - 0.5) * 2,
                        vy: Math.random() * 2,
                        life: 30,
                        maxLife: 30,
                        color: this.color,
                        size: Math.random() * 3 + 1,
                        active: true
                    });
                }
                
                this.trailParticles = this.trailParticles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life--;
                    particle.active = particle.life > 0;
                    return particle.active;
                });
                
                if ((this.direction > 0 && this.x > config.width + 150) || 
                    (this.direction < 0 && this.x < -150)) {
                    this.active = false;
                }
            }
            
            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) {
                    this.active = false;
                }
            }
            
            draw(ctx) {
                if (!this.active) return;
                
                ctx.save();
                
                this.trailParticles.forEach(particle => {
                    const alpha = particle.life / particle.maxLife;
                    ctx.save();
                    ctx.globalAlpha = alpha * 0.6;
                    ctx.fillStyle = particle.color;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = particle.color;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
                
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                const pulseIntensity = Math.sin(this.glowPulse) * 0.4 + 0.6;
                const warpAlpha = this.warpEffect > 0 ? (60 - this.warpEffect) / 60 : 1;
                
                ctx.save();
                ctx.globalAlpha = warpAlpha;
                
                ctx.fillStyle = this.color + '77';
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.shadowBlur = 25 + (pulseIntensity * 15);
                ctx.shadowColor = this.color;
                
                ctx.beginPath();
                ctx.ellipse(0, -5, this.size * 0.6, this.size * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                ctx.beginPath();
                ctx.ellipse(0, 5, this.size, this.size * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                const lightPhase = Math.sin(this.glowPulse * 2) > 0.5;
                if (lightPhase) {
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ffffff';
                    
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI * 2 * i) / 6;
                        const lightX = Math.cos(angle) * this.size * 0.8;
                        const lightY = Math.sin(angle) * this.size * 0.2 + 5;
                        
                        ctx.beginPath();
                        ctx.arc(lightX, lightY, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                ctx.font = 'bold 12px Courier New';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#ffffff';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffffff';
                ctx.globalAlpha = warpAlpha * 0.8;
                
                if (this.type.type === 'mothership') {
                    ctx.fillText('◊', 0, 2);
                } else if (this.type.type === 'cruiser') {
                    ctx.fillText('◆', 0, 2);
                } else {
                    ctx.fillText('•', 0, 2);
                }
                
                if (this.warpEffect > 0) {
                    ctx.globalAlpha = (this.warpEffect / 60) * 0.8;
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    const warpSize = this.size * (1 + (this.warpEffect / 20));
                    
                    ctx.beginPath();
                    ctx.arc(0, 0, warpSize, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.arc(0, 0, warpSize * 1.5, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.restore();
                ctx.restore();
            }
        }
        
        // Formation Manager (simplified)
        class FormationManager {
            constructor() {
                this.formations = [];
                this.formationTimer = 0;
                this.formationSpawnRate = 300;
            }
            
            update() {
                this.formationTimer++;
                
                if (this.formationTimer > this.formationSpawnRate && Math.random() < 0.3) {
                    this.spawnFormation();
                    this.formationTimer = 0;
                }
                
                this.formations.forEach(formation => {
                    if (formation.active) {
                        formation.update();
                    }
                });
                
                this.formations = this.formations.filter(f => f.active);
            }
            
            spawnFormation() {
                if (!gameState || gameState.enemies.length > 12) return;
                
                const formationTypes = ['vee'];
                const type = formationTypes[Math.floor(Math.random() * formationTypes.length)];
                
                let formation;
                switch(type) {
                    case 'vee':
                        formation = new VeeFormation();
                        break;
                }
                
                if (formation) {
                    this.formations.push(formation);
                }
            }
        }
        
        class VeeFormation {
            constructor() {
                this.active = true;
                this.enemies = [];
                this.leaderId = null;
                this.centerX = Math.random() * (config.width - 200) + 100;
                this.y = -100;
                this.speed = 2;
                this.formationTimer = 0;
                
                const leaderEnemy = new Enemy(this.centerX, this.y, 'square');
                leaderEnemy.isFormationLeader = true;
                leaderEnemy.formationBonus = 500;
                leaderEnemy.color = '#ffaa00';
                leaderEnemy.points = 400;
                this.leaderId = leaderEnemy;
                gameState.enemies.push(leaderEnemy);
                this.enemies.push(leaderEnemy);
                
                for (let i = 1; i <= 4; i++) {
                    const side = i % 2 === 1 ? -1 : 1;
                    const distance = Math.ceil(i / 2) * 40;
                    const follower = new Enemy(
                        this.centerX + (side * distance),
                        this.y - (Math.ceil(i / 2) * 30),
                        'triangle'
                    );
                    follower.isFormationFollower = true;
                    follower.formationLeader = leaderEnemy;
                    follower.formationOffset = { x: side * distance, y: -(Math.ceil(i / 2) * 30) };
                    follower.points = 150;
                    gameState.enemies.push(follower);
                    this.enemies.push(follower);
                }
                
                setTimeout(() => {
                    if (soundSystem) {
                        soundSystem.playVoiceSample('GET READY');
                    }
                }, 500);
            }
            
            update() {
                this.formationTimer++;
                
                if (this.leaderId && this.leaderId.active) {
                    this.leaderId.y += this.speed;
                    
                    this.enemies.forEach(enemy => {
                        if (enemy.isFormationFollower && enemy.active) {
                            enemy.x = this.leaderId.x + enemy.formationOffset.x;
                            enemy.y = this.leaderId.y + enemy.formationOffset.y;
                        }
                    });
                    
                    if (this.formationTimer > 60) {
                        this.leaderId.x += Math.sin(this.formationTimer * 0.02) * 2;
                    }
                } else {
                    this.enemies.forEach(enemy => {
                        if (enemy.isFormationFollower && enemy.active) {
                            enemy.behavior = 'aggressive';
                            enemy.isFormationFollower = false;
                            enemy.speed += 1;
                        }
                    });
                    this.active = false;
                }
                
                if (this.leaderId && this.leaderId.y > config.height + 100) {
                    this.active = false;
                }
                
                this.enemies = this.enemies.filter(e => e.active);
                if (this.enemies.length === 0) {
                    this.active = false;
                }
            }
        }
        
        // Sound System
        class SoundSystem {
            constructor() {
                this.enabled = true;
                this.audioContext = null;
                
                try {
                    window.AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.audioContext = new AudioContext();
                } catch (e) {
                    console.log('Web Audio API not supported');
                    this.enabled = false;
                }
            }
            
            playShoot() {
                if (!this.enabled || !this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(400, this.audioContext.currentTime + 0.1);
                
                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.1);
            }
            
            playExplosion() {
                if (!this.enabled || !this.audioContext) return;
                
                const noise = this.audioContext.createBufferSource();
                const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.2, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < buffer.length; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                noise.buffer = buffer;
                
                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(1000, this.audioContext.currentTime);
                filter.frequency.exponentialRampToValueAtTime(100, this.audioContext.currentTime + 0.2);
                
                const gainNode = this.audioContext.createGain();
                gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                
                noise.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                noise.start();
            }
            
            playPowerUp() {
                if (!this.enabled || !this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(400, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.2);
                
                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.2);
            }
            
            playCombo(comboLevel) {
                if (!this.enabled || !this.audioContext) return;
                
                const baseFreq = 300 + (comboLevel * 50);
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(baseFreq, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(baseFreq * 2, this.audioContext.currentTime + 0.1);
                
                gainNode.gain.setValueAtTime(0.08, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.1);
            }
            
            playCoinDrop() {
                if (!this.enabled || !this.audioContext) return;
                
                const oscillator1 = this.audioContext.createOscillator();
                const oscillator2 = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator1.connect(gainNode);
                oscillator2.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator1.type = 'sine';
                oscillator2.type = 'sine';
                
                oscillator1.frequency.setValueAtTime(800, this.audioContext.currentTime);
                oscillator1.frequency.exponentialRampToValueAtTime(600, this.audioContext.currentTime + 0.1);
                
                oscillator2.frequency.setValueAtTime(700, this.audioContext.currentTime + 0.15);
                oscillator2.frequency.exponentialRampToValueAtTime(500, this.audioContext.currentTime + 0.25);
                
                gainNode.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                
                oscillator1.start();
                oscillator1.stop(this.audioContext.currentTime + 0.1);
                
                oscillator2.start(this.audioContext.currentTime + 0.15);
                oscillator2.stop(this.audioContext.currentTime + 0.25);
            }
            
            playVoiceSample(message) {
                if (!this.enabled || !this.audioContext) return;
                
                const voicePatterns = {
                    'GET READY': [
                        {freq: 150, duration: 0.2, type: 'sawtooth'},
                        {freq: 200, duration: 0.15, type: 'sawtooth'},
                        {freq: 180, duration: 0.25, type: 'sawtooth'}
                    ],
                    'EXCELLENT': [
                        {freq: 220, duration: 0.18, type: 'square'},
                        {freq: 180, duration: 0.12, type: 'square'},
                        {freq: 200, duration: 0.15, type: 'square'},
                        {freq: 160, duration: 0.2, type: 'square'}
                    ],
                    'OUTSTANDING': [
                        {freq: 200, duration: 0.15, type: 'sawtooth'},
                        {freq: 250, duration: 0.12, type: 'sawtooth'},
                        {freq: 180, duration: 0.18, type: 'sawtooth'},
                        {freq: 220, duration: 0.15, type: 'sawtooth'}
                    ],
                    'PERFECT': [
                        {freq: 250, duration: 0.18, type: 'triangle'},
                        {freq: 200, duration: 0.15, type: 'triangle'},
                        {freq: 180, duration: 0.2, type: 'triangle'}
                    ],
                    'RADICAL': [
                        {freq: 220, duration: 0.15, type: 'square'},
                        {freq: 200, duration: 0.12, type: 'square'},
                        {freq: 180, duration: 0.18, type: 'square'}
                    ],
                    'GODLIKE': [
                        {freq: 300, duration: 0.2, type: 'sawtooth'},
                        {freq: 250, duration: 0.15, type: 'sawtooth'},
                        {freq: 280, duration: 0.18, type: 'sawtooth'},
                        {freq: 320, duration: 0.22, type: 'sawtooth'}
                    ],
                    'GAME OVER': [
                        {freq: 120, duration: 0.3, type: 'sawtooth'},
                        {freq: 100, duration: 0.25, type: 'sawtooth'},
                        {freq: 80, duration: 0.4, type: 'sawtooth'}
                    ],
                    'CONTINUE': [
                        {freq: 180, duration: 0.2, type: 'triangle'},
                        {freq: 200, duration: 0.15, type: 'triangle'},
                        {freq: 160, duration: 0.25, type: 'triangle'}
                    ]
                };
                
                const pattern = voicePatterns[message];
                if (!pattern) return;
                
                let currentTime = this.audioContext.currentTime;
                
                pattern.forEach((segment, index) => {
                    setTimeout(() => {
                        if (!this.enabled || !this.audioContext) return;
                        
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        const filter = this.audioContext.createBiquadFilter();
                        
                        oscillator.connect(filter);
                        filter.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        oscillator.type = segment.type;
                        oscillator.frequency.setValueAtTime(segment.freq, this.audioContext.currentTime);
                        
                        oscillator.frequency.linearRampToValueAtTime(
                            segment.freq * 0.95, 
                            this.audioContext.currentTime + segment.duration * 0.5
                        );
                        oscillator.frequency.linearRampToValueAtTime(
                            segment.freq * 1.02, 
                            this.audioContext.currentTime + segment.duration
                        );
                        
                        filter.type = 'lowpass';
                        filter.frequency.setValueAtTime(1200, this.audioContext.currentTime);
                        
                        gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                        gainNode.gain.linearRampToValueAtTime(0.12, this.audioContext.currentTime + 0.02);
                        gainNode.gain.linearRampToValueAtTime(0.08, this.audioContext.currentTime + segment.duration * 0.8);
                        gainNode.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + segment.duration);
                        
                        oscillator.start(this.audioContext.currentTime);
                        oscillator.stop(this.audioContext.currentTime + segment.duration);
                        
                    }, index * 150);
                });
                
                this.showVoiceMessage(message);
            }
            
            showVoiceMessage(message) {
                if (typeof gameState !== 'undefined' && gameState && gameState.particles) {
                    const voiceParticle = {
                        x: config.width / 2,
                        y: 80,
                        message: message,
                        life: 120,
                        maxLife: 120,
                        scale: 0.8,
                        alpha: 1,
                        active: true,
                        update() {
                            this.life--;
                            if (this.life < 30) {
                                this.alpha -= 0.03;
                            }
                            if (this.life <= 0) this.active = false;
                        },
                        draw(ctx) {
                            if (!this.active) return;
                            
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.scale(this.scale, this.scale);
                            
                            ctx.font = 'bold 24px Courier New';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            
                            let color = '#00ff00';
                            if (this.message === 'EXCELLENT' || this.message === 'RADICAL') color = '#ffff00';
                            if (this.message === 'OUTSTANDING') color = '#ff00ff';
                            if (this.message === 'PERFECT') color = '#00ffff';
                            if (this.message === 'GAME OVER') color = '#ff0000';
                            
                            ctx.fillStyle = color;
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = color;
                            ctx.globalAlpha = this.alpha;
                            
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 2;
                            ctx.strokeText(`"${this.message}!"`, 0, 0);
                            ctx.fillText(`"${this.message}!"`, 0, 0);
                            
                            ctx.restore();
                        }
                    };
                    
                    gameState.particles.push(voiceParticle);
                }
            }
            
            playUFOAppear() {
                if (!this.enabled || !this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                const filter = this.audioContext.createBiquadFilter();
                
                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(60, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 0.5);
                oscillator.frequency.exponentialRampToValueAtTime(80, this.audioContext.currentTime + 1.0);
                
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(800, this.audioContext.currentTime);
                filter.frequency.exponentialRampToValueAtTime(1200, this.audioContext.currentTime + 0.3);
                filter.frequency.exponentialRampToValueAtTime(400, this.audioContext.currentTime + 1.0);
                
                gainNode.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.25, this.audioContext.currentTime + 0.3);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 1.0);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 1.0);
            }
            
            playUFODestroy() {
                if (!this.enabled || !this.audioContext) return;
                
                const oscillator1 = this.audioContext.createOscillator();
                const oscillator2 = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                const filter = this.audioContext.createBiquadFilter();
                
                oscillator1.connect(filter);
                oscillator2.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator1.type = 'sawtooth';
                oscillator1.frequency.setValueAtTime(800, this.audioContext.currentTime);
                oscillator1.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 0.3);
                
                oscillator2.type = 'sine';
                oscillator2.frequency.setValueAtTime(1000, this.audioContext.currentTime + 0.1);
                oscillator2.frequency.exponentialRampToValueAtTime(1500, this.audioContext.currentTime + 0.4);
                
                filter.type = 'bandpass';
                filter.frequency.setValueAtTime(600, this.audioContext.currentTime);
                filter.Q.setValueAtTime(2, this.audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                
                oscillator1.start();
                oscillator1.stop(this.audioContext.currentTime + 0.3);
                
                oscillator2.start(this.audioContext.currentTime + 0.1);
                oscillator2.stop(this.audioContext.currentTime + 0.5);
            }
            
            // 🎵 FEVER MODE TECHNO BEAT
            playFeverBeat() {
                if (!this.enabled || !this.audioContext) return;
                
                // Kick drum pattern
                const playKick = () => {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(60, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(40, this.audioContext.currentTime + 0.1);
                    
                    gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                    
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.1);
                };
                
                // Play beat pattern
                playKick();
                setTimeout(() => playKick(), 250);
                setTimeout(() => playKick(), 500);
                setTimeout(() => playKick(), 750);
            }
        }

        // 📺 VHS GLITCH EFFECTS SYSTEM
        class VHSGlitchEffects {
            constructor() {
                this.glitchTimer = 0;
                this.scanlineOffset = 0;
                this.colorSeparation = 0;
                this.noiseIntensity = 0;
                this.horizontalDistortion = [];
                this.staticLines = [];
                this.chromaShift = 0;
                this.trackingError = 0;
                
                this.generateStaticLines();
            }
            
            generateStaticLines() {
                this.staticLines = [];
                for (let i = 0; i < 200; i++) {
                    this.staticLines.push({
                        y: Math.random() * config.height,
                        intensity: Math.random(),
                        speed: Math.random() * 2 + 0.5,
                        life: Math.random() * 60 + 30
                    });
                }
            }
            
            triggerGlitch(intensity = 1) {
                this.glitchTimer = 60 * intensity;
                this.colorSeparation = 5 * intensity;
                this.noiseIntensity = 0.3 * intensity;
                this.trackingError = 10 * intensity;
                
                // Generate horizontal distortion lines
                this.horizontalDistortion = [];
                for (let i = 0; i < 10; i++) {
                    this.horizontalDistortion.push({
                        y: Math.random() * config.height,
                        offset: (Math.random() - 0.5) * 50 * intensity,
                        height: Math.random() * 20 + 5,
                        life: Math.random() * 30 + 15
                    });
                }
            }
            
            update() {
                if (this.glitchTimer > 0) {
                    this.glitchTimer--;
                    this.scanlineOffset = Math.sin(Date.now() * 0.01) * 2;
                    this.chromaShift = Math.sin(Date.now() * 0.02) * this.colorSeparation;
                    
                    // Update distortion lines
                    this.horizontalDistortion = this.horizontalDistortion.filter(line => {
                        line.life--;
                        line.offset += (Math.random() - 0.5) * 2;
                        return line.life > 0;
                    });
                    
                    // Update static lines
                    this.staticLines.forEach(line => {
                        line.y += line.speed;
                        line.life--;
                        if (line.y > config.height || line.life <= 0) {
                            line.y = -5;
                            line.intensity = Math.random();
                            line.life = Math.random() * 60 + 30;
                        }
                    });
                }
            }
            
            apply(ctx) {
                if (this.glitchTimer <= 0) return;
                
                ctx.save();
                
                // RGB color separation
                if (this.colorSeparation > 0) {
                    ctx.globalCompositeOperation = 'screen';
                    ctx.globalAlpha = 0.1;
                    
                    // Red channel shift
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(this.chromaShift, 0, config.width, config.height);
                    
                    // Blue channel shift
                    ctx.fillStyle = '#0000ff';
                    ctx.fillRect(-this.chromaShift, 0, config.width, config.height);
                    
                    ctx.globalCompositeOperation = 'source-over';
                }
                
                // Horizontal distortion lines
                ctx.globalAlpha = 0.8;
                this.horizontalDistortion.forEach(line => {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fillRect(line.offset, line.y, config.width, line.height);
                    
                    // Tracking error effect
                    if (Math.random() < 0.3) {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                        ctx.fillRect(0, line.y, config.width, 2);
                    }
                });
                
                // TV static lines
                ctx.globalAlpha = this.noiseIntensity;
                this.staticLines.forEach(line => {
                    if (line.life > 0) {
                        ctx.fillStyle = `rgba(255, 255, 255, ${line.intensity})`;
                        ctx.fillRect(0, line.y, config.width, 1);
                    }
                });
                
                // Scanline interference
                if (this.trackingError > 0) {
                    ctx.globalAlpha = 0.05;
                    ctx.fillStyle = '#ffffff';
                    for (let y = this.scanlineOffset; y < config.height; y += 4) {
                        ctx.fillRect(0, y, config.width, 1);
                    }
                }
                
                ctx.restore();
            }
        }
        
        // 📊 OSCILLOSCOPE UI SYSTEM
        class OscilloscopeUI {
            constructor() {
                this.scanLines = [];
                this.phosphorTrails = [];
                this.sweepTimer = 0;
                this.signalData = [];
                
                // Generate oscilloscope grid
                this.generateScanLines();
            }
            
            generateScanLines() {
                // Horizontal scan lines for retro monitor effect
                for (let i = 0; i < config.height / 3; i++) {
                    this.scanLines.push({
                        y: i * 3,
                        brightness: 0.3 + Math.random() * 0.4,
                        flickerSpeed: 0.01 + Math.random() * 0.02
                    });
                }
            }
            
            update() {
                this.sweepTimer += 0.05;
                
                // Update phosphor trails
                this.phosphorTrails = this.phosphorTrails.filter(trail => {
                    trail.life -= 2;
                    trail.brightness *= 0.95;
                    return trail.life > 0;
                });
                
                // Generate signal data for scope displays
                this.signalData = [];
                for (let i = 0; i < 100; i++) {
                    this.signalData.push({
                        x: i * 2,
                        y: Math.sin(this.sweepTimer + i * 0.1) * 20 + 50,
                        intensity: Math.sin(this.sweepTimer * 2 + i * 0.2) * 0.5 + 0.5
                    });
                }
            }
            
            drawScanLines(ctx) {
                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.globalAlpha = 0.03;
                
                this.scanLines.forEach(line => {
                    const flicker = Math.sin(Date.now() * line.flickerSpeed) * 0.3 + 0.7;
                    ctx.fillStyle = `rgba(0, 255, 100, ${line.brightness * flicker})`;
                    ctx.fillRect(0, line.y, config.width, 1);
                });
                
                ctx.restore();
            }
            
            drawOscilloscopeDisplay(ctx, x, y, width, height, data, color = '#00ff00') {
                ctx.save();
                ctx.translate(x, y);
                
                // Monitor bezel
                ctx.fillStyle = 'rgba(20, 20, 20, 0.9)';
                ctx.fillRect(-5, -5, width + 10, height + 10);
                
                // Screen
                ctx.fillStyle = 'rgba(0, 20, 0, 0.8)';
                ctx.fillRect(0, 0, width, height);
                
                // Grid lines
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
                ctx.lineWidth = 0.5;
                
                // Horizontal grid
                for (let i = 0; i <= height; i += height / 5) {
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(width, i);
                    ctx.stroke();
                }
                
                // Vertical grid
                for (let i = 0; i <= width; i += width / 8) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, height);
                    ctx.stroke();
                }
                
                // Signal trace
                if (data && data.length > 1) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = color;
                    
                    ctx.beginPath();
                    ctx.moveTo(0, data[0]);
                    
                    for (let i = 1; i < data.length; i++) {
                        ctx.lineTo((i / data.length) * width, data[i]);
                    }
                    ctx.stroke();
                    
                    // Phosphor trail effect
                    ctx.globalAlpha = 0.3;
                    ctx.lineWidth = 4;
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }
        
        // 🎆 EPIC 80S EXPLOSION SYSTEM
        class Epic80sExplosion {
            constructor(x, y, size = 1) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.particles = [];
                this.shockwaves = [];
                this.sparks = [];
                this.debris = [];
                this.life = 120;
                this.maxLife = 120;
                this.active = true;
                
                this.generateParticles();
                this.generateShockwaves();
                this.generateSparks();
                this.generateDebris();
            }
            
            generateParticles() {
                const particleCount = 60 * this.size;
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = (Math.PI * 2 * i) / particleCount;
                    const speed = (5 + Math.random() * 15) * this.size;
                    
                    this.particles.push({
                        x: this.x,
                        y: this.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        color: i % 4 === 0 ? '#ffffff' : 
                               i % 4 === 1 ? '#ffff00' : 
                               i % 4 === 2 ? '#ff6600' : '#ff0000',
                        size: Math.random() * 6 + 3,
                        life: 80 + Math.random() * 40,
                        maxLife: 120,
                        gravity: 0.1,
                        friction: 0.98,
                        type: 'fire'
                    });
                }
            }
            
            generateShockwaves() {
                for (let i = 0; i < 3; i++) {
                    this.shockwaves.push({
                        x: this.x,
                        y: this.y,
                        radius: 0,
                        maxRadius: (100 + i * 50) * this.size,
                        speed: (8 + i * 3) * this.size,
                        life: 60,
                        maxLife: 60,
                        color: i === 0 ? '#ffffff' : i === 1 ? '#ffff00' : '#ff6600'
                    });
                }
            }
            
            generateSparks() {
                const sparkCount = 40 * this.size;
                
                for (let i = 0; i < sparkCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = (3 + Math.random() * 8) * this.size;
                    
                    this.sparks.push({
                        x: this.x,
                        y: this.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        color: '#ffffff',
                        size: Math.random() * 2 + 1,
                        life: 30 + Math.random() * 20,
                        trail: [],
                        maxTrailLength: 8
                    });
                }
            }
            
            generateDebris() {
                const debrisCount = 20 * this.size;
                
                for (let i = 0; i < debrisCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = (2 + Math.random() * 6) * this.size;
                    
                    this.debris.push({
                        x: this.x,
                        y: this.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 2,
                        color: Math.random() > 0.5 ? '#666666' : '#444444',
                        size: Math.random() * 4 + 2,
                        life: 100 + Math.random() * 50,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.3,
                        gravity: 0.15,
                        bounce: 0.3
                    });
                }
            }
            
            update() {
                this.life--;
                
                // Update particles
                this.particles = this.particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += p.gravity;
                    p.vx *= p.friction;
                    p.vy *= p.friction;
                    p.life--;
                    return p.life > 0;
                });
                
                // Update shockwaves
                this.shockwaves = this.shockwaves.filter(s => {
                    s.radius += s.speed;
                    s.life--;
                    return s.life > 0 && s.radius < s.maxRadius;
                });
                
                // Update sparks
                this.sparks = this.sparks.filter(s => {
                    s.trail.push({x: s.x, y: s.y, life: 10});
                    s.trail = s.trail.filter(t => {
                        t.life--;
                        return t.life > 0;
                    });
                    
                    if (s.trail.length > s.maxTrailLength) {
                        s.trail.shift();
                    }
                    
                    s.x += s.vx;
                    s.y += s.vy;
                    s.vy += 0.1;
                    s.vx *= 0.99;
                    s.life--;
                    return s.life > 0;
                });
                
                // Update debris
                this.debris = this.debris.filter(d => {
                    d.x += d.vx;
                    d.y += d.vy;
                    d.vy += d.gravity;
                    d.rotation += d.rotationSpeed;
                    
                    // Ground bounce
                    if (d.y > config.height - d.size && d.vy > 0) {
                        d.vy *= -d.bounce;
                        d.vx *= 0.8;
                    }
                    
                    d.life--;
                    return d.life > 0;
                });
                
                if (this.life <= 0 && this.particles.length === 0 && 
                    this.shockwaves.length === 0 && this.sparks.length === 0) {
                    this.active = false;
                }
            }
            
            draw(ctx) {
                ctx.save();
                
                // Draw shockwaves
                this.shockwaves.forEach(s => {
                    const alpha = s.life / s.maxLife;
                    ctx.strokeStyle = s.color;
                    ctx.lineWidth = 4;
                    ctx.globalAlpha = alpha;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = s.color;
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2);
                    ctx.stroke();
                });
                
                // Draw debris
                this.debris.forEach(d => {
                    const alpha = d.life / 150;
                    ctx.save();
                    ctx.translate(d.x, d.y);
                    ctx.rotate(d.rotation);
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = d.color;
                    ctx.fillRect(-d.size/2, -d.size/2, d.size, d.size);
                    ctx.restore();
                });
                
                // Draw spark trails
                this.sparks.forEach(s => {
                    if (s.trail.length > 1) {
                        ctx.strokeStyle = s.color;
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = s.color;
                        
                        ctx.beginPath();
                        ctx.moveTo(s.trail[0].x, s.trail[0].y);
                        
                        for (let i = 1; i < s.trail.length; i++) {
                            const alpha = s.trail[i].life / 10;
                            ctx.globalAlpha = alpha;
                            ctx.lineTo(s.trail[i].x, s.trail[i].y);
                        }
                        ctx.stroke();
                    }
                });
                
                // Draw fire particles
                this.particles.forEach(p => {
                    const alpha = p.life / p.maxLife;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = p.color;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.restore();
            }
        }
        class RadicalSlang {
            constructor() {
                this.phrases = [
                    { text: "RADICAL!", minCombo: 3 },
                    { text: "TUBULAR!", minCombo: 5 },
                    { text: "GNARLY!", minCombo: 8 },
                    { text: "BODACIOUS!", minCombo: 12 },
                    { text: "WICKED!", minCombo: 15 },
                    { text: "AWESOME!", minCombo: 20 },
                    { text: "RIGHTEOUS!", minCombo: 25 },
                    { text: "GROOVY!", minCombo: 30 },
                    { text: "FAR OUT!", minCombo: 40 }
                ];
                this.activeText = null;
                this.x = config.width / 2;
                this.y = config.height / 2;
                this.scale = 0;
                this.alpha = 0;
                this.lifetime = 0;
            }
            
            trigger(combo) {
                for (let i = this.phrases.length - 1; i >= 0; i--) {
                    if (combo >= this.phrases[i].minCombo) {
                        this.activeText = this.phrases[i].text;
                        this.scale = 0.5;
                        this.alpha = 1;
                        this.lifetime = 60;
                        this.x = config.width / 2 + (Math.random() - 0.5) * 100;
                        this.y = config.height / 2 + (Math.random() - 0.5) * 100;
                        
                        if (soundSystem && combo >= 25) {
                            setTimeout(() => soundSystem.playVoiceSample('RADICAL'), 100);
                        }
                        
                        break;
                    }
                }
            }
            
            update() {
                if (this.lifetime > 0) {
                    this.lifetime--;
                    this.scale += 0.02;
                    if (this.lifetime < 20) {
                        this.alpha -= 0.05;
                    }
                }
            }
            
            draw(ctx) {
                if (this.lifetime > 0 && this.activeText) {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.scale(this.scale, this.scale);
                    ctx.rotate(Math.sin(this.lifetime * 0.1) * 0.1);
                    
                    ctx.font = 'bold 48px Courier New';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    const gradient = ctx.createLinearGradient(-100, 0, 100, 0);
                    gradient.addColorStop(0, '#ff00ff');
                    gradient.addColorStop(0.5, '#00ffff');
                    gradient.addColorStop(1, '#ffff00');
                    
                    ctx.fillStyle = gradient;
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = this.alpha;
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#ff00ff';
                    
                    ctx.strokeText(this.activeText, 0, 0);
                    ctx.fillText(this.activeText, 0, 0);
                    
                    ctx.restore();
                }
            }
        }

        // Particle Classes  
        class Particle {
            constructor(x, y, vx, vy, color) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = 30;
                this.maxLife = 30;
                this.size = Math.random() * 3 + 1;
                this.active = true;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life--;
                
                if (this.life <= 0) {
                    this.active = false;
                }
            }
            
            draw(ctx) {
                const alpha = this.life / this.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class MuzzleParticle extends Particle {
            constructor(x, y, vx, vy, color) {
                super(x, y, vx, vy, color);
                this.life = 10;
                this.maxLife = 10;
                this.size = 2;
            }
        }

        class ScorePopup {
            constructor(x, y, score, color, isCombo = false) {
                this.x = x;
                this.y = y;
                this.score = score;
                this.color = color;
                this.life = 60;
                this.maxLife = 60;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = -3;
                this.scale = isCombo ? 1 : 0.5;
                this.targetScale = isCombo ? 1.5 : 1;
                this.active = true;
                this.isCombo = isCombo;
            }
            
            update() {
                if (!this.active) return;
                
                this.life--;
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.1;
                
                if (this.life > 50) {
                    this.scale += (this.targetScale - this.scale) * 0.2;
                } else {
                    this.scale *= 0.98;
                }
                
                if (this.life <= 0) {
                    this.active = false;
                }
            }
            
            draw(ctx) {
                if (!this.active) return;
                
                const alpha = this.life / this.maxLife;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.scale, this.scale);
                
                ctx.font = this.isCombo ? 'bold 32px Courier New' : 'bold 24px Courier New';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.color;
                ctx.globalAlpha = alpha;
                
                if (this.isCombo) {
                    const gradient = ctx.createLinearGradient(-50, 0, 50, 0);
                    gradient.addColorStop(0, '#ffff00');
                    gradient.addColorStop(0.5, this.color);
                    gradient.addColorStop(1, '#ff00ff');
                    ctx.fillStyle = gradient;
                } else {
                    ctx.fillStyle = '#ffffff';
                }
                
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.strokeText(`+${this.score}`, 0, 0);
                ctx.fillText(`+${this.score}`, 0, 0);
                
                ctx.restore();
            }
        }

        // Player Class with Enhanced Power-Up Support
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.speed = 5.5;
                this.size = 20;
                this.color = config.colors.player;
                this.weaponLevel = 1;
                this.fireRate = 10;
                this.fireTimer = 0;
                this.invulnerable = false;
                this.invulnerableTimer = 0;
                this.shield = 0;
                this.shieldActive = false;
                this.autoFire = false;
                this.canShoot = true;
                this.isAlive = true;
                this.respawnTimer = 0;
                this.respawnDelay = 60;
                
                // 🌈 FEVER MODE properties
                this.feverMode = 0;
                this.rainbowHue = 0;
                
                // 🔥 NEON TRAIL properties
                this.trail = [];
                this.maxTrailLength = 10;
                this.lastX = x;
                this.lastY = y;
                
                // ⚡ ENHANCED POWER-UP PROPERTIES
                this.hasLaser = false;
                this.laserPower = 1;
                this.hasHoming = false;
                this.homingStrength = 1;
                this.hasSpread = false;
                this.spreadCount = 3;
                this.hasPierce = false;
                this.pierceCount = 2;
                this.hasBounce = false;
                this.bounceCount = 3;
                this.hasChain = false;
                this.chainRange = 80;
                this.magnetRange = 0;
                this.ghostMode = 0;
                this.mirrorShip = 0;
                this.novaReady = false;
                this.novaPower = 1;
                this.vortexActive = 0;
                this.vortexPower = 1;
                this.omegaMode = 0;
                this.freezePower = 0;
                this.reflectActive = 0;
                this.quantumMode = 0;
                this.quantumShots = 3;
                this.plasmaMode = 0;
                this.matrixMode = 0;
                this.infinityMode = 0;
                this.infinitePower = false;
                this.godMode = 0;
                
                // Mirror ship properties
                this.mirrorX = x;
                this.mirrorY = y;
            }
            
            update() {
                // Handle death and respawn
                if (!this.isAlive) {
                    this.respawnTimer--;
                    if (this.respawnTimer <= 0) {
                        this.respawn();
                    }
                    return;
                }
                
                // Store previous position for trail
                this.lastX = this.x;
                this.lastY = this.y;
                
                // Normal movement
                let dx = 0, dy = 0;
                
                if (keys['ArrowLeft'] === true || keys['a'] === true) dx -= this.speed;
                if (keys['ArrowRight'] === true || keys['d'] === true) dx += this.speed;
                if (keys['ArrowUp'] === true || keys['w'] === true) dy -= this.speed;
                if (keys['ArrowDown'] === true || keys['s'] === true) dy += this.speed;
                
                if (touchJoystick.active) {
                    const touchDx = touchJoystick.currentX - touchJoystick.startX;
                    const touchDy = touchJoystick.currentY - touchJoystick.startY;
                    const dist = Math.sqrt(touchDx * touchDx + touchDy * touchDy);
                    if (dist > 10) {
                        dx += (touchDx / dist) * this.speed;
                        dy += (touchDy / dist) * this.speed;
                    }
                }
                
                if (dx !== 0 && dy !== 0) {
                    dx *= 0.707;
                    dy *= 0.707;
                }
                
                this.x = Math.max(this.size, Math.min(config.width - this.size, this.x + dx));
                this.y = Math.max(this.size, Math.min(config.height - this.size, this.y + dy));
                
                // Update mirror ship
                if (this.mirrorShip > 0) {
                    this.mirrorShip--;
                    this.mirrorX = config.width - this.x; // Mirror horizontally
                    this.mirrorY = this.y;
                }
                
                // 🔥 Update trail
                if (Math.abs(dx) > 0 || Math.abs(dy) > 0) {
                    this.trail.push({
                        x: this.lastX,
                        y: this.lastY,
                        life: 1.0
                    });
                    
                    if (this.trail.length > this.maxTrailLength) {
                        this.trail.shift();
                    }
                }
                
                // Update trail fade
                this.trail = this.trail.filter(point => {
                    point.life -= 0.1;
                    return point.life > 0;
                });
                
                // Handle shooting
                this.fireTimer++;
                const currentFireRate = this.hasLaser ? Math.max(3, this.fireRate - this.laserPower) : this.fireRate;
                
                if (this.canShoot && (keys[' '] === true || touchButtons.fire || this.autoFire) && this.fireTimer > currentFireRate) {
                    this.shoot();
                    this.fireTimer = 0;
                }
                
                if (this.invulnerable) {
                    this.invulnerableTimer--;
                    if (this.invulnerableTimer <= 0) {
                        this.invulnerable = false;
                    }
                }
                
                // 🌈 Update fever mode
                if (this.feverMode > 0) {
                    this.feverMode--;
                    this.rainbowHue = (this.rainbowHue + 5) % 360;
                    
                    if (this.feverMode % 15 === 0 && soundSystem) {
                        soundSystem.playFeverBeat();
                    }
                    
                    if (this.feverMode <= 0) {
                        this.invulnerable = false;
                        if (gameState && gameState.enemies) {
                            gameState.enemies.forEach(e => {
                                if (e.behavior === 'flee') {
                                    e.behavior = e.originalBehavior || 'aggressive';
                                    e.points = Math.floor(e.points / 2);
                                    e.color = e.originalColor || '#ff0066';
                                }
                            });
                        }
                    }
                }
                
                // Update enhanced power-up timers
                if (this.ghostMode > 0) {
                    this.ghostMode--;
                    if (this.ghostMode <= 0) {
                        this.invulnerable = false;
                    }
                }
                
                if (this.reflectActive > 0) {
                    this.reflectActive--;
                }
                
                if (this.quantumMode > 0) {
                    this.quantumMode--;
                }
                
                if (this.plasmaMode > 0) {
                    this.plasmaMode--;
                    // Plasma mode gives unlimited energy
                    if (this.fireTimer > 1) this.fireTimer = 1;
                }
                
                if (this.matrixMode > 0) {
                    this.matrixMode--;
                    // Matrix mode enhances perception
                    this.speed = Math.min(this.speed * 1.1, 8);
                }
                
                if (this.infinityMode > 0) {
                    this.infinityMode--;
                }
                
                if (this.godMode > 0) {
                    this.godMode--;
                    if (this.godMode <= 0) {
                        this.invulnerable = false;
                        this.infinitePower = false;
                        this.speed = 5.5; // Reset to normal speed
                    }
                }
                
                // Vortex effect - attract enemies and power-ups
                if (this.vortexActive > 0) {
                    this.vortexActive--;
                    this.applyEnhancedVortexEffect();
                }
                
                // Enhanced Omega mode effects
                if (this.omegaMode > 0) {
                    this.omegaMode--;
                    if (this.omegaMode % 8 === 0) { // More frequent pulses
                        this.createEnhancedOmegaPulse();
                    }
                }
                
                // Magnet effect for power-ups
                if (this.magnetRange > 0) {
                    this.applyMagnetEffect();
                }
            }
            
            shoot() {
                const hasCombo = gameState.powerUpManager && 
                    gameState.powerUpManager.comboEffects.some(c => c.name === 'PULSE CANNON');
                
                if (hasCombo) {
                    // Pulse cannon - rapid laser beams
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            if (bulletPool) {
                                bulletPool.get(this.x, this.y - 20 - i * 5, 0, -18, true);
                            }
                        }, i * 15);
                    }
                } else if (this.quantumMode > 0) {
                    // Quantum shots - multiple parallel dimensions
                    for (let i = 0; i < this.quantumShots; i++) {
                        const offsetX = (i - (this.quantumShots - 1) / 2) * 15;
                        if (bulletPool) {
                            const bullet = bulletPool.get(this.x + offsetX, this.y - 20, 0, -12, true);
                            if (bullet) {
                                bullet.isQuantum = true;
                                bullet.quantumPhase = i;
                                bullet.damage = 3;
                            }
                        }
                    }
                } else if (this.hasChain) {
                    // Chain lightning shots
                    if (bulletPool) {
                        const bullet = bulletPool.get(this.x, this.y - 20, 0, -10, true);
                        if (bullet) {
                            bullet.isChain = true;
                            bullet.chainRange = this.chainRange;
                            bullet.chainCount = 3;
                            bullet.damage = 2;
                        }
                    }
                } else if (this.hasBounce) {
                    // Bouncing projectiles
                    if (bulletPool) {
                        const bullet = bulletPool.get(this.x, this.y - 20, 0, -10, true);
                        if (bullet) {
                            bullet.isBouncing = true;
                            bullet.bounceCount = this.bounceCount;
                            bullet.damage = 2;
                        }
                    }
                } else if (this.hasSpread) {
                    // Enhanced spread shot
                    const spreadAngle = Math.PI / 6;
                    const count = Math.min(this.spreadCount + (this.weaponLevel - 1), 9);
                    for (let i = 0; i < count; i++) {
                        const angle = -spreadAngle + (i * (spreadAngle * 2) / (count - 1));
                        if (bulletPool) {
                            bulletPool.get(
                                this.x + Math.sin(angle) * 15, 
                                this.y - 20, 
                                Math.sin(angle) * 8, 
                                -10 - Math.cos(angle) * 3, 
                                true
                            );
                        }
                    }
                } else if (this.hasLaser) {
                    // Enhanced laser beam
                    const beamCount = Math.min(this.laserPower + Math.floor(this.weaponLevel / 2), 6);
                    for (let i = 0; i < beamCount; i++) {
                        const offsetX = (i - (beamCount - 1) / 2) * 8;
                        if (bulletPool) {
                            const bullet = bulletPool.get(this.x + offsetX, this.y - 20, 0, -18, true);
                            if (bullet) {
                                bullet.isLaser = true;
                                bullet.damage = 2 + Math.floor(this.laserPower / 2);
                            }
                        }
                    }
                } else {
                    // Enhanced normal weapon levels
                    switch(this.weaponLevel) {
                        case 1:
                            if (bulletPool) bulletPool.get(this.x, this.y - 20, 0, -12, true);
                            break;
                        case 2:
                            if (bulletPool) {
                                bulletPool.get(this.x - 12, this.y - 20, 0, -12, true);
                                bulletPool.get(this.x + 12, this.y - 20, 0, -12, true);
                            }
                            break;
                        case 3:
                            if (bulletPool) {
                                bulletPool.get(this.x, this.y - 20, 0, -12, true);
                                bulletPool.get(this.x - 18, this.y - 20, -2, -12, true);
                                bulletPool.get(this.x + 18, this.y - 20, 2, -12, true);
                            }
                            break;
                        case 4:
                            if (bulletPool) {
                                bulletPool.get(this.x - 8, this.y - 20, 0, -12, true);
                                bulletPool.get(this.x + 8, this.y - 20, 0, -12, true);
                                bulletPool.get(this.x - 20, this.y - 20, -3, -12, true);
                                bulletPool.get(this.x + 20, this.y - 20, 3, -12, true);
                            }
                            break;
                        case 5:
                            if (bulletPool) {
                                bulletPool.get(this.x, this.y - 20, 0, -12, true);
                                bulletPool.get(this.x - 12, this.y - 20, -1, -12, true);
                                bulletPool.get(this.x + 12, this.y - 20, 1, -12, true);
                                bulletPool.get(this.x - 24, this.y - 20, -4, -12, true);
                                bulletPool.get(this.x + 24, this.y - 20, 4, -12, true);
                            }
                            break;
                    }
                }
                
                // Mirror ship shooting (enhanced)
                if (this.mirrorShip > 0 && bulletPool) {
                    const mirrorCount = this.godMode > 0 ? 3 : 1;
                    for (let i = 0; i < mirrorCount; i++) {
                        const offsetY = i * -10;
                        bulletPool.get(this.mirrorX, this.mirrorY - 20 + offsetY, 0, -12, true);
                    }
                }
                
                // God mode multi-directional shooting
                if (this.godMode > 0) {
                    const directions = 8;
                    for (let i = 0; i < directions; i++) {
                        const angle = (Math.PI * 2 * i) / directions;
                        if (bulletPool) {
                            bulletPool.get(
                                this.x + Math.cos(angle) * 20,
                                this.y + Math.sin(angle) * 20,
                                Math.cos(angle) * 8,
                                Math.sin(angle) * 8,
                                true
                            );
                        }
                    }
                }
                
                // Infinity mode continuous fire
                if (this.infinityMode > 0 || this.infinitePower) {
                    setTimeout(() => {
                        if ((this.infinityMode > 0 || this.infinitePower) && bulletPool) {
                            bulletPool.get(this.x + Math.random() * 40 - 20, this.y - 25, 
                                         (Math.random() - 0.5) * 4, -15, true);
                        }
                    }, 50);
                }
                
                // Enhanced nova blast
                if (this.novaReady && keys[' '] === true) {
                    this.triggerEnhancedNova();
                    this.novaReady = false;
                }
                
                if (particleSystem) {
                    particleSystem.addMuzzleFlash(this.x, this.y - 20, -Math.PI/2, this.color);
                }
                if (soundSystem) {
                    soundSystem.playShoot();
                }
            }
            
            applyEnhancedVortexEffect() {
                if (!gameState) return;
                
                const baseRange = 200 + (this.vortexPower * 50);
                
                // Attract enemies with enhanced force
                gameState.enemies.forEach(enemy => {
                    if (enemy.active) {
                        const dx = this.x - enemy.x;
                        const dy = this.y - enemy.y;
                        const dist = Math.hypot(dx, dy);
                        
                        if (dist < baseRange) {
                            const force = Math.max(1, (baseRange - dist) / baseRange * (3 + this.vortexPower));
                            const angle = Math.atan2(dy, dx);
                            enemy.x += Math.cos(angle) * force;
                            enemy.y += Math.sin(angle) * force;
                            
                            // Damage enemies that get too close
                            if (dist < 50 && Math.random() < 0.1) {
                                enemy.takeDamage(1);
                                if (particleSystem) {
                                    particleSystem.addExplosion(enemy.x, enemy.y, '#80ff80', 8);
                                }
                            }
                        }
                    }
                });
                
                // Attract power-ups with stronger force
                gameState.powerUps.forEach(powerUp => {
                    if (powerUp.active) {
                        const dx = this.x - powerUp.x;
                        const dy = this.y - powerUp.y;
                        const dist = Math.hypot(dx, dy);
                        
                        if (dist < baseRange) {
                            const force = (baseRange - dist) / baseRange * (4 + this.vortexPower);
                            const angle = Math.atan2(dy, dx);
                            powerUp.x += Math.cos(angle) * force;
                            powerUp.y += Math.sin(angle) * force;
                        }
                    }
                });
                
                // Enhanced visual vortex effect
                if (Math.random() < 0.3) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 60 + Math.random() * baseRange;
                    const particleX = this.x + Math.cos(angle) * radius;
                    const particleY = this.y + Math.sin(angle) * radius;
                    
                    if (particleSystem) {
                        particleSystem.particles.push({
                            x: particleX,
                            y: particleY,
                            vx: -Math.cos(angle) * 5,
                            vy: -Math.sin(angle) * 5,
                            color: '#80ff80',
                            life: 20,
                            maxLife: 20,
                            size: 2,
                            active: true,
                            update() {
                                this.x += this.vx;
                                this.y += this.vy;
                                this.life--;
                                if (this.life <= 0) this.active = false;
                            },
                            draw(ctx) {
                                const alpha = this.life / this.maxLife;
                                ctx.save();
                                ctx.globalAlpha = alpha;
                                ctx.fillStyle = this.color;
                                ctx.shadowBlur = 15;
                                ctx.shadowColor = this.color;
                                ctx.beginPath();
                                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.restore();
                            }
                        });
                    }
                }
            }
            
            createEnhancedOmegaPulse() {
                // Enhanced omega mode creates more destructive pulses
                if (gameState && gameState.particles) {
                    const pulseCount = this.godMode > 0 ? 5 : 3;
                    
                    for (let p = 0; p < pulseCount; p++) {
                        gameState.particles.push({
                            x: this.x + (Math.random() - 0.5) * 120,
                            y: this.y + (Math.random() - 0.5) * 120,
                            radius: 0,
                            maxRadius: 100 + (p * 20),
                            life: 40,
                            maxLife: 40,
                            active: true,
                            damage: 2 + p,
                            update() {
                                this.radius += this.maxRadius / this.maxLife;
                                this.life--;
                                
                                // Damage enemies in range
                                if (gameState && gameState.enemies && this.life % 5 === 0) {
                                    gameState.enemies.forEach(enemy => {
                                        if (enemy.active) {
                                            const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                                            if (dist < this.radius && dist > this.radius - 20) {
                                                enemy.takeDamage(this.damage);
                                            }
                                        }
                                    });
                                }
                                
                                if (this.life <= 0) this.active = false;
                            },
                            draw(ctx) {
                                const alpha = this.life / this.maxLife;
                                ctx.save();
                                ctx.strokeStyle = '#ff0000';
                                ctx.lineWidth = 4;
                                ctx.globalAlpha = alpha;
                                ctx.shadowBlur = 35;
                                ctx.shadowColor = '#ff0000';
                                ctx.beginPath();
                                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                                ctx.stroke();
                                ctx.restore();
                            }
                        });
                    }
                }
            }
            
            triggerEnhancedNova() {
                // Enhanced nova with variable power
                const baseRadius = 300;
                const maxRadius = baseRadius * (this.novaPower + (this.godMode > 0 ? 2 : 0));
                
                if (gameState && gameState.particles) {
                    gameState.particles.push({
                        x: this.x,
                        y: this.y,
                        radius: 0,
                        maxRadius: maxRadius,
                        life: 80,
                        maxLife: 80,
                        active: true,
                        power: this.novaPower,
                        waves: this.godMode > 0 ? 3 : 1,
                        currentWave: 0,
                        update() {
                            this.radius += (this.maxRadius / this.maxLife) * 2;
                            this.life--;
                            
                            // Multi-wave effect for god mode
                            if (this.currentWave < this.waves - 1 && this.radius >= this.maxRadius * 0.8) {
                                this.currentWave++;
                                this.radius = 0;
                                this.life = this.maxLife;
                            }
                            
                            if (this.life <= 0) this.active = false;
                        },
                        draw(ctx) {
                            const alpha = this.life / this.maxLife;
                            ctx.save();
                            
                            // Multiple colored rings
                            const colors = ['#ffff00', '#ff8800', '#ff4400'];
                            colors.forEach((color, index) => {
                                ctx.strokeStyle = color;
                                ctx.lineWidth = 6 - index;
                                ctx.globalAlpha = alpha * (1 - index * 0.2);
                                ctx.shadowBlur = 40;
                                ctx.shadowColor = color;
                                ctx.beginPath();
                                ctx.arc(this.x, this.y, this.radius - (index * 10), 0, Math.PI * 2);
                                ctx.stroke();
                            });
                            
                            ctx.restore();
                        }
                    });
                }
                
                // Enhanced damage area
                if (gameState && gameState.enemies) {
                    gameState.enemies.forEach(enemy => {
                        if (enemy.active) {
                            const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                            if (dist < maxRadius) {
                                const damage = Math.ceil((4 + this.novaPower) * (1 - dist / maxRadius));
                                enemy.takeDamage(damage);
                            }
                        }
                    });
                }
            }
            
            draw(ctx) {
                ctx.save();
                
                // 🔥 Draw neon trail
                if (this.trail.length > 0) {
                    this.trail.forEach((point, index) => {
                        ctx.save();
                        ctx.globalAlpha = point.life * 0.6;
                        
                        // Rainbow trail in fever mode
                        if (this.feverMode > 0) {
                            ctx.fillStyle = `hsl(${(this.rainbowHue - index * 10) % 360}, 100%, 50%)`;
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = ctx.fillStyle;
                        } else {
                            ctx.fillStyle = this.color;
                            ctx.shadowBlur = 15;
                            ctx.shadowColor = this.color;
                        }
                        
                        const size = (this.size * 0.5) * point.life;
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    });
                }
                
                // Draw mirror ship
                if (this.mirrorShip > 0) {
                    ctx.save();
                    ctx.translate(this.mirrorX, this.mirrorY);
                    ctx.globalAlpha = 0.7;
                    
                    ctx.strokeStyle = '#aaffff';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#aaffff';
                    
                    ctx.beginPath();
                    ctx.moveTo(0, -20);
                    ctx.lineTo(-15, 20);
                    ctx.lineTo(0, 10);
                    ctx.lineTo(15, 20);
                    ctx.closePath();
                    ctx.stroke();
                    
                    ctx.fillStyle = '#aaffff44';
                    ctx.fill();
                    
                    ctx.restore();
                }
                
                ctx.translate(this.x, this.y);
                
                // 🌈 Rainbow effect in fever mode
                if (this.feverMode > 0) {
                    this.color = `hsl(${this.rainbowHue}, 100%, 50%)`;
                    
                    // Extra rainbow aura
                    for (let i = 0; i < 3; i++) {
                        ctx.strokeStyle = `hsla(${(this.rainbowHue + i * 30) % 360}, 100%, 50%, ${0.3 - i * 0.1})`;
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 30;
                        ctx.shadowColor = ctx.strokeStyle;
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size + 10 + i * 5, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                } else if (this.omegaMode > 0) {
                    // Omega mode red glow
                    this.color = '#ff0000';
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 4;
                    ctx.shadowBlur = 40;
                    ctx.shadowColor = '#ff0000';
                } else if (this.ghostMode > 0) {
                    // Ghost mode transparency
                    ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.01) * 0.3;
                    this.color = '#aaaaff';
                } else {
                    this.color = config.colors.player;
                }
                
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.shadowBlur = 30;
                ctx.shadowColor = this.color;
                ctx.globalAlpha = Math.min(ctx.globalAlpha, 0.9);
                
                ctx.beginPath();
                ctx.moveTo(0, -20);
                ctx.lineTo(-15, 20);
                ctx.lineTo(0, 10);
                ctx.lineTo(15, 20);
                ctx.closePath();
                ctx.stroke();
                
                ctx.fillStyle = this.color + '44';
                ctx.fill();
                
                ctx.globalAlpha = 1;
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.stroke();
                
                // Draw vortex effect
                if (this.vortexActive > 0) {
                    ctx.save();
                    const vortexRadius = 80 + Math.sin(Date.now() * 0.01) * 20;
                    ctx.strokeStyle = '#80ff80';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.6;
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = '#80ff80';
                    ctx.beginPath();
                    ctx.arc(0, 0, vortexRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Swirling lines
                    for (let i = 0; i < 8; i++) {
                        const angle = (Date.now() * 0.005) + (i * Math.PI / 4);
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(angle) * 40, Math.sin(angle) * 40);
                        ctx.lineTo(Math.cos(angle) * vortexRadius, Math.sin(angle) * vortexRadius);
                        ctx.stroke();
                    }
                    ctx.restore();
                }
                
                // 🔥 Afterburner effect when moving
                const moving = Math.abs(this.x - this.lastX) > 1 || Math.abs(this.y - this.lastY) > 1;
                if (moving) {
                    ctx.save();
                    const flameLength = 10 + Math.random() * 15;
                    const gradient = ctx.createLinearGradient(0, 15, 0, 15 + flameLength);
                    
                    if (this.feverMode > 0) {
                        gradient.addColorStop(0, `hsla(${this.rainbowHue}, 100%, 70%, 0.8)`);
                        gradient.addColorStop(0.5, `hsla(${(this.rainbowHue + 60) % 360}, 100%, 50%, 0.5)`);
                        gradient.addColorStop(1, 'transparent');
                    } else {
                        gradient.addColorStop(0, 'rgba(255, 255, 100, 0.8)');
                        gradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.5)');
                        gradient.addColorStop(1, 'transparent');
                    }
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.moveTo(-5, 15);
                    ctx.lineTo(-8, 15 + flameLength);
                    ctx.lineTo(0, 15 + flameLength * 0.7);
                    ctx.lineTo(8, 15 + flameLength);
                    ctx.lineTo(5, 15);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }
                
                if (this.weaponLevel > 1) {
                    ctx.fillStyle = '#ffff00';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffff00';
                    for (let i = 0; i < this.weaponLevel - 1; i++) {
                        ctx.beginPath();
                        ctx.arc(-10 + i * 10, -25, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                if (this.shieldActive && this.shield > 0) {
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#00ffff';
                    ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.01) * 0.3;
                    ctx.beginPath();
                    ctx.arc(0, 0, 35, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                if (this.autoFire) {
                    ctx.fillStyle = '#00ff00';
                    ctx.font = 'bold 10px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText('AUTO', 0, -35);
                }
                
                ctx.restore();
            }
        }

        /*
         * Player damage and respawn handling
         *
         * The original code relied on external functions for dealing with
         * player death and invulnerability windows. In some prior patches
         * these methods were removed, which resulted in the player never
         * losing lives and lasers passing through without effect. To restore
         * proper collision handling, we define takeDamage() and respawn()
         * on Player.prototype. These functions manage shield depletion,
         * invulnerability timers, explosion effects, life deduction and
         * respawning.
         */
        // Inserted after the Player class definition
        Player.prototype.takeDamage = function() {
            // Ignore damage if already invulnerable or in special modes
            if (this.invulnerable || this.ghostMode > 0 || this.godMode > 0 || this.infinityMode > 0 || this.infinitePower) {
                return false;
            }
            // Shield absorbs a hit without consuming a life
            if (this.shieldActive && this.shield > 0) {
                this.shield--;
                if (this.shield <= 0) {
                    this.shieldActive = false;
                }
                // Play shield hit sound if available
                try {
                    if (soundSystem && soundSystem.playShieldHit) {
                        soundSystem.playShieldHit();
                    }
                } catch (e) {
                    /* ignore sound errors */
                }
                return false;
            }
            // If already dead, ignore further damage
            if (!this.isAlive) {
                return false;
            }
            // Trigger death: set flags and timers
            this.isAlive = false;
            this.respawnTimer = this.respawnDelay;
            this.invulnerable = true;
            this.invulnerableTimer = 120;
            // Explosion and sound effects on death
            try {
                if (typeof particleSystem !== 'undefined' && particleSystem && typeof particleSystem.addExplosion === 'function') {
                    particleSystem.addExplosion(this.x, this.y, '#ff6666', 25);
                }
                if (typeof soundSystem !== 'undefined' && soundSystem) {
                    if (soundSystem.playExplosion) soundSystem.playExplosion();
                    if (soundSystem.playVoiceSample) soundSystem.playVoiceSample('OOPS');
                }
            } catch (e) {
                /* ignore particle/sound errors */
            }
            return true;
        };
        
        Player.prototype.respawn = function() {
            // Reset position to bottom centre and clear motion
            this.x = config.width / 2;
            this.y = config.height - 80;
            this.fireTimer = 0;
            this.isAlive = true;
            // Brief invulnerability after respawn
            this.invulnerable = true;
            this.invulnerableTimer = 120;
            // Remove any remaining shield
            this.shieldActive = false;
            this.shield = 0;
        };

        // Enhanced Enemy Class with Advanced AI and Roles
        class Enemy {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.active = true;
                this.rotation = 0;
                this.moveTimer = 0;
                this.fireTimer = 0;
                this.glowPulse = 0;
                this.smokeTrail = [];
                this.lastPlayerX = 0;
                this.lastPlayerY = 0;
                this.alertLevel = 0;
                this.formationRole = 'none';
                this.communicationTimer = 0;
                
                const currentWave = (gameState && gameState.wave) ? gameState.wave : 1;
                
                // Base stats influenced by wave
                const waveMultiplier = Math.min(1 + (currentWave * 0.1), 3.0);
                const intelligenceLevel = Math.min(Math.floor(currentWave / 3), 5);
                
                switch(type) {
                    case 'triangle':
                        this.setupTriangleScout(currentWave, intelligenceLevel);
                        break;
                    case 'square':
                        this.setupSquareHeavy(currentWave, intelligenceLevel);
                        break;
                    case 'pentagon':
                        this.setupPentagonSniper(currentWave, intelligenceLevel);
                        break;
                    case 'divebomber':
                        this.setupDiveBomber(currentWave, intelligenceLevel);
                        break;
                    case 'sinewave':
                        this.setupSineWaveElite(currentWave, intelligenceLevel);
                        break;
                }
                
                // Store original values for fever mode
                this.originalBehavior = this.behavior;
                this.originalColor = this.color;
                this.originalSpeed = this.speed;
                this.intelligence = intelligenceLevel;
                this.reactionTime = Math.max(10, 60 - (intelligenceLevel * 10));
            }
            
            setupTriangleScout(wave, intelligence) {
                this.sides = 3;
                this.size = 15;
                this.hp = 1;
                this.speed = Math.max(1.8, 2.2 + (wave * 0.18));
                this.points = 100;
                // Increase firing frequency: lower base and reduce wave scaling
                this.fireRate = Math.max(35, 85 - (wave * 5));
                this.bulletSpeed = Math.max(3.5, 4.5 + (wave * 0.12));
                this.color = '#ff0066';
                this.behavior = intelligence >= 2 ? 'scout_aggressive' : 'aggressive';
                this.role = 'scout';
                this.detectionRange = 150 + (intelligence * 20);
                this.canCallReinforcements = intelligence >= 3;
            }
            
            setupSquareHeavy(wave, intelligence) {
                this.sides = 4;
                this.size = 22;
                this.hp = 2 + Math.floor(wave / 4);
                this.speed = Math.max(0.8, 1.2 + (wave * 0.08));
                this.points = 200;
                // Increase firing frequency for heavies
                this.fireRate = Math.max(30, 70 - (wave * 4));
                this.bulletSpeed = Math.max(4, 5.5 + (wave * 0.1));
                this.color = '#0099ff';
                this.behavior = intelligence >= 3 ? 'heavy_tactical' : 'zigzag';
                this.role = 'heavy';
                this.canBlock = intelligence >= 2;
                this.shieldTimer = 0;
                this.zigzagTimer = 0;
            }
            
            setupPentagonSniper(wave, intelligence) {
                this.sides = 5;
                this.size = 25;
                this.hp = 3 + Math.floor(wave / 3);
                this.speed = Math.max(0.6, 1.0 + (wave * 0.06));
                this.points = 300;
                // Increase firing frequency for snipers
                this.fireRate = Math.max(80, 130 - (wave * 6));
                this.bulletSpeed = Math.max(6, 8 + (wave * 0.15));
                this.color = '#00ff66';
                this.behavior = intelligence >= 4 ? 'sniper_elite' : 'chaser';
                this.role = 'sniper';
                this.aimPrediction = intelligence >= 3;
                this.chargeTime = 0;
                this.isCharging = false;
            }
            
            setupDiveBomber(wave, intelligence) {
                this.sides = 3;
                this.size = 18;
                this.hp = 1;
                this.speed = Math.max(2.8, 3.2 + (wave * 0.25));
                this.points = 150;
                this.fireRate = 999;
                this.bulletSpeed = 0;
                this.color = '#ff3300';
                this.behavior = intelligence >= 2 ? 'kamikaze_smart' : 'kamikaze';
                this.role = 'kamikaze';
                this.isDiveBomber = true;
                this.explosionRadius = 60 + (intelligence * 15);
                this.updateTargetTimer = 0;
                
                if (gameState && gameState.player) {
                    this.targetX = gameState.player.x;
                    this.targetY = gameState.player.y;
                }
            }
            
            setupSineWaveElite(wave, intelligence) {
                this.sides = 4;
                this.size = 24;
                this.hp = 2 + Math.floor(wave / 3);
                this.speed = Math.max(1.4, 2.0 + (wave * 0.12));
                this.points = 250;
                this.fireRate = Math.max(35, 70 - (wave * 4));
                this.bulletSpeed = Math.max(4.5, 6 + (wave * 0.12));
                this.color = '#9900ff';
                this.behavior = intelligence >= 3 ? 'sine_tactical' : 'sine_wave';
                this.role = 'elite';
                this.sineTimer = Math.random() * Math.PI * 2;
                this.amplitude = 60 + Math.random() * 40;
                this.centerX = x;
                this.canTeleport = intelligence >= 4;
                this.teleportCooldown = 0;
            }
            
            update() {
                if (!this.active) return;
                
                this.moveTimer++;
                this.fireTimer++;
                this.rotation += 0.02;
                this.glowPulse += 0.05;
                this.communicationTimer++;
                
                // Update player tracking for intelligent enemies
                if (gameState && gameState.player && this.intelligence >= 1) {
                    this.lastPlayerX = gameState.player.x;
                    this.lastPlayerY = gameState.player.y;
                    
                    const distToPlayer = Math.hypot(this.x - gameState.player.x, this.y - gameState.player.y);
                    if (distToPlayer < this.detectionRange) {
                        this.alertLevel = Math.min(this.alertLevel + 1, 100);
                        
                        // Smart enemies communicate threats to nearby allies
                        if (this.canCallReinforcements && this.communicationTimer > 120 && Math.random() < 0.1) {
                            this.alertNearbyEnemies();
                            this.communicationTimer = 0;
                        }
                    } else {
                        this.alertLevel = Math.max(this.alertLevel - 0.5, 0);
                    }
                }
                
                // Generate smoke trail for dive bombers
                if (this.isDiveBomber && Math.random() < 0.7) {
                    this.smokeTrail.push({
                        x: this.x + (Math.random() - 0.5) * 10,
                        y: this.y + (Math.random() - 0.5) * 10,
                        life: 60,
                        size: Math.random() * 4 + 2,
                        vx: (Math.random() - 0.5) * 2,
                        vy: Math.random() * 3 + 1
                    });
                }
                
                // Update smoke trail
                this.smokeTrail = this.smokeTrail.filter(smoke => {
                    smoke.x += smoke.vx;
                    smoke.y += smoke.vy;
                    smoke.life--;
                    smoke.vy += 0.1; // Gravity
                    return smoke.life > 0;
                });
                
                // 🌈 FEVER MODE - enemies flee!
                if (this.behavior === 'flee' && gameState && gameState.player) {
                    const dx = this.x - gameState.player.x;
                    const dy = this.y - gameState.player.y;
                    const dist = Math.hypot(dx, dy);
                    
                    if (dist < 200) {
                        const angle = Math.atan2(dy, dx);
                        this.x += Math.cos(angle) * this.speed * 1.5;
                        this.y += Math.sin(angle) * this.speed * 1.5;
                    } else {
                        this.y += this.speed;
                    }
                    return;
                }
                
                // Advanced AI behaviors based on role and intelligence
                switch(this.behavior) {
                    case 'scout_aggressive':
                        this.updateScoutBehavior();
                        break;
                    case 'heavy_tactical':
                        this.updateHeavyBehavior();
                        break;
                    case 'sniper_elite':
                        this.updateSniperBehavior();
                        break;
                    case 'kamikaze_smart':
                        this.updateSmartKamikazeBehavior();
                        break;
                    case 'sine_tactical':
                        this.updateTacticalSineBehavior();
                        break;
                    default:
                        this.updateBasicBehavior();
                        break;
                }
                
                // Shooting logic (except for kamikaze)
                if (!this.isDiveBomber && this.fireTimer > this.fireRate) {
                    this.attemptFire();
                    this.fireTimer = 0;
                }

                // Additional random shots based on intelligence
                // To make enemies more aggressive, allow a small random chance to fire on any frame.
                // Higher intelligence enemies get a higher chance to shoot back.
                if (!this.isDiveBomber && Math.random() < 0.002 * (this.intelligence + 1)) {
                    this.attemptFire();
                }
                
                // Cleanup when off-screen
                if (this.y > config.height + 50 || this.x < -50 || this.x > config.width + 50) {
                    this.active = false;
                }
            }
            
            // Advanced AI Behavior Methods
            updateScoutBehavior() {
                // Scouts move fast and try to flank the player
                this.y += this.speed;
                
                if (gameState && gameState.player && this.alertLevel > 20) {
                    const dx = gameState.player.x - this.x;
                    const dy = gameState.player.y - this.y;
                    
                    // Try to position for flanking
                    if (Math.abs(dx) > 100) {
                        this.x += Math.sign(dx) * Math.min(3, Math.abs(dx * 0.03));
                    } else {
                        // Strafe to avoid being directly in front
                        this.x += Math.sin(this.moveTimer * 0.1) * 2;
                    }
                }
            }
            
            updateHeavyBehavior() {
                // Heavy units move slower but more strategically
                this.y += this.speed * 0.8;
                this.zigzagTimer += 0.05;
                
                // Defensive positioning
                if (gameState && gameState.player) {
                    const dx = gameState.player.x - this.x;
                    
                    // Try to stay in firing lanes
                    if (Math.abs(dx) < 50) {
                        this.x += Math.sin(this.zigzagTimer) * 1.5;
                    } else {
                        this.x += Math.sign(dx) * Math.min(1.5, Math.abs(dx * 0.015));
                    }
                    
                    // Shield behavior for advanced heavies
                    if (this.canBlock && this.intelligence >= 3) {
                        this.shieldTimer++;
                        if (this.shieldTimer > 180) {
                            this.temporaryShield = 60;
                            this.shieldTimer = 0;
                        }
                    }
                }
            }
            
            updateSniperBehavior() {
                // Snipers try to maintain optimal range
                this.y += this.speed * 0.6;
                
                if (gameState && gameState.player) {
                    const distToPlayer = Math.hypot(this.x - gameState.player.x, this.y - gameState.player.y);
                    const optimalRange = 200;
                    
                    if (distToPlayer < optimalRange * 0.7) {
                        // Too close, back away
                        const dx = this.x - gameState.player.x;
                        const dy = this.y - gameState.player.y;
                        const angle = Math.atan2(dy, dx);
                        this.x += Math.cos(angle) * this.speed * 0.5;
                        this.y += Math.sin(angle) * this.speed * 0.3;
                    } else if (distToPlayer > optimalRange) {
                        // Too far, close in slowly
                        const dx = gameState.player.x - this.x;
                        this.x += Math.sign(dx) * Math.min(1, Math.abs(dx * 0.01));
                    }
                    
                    // Charge powerful shots
                    if (this.fireTimer > this.fireRate * 0.7 && !this.isCharging) {
                        this.isCharging = true;
                        this.chargeTime = 0;
                    }
                    
                    if (this.isCharging) {
                        this.chargeTime++;
                    }
                }
            }
            
            updateSmartKamikazeBehavior() {
                // Smart kamikaze predicts player movement
                if (gameState && gameState.player) {
                    this.updateTargetTimer++;
                    
                    // Update target prediction more frequently
                    if (this.updateTargetTimer > this.reactionTime) {
                        const playerVx = gameState.player.x - this.lastPlayerX;
                        const playerVy = gameState.player.y - this.lastPlayerY;
                        
                        // Predict where player will be
                        const predictionTime = 30;
                        this.targetX = gameState.player.x + playerVx * predictionTime;
                        this.targetY = gameState.player.y + playerVy * predictionTime;
                        
                        this.updateTargetTimer = 0;
                    }
                    
                    const dx = this.targetX - this.x;
                    const dy = this.targetY - this.y;
                    const angle = Math.atan2(dy, dx);
                    
                    // Accelerate as we get closer
                    const distToTarget = Math.hypot(dx, dy);
                    const speedMultiplier = Math.min(2.5, 1 + (200 - distToTarget) / 100);
                    
                    this.x += Math.cos(angle) * this.speed * speedMultiplier;
                    this.y += Math.sin(angle) * this.speed * speedMultiplier;
                    this.rotation += 0.15;
                }
            }
            
            updateTacticalSineBehavior() {
                // Tactical sine wave with teleportation and unpredictable patterns
                this.y += this.speed;
                this.sineTimer += 0.08 + (this.alertLevel * 0.001);
                
                // Dynamic amplitude based on threat level
                const dynamicAmplitude = this.amplitude + (this.alertLevel * 0.5);
                this.x = this.centerX + Math.sin(this.sineTimer) * dynamicAmplitude;
                
                // Advanced sine users can teleport
                if (this.canTeleport) {
                    this.teleportCooldown--;
                    if (this.teleportCooldown <= 0 && this.alertLevel > 50 && Math.random() < 0.02) {
                        this.performTeleport();
                        this.teleportCooldown = 300;
                    }
                }
                
                // Change sine pattern occasionally
                if (Math.random() < 0.005) {
                    this.amplitude = 40 + Math.random() * 80;
                    this.centerX = Math.max(50, Math.min(config.width - 50, this.x));
                }
            }
            
            updateBasicBehavior() {
                // Fallback to original behaviors
                switch(this.originalBehavior) {
                    case 'aggressive':
                        this.y += this.speed;
                        if (gameState && gameState.player) {
                            const dx = gameState.player.x - this.x;
                            this.x += Math.sign(dx) * Math.min(2, Math.abs(dx * 0.02));
                        }
                        break;
                        
                    case 'zigzag':
                        this.y += this.speed;
                        this.zigzagTimer += 0.1;
                        this.x += Math.sin(this.zigzagTimer) * 4;
                        break;
                        
                    case 'chaser':
                        if (gameState && gameState.player) {
                            const dx = gameState.player.x - this.x;
                            const dy = gameState.player.y - this.y;
                            const angle = Math.atan2(dy, dx);
                            this.x += Math.cos(angle) * this.speed;
                            this.y += Math.sin(angle) * this.speed * 0.7;
                        } else {
                            this.y += this.speed;
                        }
                        break;
                        
                    case 'sine_wave':
                        this.y += this.speed;
                        this.sineTimer += 0.08;
                        this.x = this.centerX + Math.sin(this.sineTimer) * this.amplitude;
                        break;
                        
                    case 'kamikaze':
                        if (this.targetX !== undefined && this.targetY !== undefined) {
                            const dx = this.targetX - this.x;
                            const dy = this.targetY - this.y;
                            const angle = Math.atan2(dy, dx);
                            this.x += Math.cos(angle) * this.speed;
                            this.y += Math.sin(angle) * this.speed;
                            this.rotation += 0.1;
                        } else {
                            this.y += this.speed * 1.5;
                        }
                        break;
                        
                    default:
                        this.y += this.speed;
                }
            }
            
            // Support Methods
            alertNearbyEnemies() {
                if (!gameState || !gameState.enemies) return;
                
                const alertRadius = 120;
                gameState.enemies.forEach(enemy => {
                    if (enemy !== this && enemy.active) {
                        const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                        if (dist < alertRadius) {
                            enemy.alertLevel = Math.min(enemy.alertLevel + 30, 100);
                            enemy.speed *= 1.1; // Slight speed boost when alerted
                        }
                    }
                });
            }
            
            performTeleport() {
                // Teleport to a strategic position
                if (particleSystem) {
                    // Teleport out effect
                    for (let i = 0; i < 15; i++) {
                        const angle = (Math.PI * 2 * i) / 15;
                        particleSystem.particles.push({
                            x: this.x,
                            y: this.y,
                            vx: Math.cos(angle) * 6,
                            vy: Math.sin(angle) * 6,
                            color: this.color,
                            life: 20,
                            maxLife: 20,
                            size: 3,
                            active: true,
                            update() {
                                this.x += this.vx;
                                this.y += this.vy;
                                this.vx *= 0.9;
                                this.vy *= 0.9;
                                this.life--;
                                if (this.life <= 0) this.active = false;
                            },
                            draw(ctx) {
                                const alpha = this.life / this.maxLife;
                                ctx.save();
                                ctx.globalAlpha = alpha;
                                ctx.fillStyle = this.color;
                                ctx.shadowBlur = 15;
                                ctx.shadowColor = this.color;
                                ctx.beginPath();
                                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.restore();
                            }
                        });
                    }
                }
                
                // Choose new position strategically
                const newX = Math.max(50, Math.min(config.width - 50, 
                    this.lastPlayerX + (Math.random() - 0.5) * 200));
                const newY = Math.max(50, Math.min(this.y + 100, 
                    this.y + (Math.random() - 0.5) * 100));
                
                this.x = newX;
                this.y = newY;
                this.centerX = newX;
                
                // Teleport in effect
                if (particleSystem) {
                    setTimeout(() => {
                        for (let i = 0; i < 15; i++) {
                            const angle = (Math.PI * 2 * i) / 15;
                            particleSystem.particles.push({
                                x: this.x + Math.cos(angle) * 20,
                                y: this.y + Math.sin(angle) * 20,
                                vx: -Math.cos(angle) * 6,
                                vy: -Math.sin(angle) * 6,
                                color: this.color,
                                life: 20,
                                maxLife: 20,
                                size: 3,
                                active: true,
                                update() {
                                    this.x += this.vx;
                                    this.y += this.vy;
                                    this.vx *= 0.9;
                                    this.vy *= 0.9;
                                    this.life--;
                                    if (this.life <= 0) this.active = false;
                                },
                                draw(ctx) {
                                    const alpha = this.life / this.maxLife;
                                    ctx.save();
                                    ctx.globalAlpha = alpha;
                                    ctx.fillStyle = this.color;
                                    ctx.shadowBlur = 15;
                                    ctx.shadowColor = this.color;
                                    ctx.beginPath();
                                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                    ctx.fill();
                                    ctx.restore();
                                }
                            });
                        }
                    }, 100);
                }
            }
            
            attemptFire() {
                if (!gameState || !gameState.player || this.behavior === 'flee') return;

                // Mini‑bosses use a special firing pattern: they shoot bullets in a
                // radial spread rather than a single aimed shot. This makes
                // them much more threatening and forces the player to weave
                // through projectiles. The number of bullets increases with
                // intelligence/wave difficulty. We handle this early and
                // bypass the rest of the firing logic.
                if (this.isMiniBoss && enemyBulletPool) {
                    const bullets = 8 + Math.min(this.intelligence * 2, 8); // 8 to 16 bullets
                    for (let i = 0; i < bullets; i++) {
                        const angle = (Math.PI * 2 * i) / bullets;
                        const vx = Math.cos(angle) * this.bulletSpeed;
                        const vy = Math.sin(angle) * this.bulletSpeed;
                        enemyBulletPool.get(this.x, this.y, vx, vy, false);
                    }
                    return;
                }
                
                let shouldFire = false;
                let fireAngle = 0;
                let bulletSpeed = this.bulletSpeed;
                
                switch(this.role) {
                    case 'scout':
                        // Scouts fire quick bursts
                        shouldFire = this.alertLevel > 10;
                        fireAngle = this.calculateAimAngle(false);
                        break;
                        
                    case 'heavy':
                        // Heavies fire powerful shots
                        shouldFire = this.alertLevel > 30;
                        fireAngle = this.calculateAimAngle(false);
                        bulletSpeed *= 1.2;
                        break;
                        
                    case 'sniper':
                        // Snipers fire precise, charged shots
                        shouldFire = this.isCharging && this.chargeTime > 30;
                        fireAngle = this.calculateAimAngle(this.aimPrediction);
                        bulletSpeed *= (1.5 + this.chargeTime / 20);
                        if (shouldFire) {
                            this.isCharging = false;
                            this.chargeTime = 0;
                        }
                        break;
                        
                    case 'elite':
                        // Elites use advanced firing patterns
                        shouldFire = this.alertLevel > 20;
                        if (shouldFire && this.intelligence >= 3) {
                            this.fireSpreadPattern();
                            return;
                        }
                        fireAngle = this.calculateAimAngle(true);
                        break;
                        
                    default:
                        // Basic firing
                        shouldFire = true;
                        fireAngle = this.calculateAimAngle(false);
                        break;
                }
                
                if (shouldFire) {
                    const vx = Math.cos(fireAngle) * bulletSpeed;
                    const vy = Math.sin(fireAngle) * bulletSpeed;
                    
                    if (enemyBulletPool) {
                        enemyBulletPool.get(this.x, this.y, vx, vy, false);
                        
                        // Advanced enemies fire bursts
                        if (this.intelligence >= 3 && Math.random() < 0.4) {
                            setTimeout(() => {
                                if (this.active && enemyBulletPool) {
                                    enemyBulletPool.get(this.x, this.y, vx, vy, false);
                                }
                            }, 150);
                        }
                    }
                }
            }
            
            calculateAimAngle(usePrediction) {
                if (!gameState || !gameState.player) return 0;
                
                let targetX = gameState.player.x;
                let targetY = gameState.player.y;
                
                if (usePrediction && this.intelligence >= 2) {
                    // Predict player movement
                    const playerVx = gameState.player.x - this.lastPlayerX;
                    const playerVy = gameState.player.y - this.lastPlayerY;
                    const predictionFrames = 20 + (this.intelligence * 5);
                    
                    targetX += playerVx * predictionFrames;
                    targetY += playerVy * predictionFrames;
                }
                
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                return Math.atan2(dy, dx);
            }
            
            fireSpreadPattern() {
                // Elite enemies fire spread shots
                const baseAngle = this.calculateAimAngle(true);
                const spreadAngles = [-0.3, -0.15, 0, 0.15, 0.3];
                
                spreadAngles.forEach((spread, index) => {
                    setTimeout(() => {
                        if (this.active && enemyBulletPool) {
                            const angle = baseAngle + spread;
                            const vx = Math.cos(angle) * this.bulletSpeed;
                            const vy = Math.sin(angle) * this.bulletSpeed;
                            enemyBulletPool.get(this.x, this.y, vx, vy, false);
                        }
                    }, index * 50);
                });
            }
            
            shoot() {
                if (!gameState || !gameState.player || this.behavior === 'flee') return;
                
                const dx = gameState.player.x - this.x;
                const dy = gameState.player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    const vx = (dx / dist) * this.bulletSpeed;
                    const vy = (dy / dist) * this.bulletSpeed;
                    if (enemyBulletPool) {
                        enemyBulletPool.get(this.x, this.y, vx, vy, false);
                    }
                }
            }
            
            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) {
                    this.active = false;
                }
            }
            
            draw(ctx) {
                if (!this.active) return;
                
                ctx.save();
                
                // Draw smoke trail for dive bombers
                if (this.isDiveBomber && this.smokeTrail.length > 0) {
                    this.smokeTrail.forEach(smoke => {
                        const alpha = smoke.life / 60;
                        ctx.save();
                        ctx.globalAlpha = alpha * 0.6;
                        
                        const gradient = ctx.createRadialGradient(smoke.x, smoke.y, 0, smoke.x, smoke.y, smoke.size);
                        gradient.addColorStop(0, '#ff4400');
                        gradient.addColorStop(0.5, '#ff6600');
                        gradient.addColorStop(1, 'transparent');
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(smoke.x, smoke.y, smoke.size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    });
                }
                
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                const pulseIntensity = Math.sin(this.glowPulse) * 0.3 + 0.7;
                
                // Special visual indicators for different roles
                if (this.role === 'scout' && this.alertLevel > 30) {
                    // Scout radar pulse
                    ctx.save();
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.4 + Math.sin(this.moveTimer * 0.2) * 0.3;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size + 15, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                } else if (this.role === 'heavy' && this.temporaryShield > 0) {
                    // Heavy shield indicator
                    this.temporaryShield--;
                    ctx.save();
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = 0.6 + Math.sin(this.moveTimer * 0.3) * 0.4;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#00ffff';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size + 12, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                } else if (this.role === 'sniper' && this.isCharging) {
                    // Sniper charging indicator
                    const chargePercent = Math.min(this.chargeTime / 30, 1);
                    ctx.save();
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 4;
                    ctx.globalAlpha = 0.5 + chargePercent * 0.5;
                    ctx.shadowBlur = 25 + (chargePercent * 15);
                    ctx.shadowColor = '#ff00ff';
                    
                    // Charging ring
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size + 8, 0, Math.PI * 2 * chargePercent);
                    ctx.stroke();
                    
                    // Targeting laser
                    if (chargePercent > 0.7 && gameState && gameState.player) {
                        const dx = gameState.player.x - this.x;
                        const dy = gameState.player.y - this.y;
                        const dist = Math.hypot(dx, dy);
                        const angle = Math.atan2(dy, dx);
                        
                        ctx.strokeStyle = '#ff00ff';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.8;
                        ctx.shadowBlur = 30;
                        ctx.shadowColor = '#ff00ff';
                        ctx.beginPath();
                        ctx.moveTo(this.size, 0);
                        ctx.lineTo(dist - this.size, 0);
                        ctx.rotate(angle);
                        ctx.stroke();
                    }
                    ctx.restore();
                } else if (this.role === 'elite' && this.teleportCooldown <= 60 && this.canTeleport) {
                    // Elite ready to teleport
                    ctx.save();
                    ctx.strokeStyle = '#9900ff';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.4 + Math.sin(this.moveTimer * 0.4) * 0.4;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#9900ff';
                    
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI * 2 * i) / 6 + this.moveTimer * 0.1;
                        const radius = this.size + 10 + Math.sin(this.moveTimer * 0.2 + i) * 5;
                        ctx.beginPath();
                        ctx.arc(Math.cos(angle) * radius, Math.sin(angle) * radius, 3, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.restore();
                }
                
                // Formation and group indicators
                if (this.isFormationLeader) {
                    ctx.shadowBlur = 40 + (pulseIntensity * 30);
                    ctx.shadowColor = this.color;
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 4;
                    
                    ctx.save();
                    ctx.rotate(this.glowPulse * 0.5);
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 * i) / 8;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(angle) * (this.size + 15), Math.sin(angle) * (this.size + 15));
                        ctx.stroke();
                    }
                    ctx.restore();
                } else if (this.isGroupLeader) {
                    // Group leader crown
                    ctx.save();
                    ctx.strokeStyle = '#ffaa00';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ffaa00';
                    ctx.globalAlpha = 0.8;
                    
                    // Crown points
                    for (let i = 0; i < 5; i++) {
                        const angle = (Math.PI * 2 * i) / 5 - Math.PI/2;
                        const radius = this.size + 8 + (i % 2 === 0 ? 5 : 0);
                        ctx.beginPath();
                        ctx.moveTo(0, -this.size - 3);
                        ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
                        ctx.stroke();
                    }
                    ctx.restore();
                } else if (this.isDiveBomber && this.behavior === 'kamikaze_smart') {
                    // Smart kamikaze warning indicator
                    ctx.save();
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.6 + Math.sin(this.moveTimer * 0.5) * 0.4;
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = '#ff0000';
                    
                    // Warning triangles
                    for (let i = 0; i < 3; i++) {
                        const angle = (Math.PI * 2 * i) / 3 + this.moveTimer * 0.1;
                        const radius = this.size + 12;
                        const triangleSize = 6;
                        
                        ctx.save();
                        ctx.translate(Math.cos(angle) * radius, Math.sin(angle) * radius);
                        ctx.rotate(angle);
                        ctx.beginPath();
                        ctx.moveTo(-triangleSize, triangleSize);
                        ctx.lineTo(triangleSize, triangleSize);
                        ctx.lineTo(0, -triangleSize);
                        ctx.closePath();
                        ctx.stroke();
                        ctx.restore();
                    }
                    ctx.restore();
                } else if (this.isElite) {
                    // Elite enemy special aura
                    ctx.save();
                    for (let i = 0; i < 3; i++) {
                        ctx.strokeStyle = `hsla(280, 100%, 50%, ${0.3 - i * 0.1})`;
                        ctx.lineWidth = 2 + i;
                        ctx.shadowBlur = 20 + (i * 10);
                        ctx.shadowColor = this.color;
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size + (i * 8), 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.restore();
                } else if (this.isMiniBoss) {
                    // Mini-boss special effects
                    ctx.save();
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#ff00ff';
                    ctx.globalAlpha = 0.7 + Math.sin(this.glowPulse * 2) * 0.3;
                    
                    // Rotating aura
                    ctx.rotate(this.moveTimer * 0.05);
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI * 2 * i) / 6;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(angle) * (this.size + 20), Math.sin(angle) * (this.size + 20));
                        ctx.stroke();
                    }
                    ctx.restore();
                } else if (this.type === 'sinewave') {
                    // Special sine wave glow effect
                    ctx.save();
                    for (let i = 0; i < 3; i++) {
                        ctx.strokeStyle = `hsla(280, 100%, 50%, ${0.3 - i * 0.1})`;
                        ctx.lineWidth = 2 + i;
                        ctx.shadowBlur = 20 + (i * 10);
                        ctx.shadowColor = this.color;
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size + (i * 8), 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.restore();
                } else {
                    // Standard enemy appearance
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 30 + (pulseIntensity * 20);
                    ctx.shadowColor = this.color;
                }
                
                // Alert level visual feedback
                if (this.alertLevel > 50) {
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = '#ff0000';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size + 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                
                ctx.globalAlpha = 0.8;
                
                // Draw the main shape
                if (this.type === 'sinewave') {
                    // Special diamond shape for sine wave enemies
                    ctx.beginPath();
                    ctx.moveTo(0, -this.size);
                    ctx.lineTo(this.size, 0);
                    ctx.lineTo(0, this.size);
                    ctx.lineTo(-this.size, 0);
                    ctx.closePath();
                } else {
                    // Regular polygon
                    ctx.beginPath();
                    for (let i = 0; i < this.sides; i++) {
                        const angle = (Math.PI * 2 * i) / this.sides - Math.PI / 2;
                        const x = Math.cos(angle) * this.size;
                        const y = Math.sin(angle) * this.size;
                        
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                }
                
                ctx.stroke();
                
                ctx.fillStyle = this.color + '44';
                ctx.fill();
                
                // Role indicators inside shapes
                ctx.globalAlpha = pulseIntensity;
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.stroke();
                
                // Role symbols
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 12px Courier New';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.globalAlpha = 0.8;
                
                let roleSymbol = '';
                switch(this.role) {
                    case 'scout': roleSymbol = '⚡'; break;
                    case 'heavy': roleSymbol = '▣'; break;
                    case 'sniper': roleSymbol = '◎'; break;
                    case 'kamikaze': roleSymbol = '💀'; break;
                    case 'elite': roleSymbol = '★'; break;
                }
                
                if (roleSymbol && this.intelligence >= 2) {
                    ctx.fillText(roleSymbol, 0, 0);
                }
                
                if (this.isFormationFollower) {
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size + 8, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }

        // Boss Class with 5 Different Types in Sequence
        class Boss {
            constructor(wave) {
                this.wave = wave;
                this.x = config.width / 2;
                this.y = -100;
                this.targetY = 150;
                this.rotation = 0;
                this.active = true;
                this.phaseTimer = 0;
                this.attackTimer = 0;
                this.moveTimer = 0;
                this.glowPulse = 0;
                
                // Determine boss type in sequence (cycles through 1-5)
                const bossSequence = ((wave - 1) % 5) + 1;
                
                if (bossSequence === 1) {
                    this.type = 'spinner';
                    this.setupSpinner();
                } else if (bossSequence === 2) {
                    this.type = 'fortress';
                    this.setupFortress();
                } else if (bossSequence === 3) {
                    this.type = 'hydra';
                    this.setupHydra();
                } else if (bossSequence === 4) {
                    this.type = 'phoenix';
                    this.setupPhoenix();
                } else if (bossSequence === 5) {
                    this.type = 'motherbrain';
                    this.setupMotherbrain();
                }
                
                console.log(`🎯 Wave ${wave}: Spawning ${this.type.toUpperCase()} boss (sequence ${bossSequence})`);
            }
            
            setupSpinner() {
                const cycle = Math.floor((this.wave - 1) / 5);
                this.name = cycle > 0 ? `SPINNER MK-${cycle + 1}` : 'SPINNER';
                this.maxHp = 15 + this.wave * 3 + (cycle * 10);
                this.hp = this.maxHp;
                this.size = 50 + (cycle * 5);
                this.speed = 1.5 + (cycle * 0.3);
                this.color = '#ff00ff';
                this.spinSpeed = 0.05 + (cycle * 0.01);
                this.burstTimer = 0;
                this.berserkerMode = false;
            }
            
            setupFortress() {
                const cycle = Math.floor((this.wave - 1) / 5);
                this.name = cycle > 0 ? `FORTRESS MK-${cycle + 1}` : 'FORTRESS';
                this.maxHp = 30 + this.wave * 4 + (cycle * 15);
                this.hp = this.maxHp;
                this.size = 70 + (cycle * 8);
                this.speed = 0.8 + (cycle * 0.2);
                this.color = '#0066ff';
                this.shieldActive = true;
                this.shieldHp = 20 + (cycle * 8);
                this.maxShieldHp = 20 + (cycle * 8);
                this.wallCooldown = 0;
                this.walls = [];
                this.shieldRegenTimer = 0;
            }
            
            setupHydra() {
                const cycle = Math.floor((this.wave - 1) / 5);
                this.name = cycle > 0 ? `HYDRA MK-${cycle + 1}` : 'HYDRA';
                this.maxHp = 25 + this.wave * 3 + (cycle * 12);
                this.hp = this.maxHp;
                this.size = 60 + (cycle * 6);
                this.speed = 1.2 + (cycle * 0.25);
                this.color = '#00ff00';
                this.heads = 3 + cycle; // More heads in later cycles
                this.maxHeads = 3 + cycle;
                this.regenerationTimer = 0;
                this.headPositions = [];
                for (let i = 0; i < this.heads; i++) {
                    this.headPositions.push({
                        angle: (Math.PI * 2 * i) / this.heads,
                        radius: 40 + (cycle * 5),
                        health: 8 + (cycle * 3)
                    });
                }
            }
            
            setupPhoenix() {
                const cycle = Math.floor((this.wave - 1) / 5);
                this.name = cycle > 0 ? `PHOENIX MK-${cycle + 1}` : 'PHOENIX';
                this.maxHp = 35 + this.wave * 4 + (cycle * 18);
                this.hp = this.maxHp;
                this.size = 65 + (cycle * 7);
                this.speed = 2 + (cycle * 0.4);
                this.color = '#ff6600';
                this.hasRevived = false;
                this.flameTrail = [];
                this.diveAttackCooldown = 0;
                this.isDiving = false;
                this.diveTarget = { x: 0, y: 0 };
                // Can revive multiple times in later cycles
                this.maxRevives = cycle > 0 ? 1 + Math.floor(cycle / 2) : 1;
                this.currentRevives = 0;
            }
            
            setupMotherbrain() {
                const cycle = Math.floor((this.wave - 1) / 5);
                this.name = cycle > 0 ? `MOTHERBRAIN MK-${cycle + 1}` : 'MOTHERBRAIN';
                this.maxHp = 80 + this.wave * 6 + (cycle * 25);
                this.hp = this.maxHp;
                this.size = 100 + (cycle * 10);
                this.speed = 0.5 + (cycle * 0.15);
                this.color = '#8800ff';
                this.satellites = [];
                this.brainPulse = 0;
                this.tentacles = [];
                
                // 🚀 PERFORMANCE OPTIMIZED: Reduced satellites and tentacles
                const numSatellites = Math.min(2 + cycle, 4); // Further reduced from 3+cycle
                for (let i = 0; i < numSatellites; i++) {
                    this.satellites.push({
                        angle: (Math.PI * 2 * i) / numSatellites,
                        distance: 120 + (cycle * 15),
                        health: 15 + (cycle * 5),
                        active: true,
                        size: 25 + (cycle * 3),
                        attackTimer: Math.random() * 80 + 40, // Longer initial cooldown
                        attackCooldown: 120 // Add consistent cooldown
                    });
                }
                
                // 🚀 PERFORMANCE OPTIMIZED: Fewer tentacles, shorter segments
                const numTentacles = Math.min(3 + Math.floor(cycle * 0.5), 6); // Further reduced
                for (let i = 0; i < numTentacles; i++) {
                    this.tentacles.push({
                        angle: (Math.PI * 2 * i) / numTentacles,
                        length: 80 + (cycle * 10),
                        segments: Math.min(4 + Math.floor(cycle * 0.5), 6), // Fewer segments
                        health: 12 + (cycle * 4),
                        active: true,
                        lastAttackTime: 0,
                        attackCooldown: 180 // Longer cooldown between attacks
                    });
                }
            }
            
            update() {
                if (!this.active) return;
                
                this.phaseTimer++;
                this.rotation += 0.02;
                this.glowPulse += 0.08;
                
                // Boss entrance
                if (this.y < this.targetY) {
                    this.y += 2;
                    return;
                }
                
                switch(this.type) {
                    case 'spinner':
                        this.updateSpinner();
                        break;
                    case 'fortress':
                        this.updateFortress();
                        break;
                    case 'hydra':
                        this.updateHydra();
                        break;
                    case 'phoenix':
                        this.updatePhoenix();
                        break;
                    case 'motherbrain':
                        this.updateMotherbrain();
                        break;
                }
            }
            
            updateSpinner() {
                this.rotation += this.spinSpeed;
                if (this.berserkerMode) this.spinSpeed = 0.1;
                
                this.x += Math.sin(this.phaseTimer * 0.02) * this.speed * 2;
                
                this.burstTimer++;
                if (this.burstTimer > 60) {
                    this.fireBurstPattern();
                    this.burstTimer = 0;
                }
                
                if (this.hp <= this.maxHp * 0.3 && !this.berserkerMode) {
                    this.berserkerMode = true;
                    this.speed *= 1.5;
                }
            }
            
            updateFortress() {
                this.x += Math.sin(this.phaseTimer * 0.01) * this.speed;
                
                // Shield regeneration
                if (!this.shieldActive && this.shieldRegenTimer > 300) {
                    this.shieldActive = true;
                    this.shieldHp = this.maxShieldHp;
                    this.shieldRegenTimer = 0;
                }
                this.shieldRegenTimer++;
                
                // Wall attack
                this.wallCooldown--;
                if (this.wallCooldown <= 0 && Math.random() < 0.02) {
                    this.spawnWall();
                    this.wallCooldown = 180;
                }
                
                // Update walls
                this.walls = this.walls.filter(wall => {
                    wall.y += 3;
                    return wall.y < config.height + 50;
                });
                
                // Regular shooting
                if (this.phaseTimer % 45 === 0) {
                    this.fireSpread();
                }
            }
            
            updateHydra() {
                this.x += Math.sin(this.phaseTimer * 0.03) * this.speed;
                
                // Regenerate heads
                this.regenerationTimer++;
                if (this.regenerationTimer > 240 && this.heads < this.maxHeads) {
                    this.regenerateHead();
                    this.regenerationTimer = 0;
                }
                
                // Each head attacks independently
                this.headPositions.forEach((head, index) => {
                    if (head.health > 0) {
                        head.angle += 0.02 * (index % 2 === 0 ? 1 : -1);
                        
                        if (this.phaseTimer % (60 + index * 10) === 0) {
                            this.fireFromHead(index);
                        }
                    }
                });
            }
            
            updatePhoenix() {
                // Generate flame trail
                if (Math.random() < 0.8) {
                    this.flameTrail.push({
                        x: this.x + (Math.random() - 0.5) * this.size,
                        y: this.y + (Math.random() - 0.5) * this.size,
                        life: 40,
                        size: Math.random() * 8 + 4,
                        color: Math.random() > 0.5 ? '#ff6600' : '#ff3300'
                    });
                }
                
                // Update flame trail
                this.flameTrail = this.flameTrail.filter(flame => {
                    flame.life--;
                    flame.y += 2;
                    return flame.life > 0;
                });
                
                if (!this.isDiving) {
                    this.x += Math.sin(this.phaseTimer * 0.04) * this.speed * 2;
                    
                    // Dive attack
                    this.diveAttackCooldown--;
                    if (this.diveAttackCooldown <= 0 && gameState && gameState.player) {
                        this.isDiving = true;
                        this.diveTarget.x = gameState.player.x;
                        this.diveTarget.y = gameState.player.y;
                        this.diveAttackCooldown = 300;
                    }
                    
                    // Regular flame bursts
                    if (this.phaseTimer % 40 === 0) {
                        this.fireFlames();
                    }
                } else {
                    // Diving behavior
                    const dx = this.diveTarget.x - this.x;
                    const dy = this.diveTarget.y - this.y;
                    const dist = Math.hypot(dx, dy);
                    
                    if (dist > 50) {
                        const angle = Math.atan2(dy, dx);
                        this.x += Math.cos(angle) * this.speed * 3;
                        this.y += Math.sin(angle) * this.speed * 3;
                    } else {
                        this.isDiving = false;
                        this.y = this.targetY; // Return to position
                    }
                }
            }
            
            updateMotherbrain() {
                this.brainPulse += 0.1;
                this.x += Math.sin(this.phaseTimer * 0.008) * this.speed;
                
                // 🚀 PERFORMANCE OPTIMIZED: Update satellites with cooldowns
                this.satellites.forEach((satellite, index) => {
                    if (satellite.active) {
                        satellite.angle += 0.02; // Slower rotation
                        satellite.attackTimer--;
                        satellite.attackCooldown--;
                        
                        // Only attack if both timers allow it
                        if (satellite.attackTimer <= 0 && satellite.attackCooldown <= 0) {
                            this.fireFromSatellite(satellite, index);
                            satellite.attackTimer = 100 + Math.random() * 80; // Longer intervals
                            satellite.attackCooldown = 120; // Consistent cooldown
                        }
                    }
                });
                
                // 🚀 PERFORMANCE OPTIMIZED: Tentacle attacks with strict cooldowns
                this.tentacles.forEach((tentacle, index) => {
                    if (tentacle.active) {
                        tentacle.angle += Math.sin(this.phaseTimer * 0.01 + index) * 0.005; // Slower movement
                        
                        const currentTime = this.phaseTimer;
                        // Much longer cooldown between tentacle attacks
                        if (currentTime - tentacle.lastAttackTime > tentacle.attackCooldown) {
                            this.tentacleAttack(tentacle, index);
                            tentacle.lastAttackTime = currentTime;
                        }
                    }
                });
                
                // 🚀 PERFORMANCE OPTIMIZED: Less frequent main brain attacks
                if (this.phaseTimer % 120 === 0) { // Reduced from every 80 frames
                    this.brainBlast();
                }
            }
            
            // Attack Methods for Different Boss Types
            fireBurstPattern() {
                const numBullets = this.berserkerMode ? 16 : 12;
                for (let i = 0; i < numBullets; i++) {
                    const angle = (Math.PI * 2 * i) / numBullets + this.rotation;
                    const speed = 4;
                    enemyBulletPool.get(
                        this.x + Math.cos(angle) * 30,
                        this.y + Math.sin(angle) * 30,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        false
                    );
                }
                if (soundSystem) soundSystem.playExplosion();
            }
            
            spawnWall() {
                const wallWidth = 60;
                const wallHeight = 20;
                const startX = Math.random() * (config.width - wallWidth);
                
                this.walls.push({
                    x: startX,
                    y: this.y + this.size + 20,
                    width: wallWidth,
                    height: wallHeight,
                    hp: 5
                });
            }
            
            fireSpread() {
                const angles = [-0.5, -0.25, 0, 0.25, 0.5];
                angles.forEach(angle => {
                    enemyBulletPool.get(
                        this.x,
                        this.y + this.size / 2,
                        Math.sin(angle) * 4,
                        Math.cos(angle) * 6 + 2,
                        false
                    );
                });
            }
            
            regenerateHead() {
                for (let i = 0; i < this.headPositions.length; i++) {
                    if (this.headPositions[i].health <= 0) {
                        this.headPositions[i].health = 8;
                        this.heads++;
                        
                        // Regeneration effect
                        if (particleSystem) {
                            for (let j = 0; j < 20; j++) {
                                const angle = (Math.PI * 2 * j) / 20;
                                const headX = this.x + Math.cos(this.headPositions[i].angle) * this.headPositions[i].radius;
                                const headY = this.y + Math.sin(this.headPositions[i].angle) * this.headPositions[i].radius;
                                
                                particleSystem.particles.push({
                                    x: headX,
                                    y: headY,
                                    vx: Math.cos(angle) * 6,
                                    vy: Math.sin(angle) * 6,
                                    color: '#00ff00',
                                    life: 30,
                                    maxLife: 30,
                                    size: 3,
                                    active: true,
                                    update() {
                                        this.x += this.vx;
                                        this.y += this.vy;
                                        this.vx *= 0.95;
                                        this.vy *= 0.95;
                                        this.life--;
                                        if (this.life <= 0) this.active = false;
                                    },
                                    draw(ctx) {
                                        const alpha = this.life / this.maxLife;
                                        ctx.save();
                                        ctx.globalAlpha = alpha;
                                        ctx.fillStyle = this.color;
                                        ctx.shadowBlur = 15;
                                        ctx.shadowColor = this.color;
                                        ctx.beginPath();
                                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                        ctx.fill();
                                        ctx.restore();
                                    }
                                });
                            }
                        }
                        break;
                    }
                }
            }
            
            fireFromHead(headIndex) {
                const head = this.headPositions[headIndex];
                if (head.health <= 0) return;
                
                const headX = this.x + Math.cos(head.angle) * head.radius;
                const headY = this.y + Math.sin(head.angle) * head.radius;
                
                if (gameState && gameState.player) {
                    const dx = gameState.player.x - headX;
                    const dy = gameState.player.y - headY;
                    const angle = Math.atan2(dy, dx);
                    
                    enemyBulletPool.get(
                        headX,
                        headY,
                        Math.cos(angle) * 5,
                        Math.sin(angle) * 5,
                        false
                    );
                }
            }
            
            fireFlames() {
                const numFlames = 8;
                for (let i = 0; i < numFlames; i++) {
                    const angle = (Math.PI * 2 * i) / numFlames + Math.sin(this.phaseTimer * 0.1) * 0.5;
                    const speed = 3 + Math.random() * 2;
                    
                    enemyBulletPool.get(
                        this.x + Math.cos(angle) * this.size / 2,
                        this.y + Math.sin(angle) * this.size / 2,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        false
                    );
                }
            }
            
            fireFromSatellite(satellite, index) {
                const satX = this.x + Math.cos(satellite.angle) * satellite.distance;
                const satY = this.y + Math.sin(satellite.angle) * satellite.distance;
                
                if (gameState && gameState.player) {
                    const dx = gameState.player.x - satX;
                    const dy = gameState.player.y - satY;
                    const angle = Math.atan2(dy, dx);
                    
                    // Triple shot from satellite
                    for (let i = -1; i <= 1; i++) {
                        const spreadAngle = angle + i * 0.2;
                        enemyBulletPool.get(
                            satX,
                            satY,
                            Math.cos(spreadAngle) * 4,
                            Math.sin(spreadAngle) * 4,
                            false
                        );
                    }
                }
            }
            
            tentacleAttack(tentacle, index) {
                // 🚀 PERFORMANCE CRITICAL: Heavily reduced bullet spam
                if (!enemyBulletPool) return;
                
                // Only fire from every 3rd segment and reduce total bullets
                const segments = Math.min(tentacle.segments, 4); // Cap at 4 segments max
                const bulletsToFire = Math.min(2, Math.floor(segments / 2)); // Max 2 bullets per tentacle
                
                for (let i = 0; i < bulletsToFire; i++) {
                    const segmentIndex = i * 2; // Skip segments
                    const segmentAngle = tentacle.angle + (segmentIndex * 0.4);
                    const segmentRadius = (tentacle.length / segments) * (segmentIndex + 1);
                    const segmentX = this.x + Math.cos(segmentAngle) * segmentRadius;
                    const segmentY = this.y + Math.sin(segmentAngle) * segmentRadius;
                    
                    const fireAngle = segmentAngle + Math.PI / 2;
                    enemyBulletPool.get(
                        segmentX,
                        segmentY,
                        Math.cos(fireAngle) * 2.5, // Slower bullets
                        Math.sin(fireAngle) * 2.5,
                        false
                    );
                }
            }
            
            brainBlast() {
                // 🚀 PERFORMANCE CRITICAL: Significantly reduced bullet rings
                if (!enemyBulletPool) return;
                
                const baseRings = Math.min(2, 3 - Math.floor(this.wave / 8)); // Max 2 rings, fewer on higher waves
                const bulletsPerRing = Math.min(8, 12 - Math.floor(this.wave / 5)); // Fewer bullets per ring
                
                for (let ring = 0; ring < baseRings; ring++) {
                    setTimeout(() => {
                        if (!this.active || !enemyBulletPool) return;
                        
                        for (let i = 0; i < bulletsPerRing; i++) {
                            const angle = (Math.PI * 2 * i) / bulletsPerRing + (ring * 0.2);
                            const speed = 1.5 + ring * 0.3; // Slower bullets
                            
                            enemyBulletPool.get(
                                this.x,
                                this.y,
                                Math.cos(angle) * speed,
                                Math.sin(angle) * speed,
                                false
                            );
                        }
                    }, ring * 300); // Longer delay between rings
                }
            }
            
            draw(ctx) {
                ctx.save();
                
                switch(this.type) {
                    case 'spinner':
                        this.drawSpinner(ctx);
                        break;
                    case 'fortress':
                        this.drawFortress(ctx);
                        break;
                    case 'hydra':
                        this.drawHydra(ctx);
                        break;
                    case 'phoenix':
                        this.drawPhoenix(ctx);
                        break;
                    case 'motherbrain':
                        this.drawMotherbrain(ctx);
                        break;
                }
                
                ctx.restore();
                
                // Boss name and health bar
                this.drawHealthBar(ctx);
            }
            
            drawSpinner(ctx) {
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.shadowBlur = 30;
                ctx.shadowColor = this.color;
                
                // Spinning arms
                for (let i = 0; i < 4; i++) {
                    ctx.save();
                    ctx.rotate((Math.PI / 2) * i);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(this.size, 0);
                    ctx.lineTo(this.size * 0.8, this.size * 0.3);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.fillStyle = this.color + '33';
                    ctx.fill();
                    ctx.restore();
                }
                
                // Center core
                ctx.beginPath();
                ctx.arc(0, 0, 20, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fill();
            }
            
            drawFortress(ctx) {
                ctx.translate(this.x, this.y);
                
                // Main fortress body
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 4;
                ctx.shadowBlur = 25;
                ctx.shadowColor = this.color;
                
                ctx.beginPath();
                ctx.rect(-this.size/2, -this.size/2, this.size, this.size);
                ctx.stroke();
                ctx.fillStyle = this.color + '22';
                ctx.fill();
                
                // Turrets
                for (let i = 0; i < 4; i++) {
                    const angle = (Math.PI * 2 * i) / 4;
                    const turretX = Math.cos(angle) * (this.size * 0.6);
                    const turretY = Math.sin(angle) * (this.size * 0.6);
                    
                    ctx.beginPath();
                    ctx.arc(turretX, turretY, 8, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fill();
                }
                
                // Shield effect
                if (this.shieldActive) {
                    const shieldAlpha = 0.3 + Math.sin(this.glowPulse) * 0.2;
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#00ffff';
                    ctx.globalAlpha = shieldAlpha;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size + 15, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Draw walls
                ctx.globalAlpha = 1;
                this.walls.forEach(wall => {
                    ctx.fillStyle = '#666666';
                    ctx.fillRect(wall.x - this.x, wall.y - this.y, wall.width, wall.height);
                    ctx.strokeStyle = '#999999';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(wall.x - this.x, wall.y - this.y, wall.width, wall.height);
                });
            }
            
            drawHydra(ctx) {
                ctx.translate(this.x, this.y);
                
                // Main body
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 4;
                ctx.shadowBlur = 25;
                ctx.shadowColor = this.color;
                
                ctx.beginPath();
                ctx.arc(0, 0, this.size * 0.6, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = this.color + '33';
                ctx.fill();
                
                // Draw heads
                this.headPositions.forEach((head, index) => {
                    if (head.health > 0) {
                        const headX = Math.cos(head.angle) * head.radius;
                        const headY = Math.sin(head.angle) * head.radius;
                        
                        // Neck connection
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(headX, headY);
                        ctx.stroke();
                        
                        // Head
                        ctx.save();
                        ctx.translate(headX, headY);
                        ctx.beginPath();
                        ctx.arc(0, 0, 12, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.fill();
                        
                        // Eyes
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(-4, -4, 2, 2);
                        ctx.fillRect(2, -4, 2, 2);
                        ctx.restore();
                    }
                });
            }
            
            drawPhoenix(ctx) {
                // Draw flame trail
                this.flameTrail.forEach(flame => {
                    const alpha = flame.life / 40;
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = flame.color;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = flame.color;
                    ctx.beginPath();
                    ctx.arc(flame.x, flame.y, flame.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
                
                ctx.translate(this.x, this.y);
                ctx.rotate(Math.sin(this.glowPulse) * 0.1);
                
                // Phoenix body
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 4;
                ctx.shadowBlur = 30;
                ctx.shadowColor = this.color;
                
                // Wing spread
                for (let wing = -1; wing <= 1; wing += 2) {
                    ctx.save();
                    ctx.scale(wing, 1);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.quadraticCurveTo(this.size, -this.size/2, this.size * 1.2, this.size/4);
                    ctx.quadraticCurveTo(this.size * 0.8, this.size/2, this.size/2, this.size/3);
                    ctx.lineTo(0, 0);
                    ctx.stroke();
                    ctx.fillStyle = this.color + '22';
                    ctx.fill();
                    ctx.restore();
                }
                
                // Body
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size/3, this.size/2, 0, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fill();
                
                // Flame aura
                ctx.save();
                ctx.globalAlpha = 0.5 + Math.sin(this.glowPulse * 2) * 0.3;
                ctx.strokeStyle = '#ff3300';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 40;
                ctx.shadowColor = '#ff3300';
                ctx.beginPath();
                ctx.arc(0, 0, this.size + 20, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
            
            drawMotherbrain(ctx) {
                // Draw tentacles
                this.tentacles.forEach((tentacle, index) => {
                    if (tentacle.active) {
                        ctx.strokeStyle = this.color;
                        ctx.lineWidth = 8 - index;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = this.color;
                        
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        
                        for (let i = 0; i < tentacle.segments; i++) {
                            const segmentAngle = tentacle.angle + (i * 0.3) + Math.sin(this.brainPulse + i) * 0.2;
                            const segmentRadius = (tentacle.length / tentacle.segments) * (i + 1);
                            const segmentX = this.x + Math.cos(segmentAngle) * segmentRadius;
                            const segmentY = this.y + Math.sin(segmentAngle) * segmentRadius;
                            
                            if (i === 0) ctx.moveTo(segmentX, segmentY);
                            else ctx.lineTo(segmentX, segmentY);
                        }
                        ctx.stroke();
                    }
                });
                
                ctx.translate(this.x, this.y);
                
                // Draw satellites
                this.satellites.forEach((satellite, index) => {
                    if (satellite.active) {
                        const satX = Math.cos(satellite.angle) * satellite.distance;
                        const satY = Math.sin(satellite.angle) * satellite.distance;
                        
                        ctx.save();
                        ctx.translate(satX, satY);
                        ctx.strokeStyle = '#ff00ff';
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#ff00ff';
                        
                        ctx.beginPath();
                        ctx.arc(0, 0, satellite.size, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.fillStyle = '#ff00ff33';
                        ctx.fill();
                        ctx.restore();
                    }
                });
                
                // Main brain
                const brainPulse = 1 + Math.sin(this.brainPulse) * 0.2;
                ctx.scale(brainPulse, brainPulse);
                
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 5;
                ctx.shadowBlur = 40;
                ctx.shadowColor = this.color;
                
                // Brain wrinkles
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI * 2 * i) / 6;
                    ctx.save();
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.ellipse(0, -this.size/3, this.size/4, this.size/8, 0, 0, Math.PI);
                    ctx.stroke();
                    ctx.restore();
                }
                
                // Main brain body
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = this.color + '22';
                ctx.fill();
                
                // Central eye
                ctx.fillStyle = '#ff0000';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ff0000';
                ctx.beginPath();
                ctx.arc(0, 0, this.size/4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            drawHealthBar(ctx) {
                // Boss name
                ctx.save();
                ctx.font = 'bold 24px Courier New';
                ctx.textAlign = 'center';
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.color;
                ctx.fillText(this.name, this.x, this.y - this.size - 40);
                
                // Health bar background
                const barWidth = 120;
                const barHeight = 10;
                const barX = this.x - barWidth / 2;
                const barY = this.y - this.size - 20;
                
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ff0000';
                ctx.strokeRect(barX, barY, barWidth, barHeight);
                
                // Health bar fill
                const healthPercent = this.hp / this.maxHp;
                ctx.fillStyle = healthPercent > 0.3 ? '#00ff00' : '#ff0000';
                ctx.shadowBlur = 15;
                ctx.shadowColor = ctx.fillStyle;
                ctx.fillRect(barX + 1, barY + 1, (barWidth - 2) * healthPercent, barHeight - 2);
                
                // Shield bar for fortress
                if (this.type === 'fortress' && this.shieldActive) {
                    const shieldBarY = barY - 15;
                    ctx.strokeStyle = '#00ffff';
                    ctx.strokeRect(barX, shieldBarY, barWidth, barHeight);
                    
                    const shieldPercent = this.shieldHp / this.maxShieldHp;
                    ctx.fillStyle = '#00ffff';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#00ffff';
                    ctx.fillRect(barX + 1, shieldBarY + 1, (barWidth - 2) * shieldPercent, barHeight - 2);
                }
                
                ctx.restore();
            }
            
            takeDamage(amount) {
                try {
                    // Special damage handling for different boss types
                    switch(this.type) {
                        case 'fortress':
                            if (this.shieldActive && this.shieldHp > 0) {
                                this.shieldHp -= amount;
                                if (this.shieldHp <= 0) {
                                    this.shieldActive = false;
                                    this.shieldRegenTimer = 0;
                                }
                                return; // Shield absorbs damage
                            }
                            break;
                            
                        case 'hydra':
                            // Damage the closest head first
                            let damagedHead = false;
                            for (let head of this.headPositions) {
                                if (head.health > 0) {
                                    head.health -= amount;
                                    if (head.health <= 0) {
                                        this.heads--;
                                        damagedHead = true;
                                        
                                        // Head destruction effect
                                        if (particleSystem) {
                                            const headX = this.x + Math.cos(head.angle) * head.radius;
                                            const headY = this.y + Math.sin(head.angle) * head.radius;
                                            particleSystem.addExplosion(headX, headY, this.color, 15);
                                        }
                                    }
                                    break;
                                }
                            }
                            
                            // Only damage main body if no heads left
                            if (this.heads <= 0) {
                                this.hp -= amount * 2; // Double damage when headless
                            } else if (!damagedHead) {
                                this.hp -= Math.floor(amount / 2); // Reduced body damage when heads alive
                            }
                            
                            if (this.hp <= 0) {
                                this.active = false;
                                this.onDestroyed();
                            }
                            return;
                            
                        case 'phoenix':
                            this.hp -= amount;
                            if (this.hp <= 0 && this.currentRevives < this.maxRevives) {
                                // Phoenix revival!
                                this.currentRevives++;
                                this.hp = Math.floor(this.maxHp * (0.6 - this.currentRevives * 0.1)); // Less health each revival
                                
                                // Revival flame explosion
                                if (particleSystem) {
                                    for (let i = 0; i < 80; i++) {
                                        const angle = (Math.PI * 2 * i) / 80;
                                        const speed = Math.random() * 15 + 8;
                                        const color = i % 3 === 0 ? '#ff3300' : (i % 3 === 1 ? '#ff6600' : '#ffaa00');
                                        
                                        particleSystem.particles.push({
                                            x: this.x,
                                            y: this.y,
                                            vx: Math.cos(angle) * speed,
                                            vy: Math.sin(angle) * speed,
                                            color: color,
                                            life: 60,
                                            maxLife: 60,
                                            size: Math.random() * 8 + 4,
                                            active: true,
                                            update() {
                                                this.x += this.vx;
                                                this.y += this.vy;
                                                this.vx *= 0.94;
                                                this.vy *= 0.94;
                                                this.life--;
                                                if (this.life <= 0) this.active = false;
                                            },
                                            draw(ctx) {
                                                const alpha = this.life / this.maxLife;
                                                ctx.save();
                                                ctx.globalAlpha = alpha;
                                                ctx.fillStyle = this.color;
                                                ctx.shadowBlur = 20;
                                                ctx.shadowColor = this.color;
                                                ctx.beginPath();
                                                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                                ctx.fill();
                                                ctx.restore();
                                            }
                                        });
                                    }
                                }
                                
                                if (soundSystem) {
                                    soundSystem.playVoiceSample('RADICAL');
                                }
                                return; // Don't destroy on revival
                            }
                            break;
                            
                        case 'motherbrain':
                            // Satellites absorb some damage
                            const activeSatellites = this.satellites.filter(s => s.active).length;
                            if (activeSatellites > 0) {
                                // Damage random satellite first
                                const satelliteIndex = Math.floor(Math.random() * this.satellites.length);
                                if (this.satellites[satelliteIndex].active) {
                                    this.satellites[satelliteIndex].health -= amount;
                                    if (this.satellites[satelliteIndex].health <= 0) {
                                        this.satellites[satelliteIndex].active = false;
                                        
                                        // Satellite destruction effect
                                        const satX = this.x + Math.cos(this.satellites[satelliteIndex].angle) * this.satellites[satelliteIndex].distance;
                                        const satY = this.y + Math.sin(this.satellites[satelliteIndex].angle) * this.satellites[satelliteIndex].distance;
                                        
                                        if (particleSystem) {
                                            particleSystem.addExplosion(satX, satY, '#ff00ff', 20);
                                        }
                                    }
                                    return; // Satellite absorbed the damage
                                }
                            }
                            break;
                    }
                    
                    // Default damage handling
                    this.hp -= amount;
                    
                    if (this.hp <= 0) {
                        this.active = false;
                        this.onDestroyed();
                    }
                } catch (error) {
                    console.error('Boss take damage error:', error);
                }
            }
            
            onDestroyed() {
                let bossScore = 1000 * this.wave;
                gameState.score += bossScore;
                gameState.boss = null;
                
                console.log(`👑 Boss destroyed! Wave: ${this.wave}, Score: ${bossScore}, Total Score: ${gameState.score}`);
                
                // 🎆 EPIC BOSS EXPLOSION based on type!
                let explosionSize = 2.0;
                switch(this.type) {
                    case 'motherbrain':
                        explosionSize = 4.0;
                        break;
                    case 'phoenix':
                        explosionSize = 3.5;
                        break;
                    case 'fortress':
                        explosionSize = 3.0;
                        break;
                    case 'hydra':
                        explosionSize = 2.8;
                        break;
                    case 'spinner':
                        explosionSize = 2.5;
                        break;
                }
                
                if (epic80sExplosions) {
                    epic80sExplosions.push(new Epic80sExplosion(this.x, this.y, explosionSize));
                }
                
                if (particleSystem) {
                    const particleCount = 50 + (explosionSize * 10);
                    for (let i = 0; i < particleCount; i++) {
                        particleSystem.particles.push(new Particle(
                            this.x + (Math.random() - 0.5) * this.size,
                            this.y + (Math.random() - 0.5) * this.size,
                            (Math.random() - 0.5) * 15,
                            (Math.random() - 0.5) * 15,
                            `hsl(${Math.random() * 360}, 100%, 70%)`
                        ));
                    }
                }
                
                if (gameState.screenShake) {
                    gameState.screenShake.intensity = 15 + (explosionSize * 5);
                    gameState.screenShake.duration = 30 + (explosionSize * 10);
                }
                
                if (soundSystem) {
                    soundSystem.playExplosion();
                    setTimeout(() => {
                        const bossVoices = {
                            'spinner': 'EXCELLENT',
                            'fortress': 'OUTSTANDING',
                            'hydra': 'RADICAL',
                            'phoenix': 'PERFECT',
                            'motherbrain': 'RADICAL'
                        };
                        soundSystem.playVoiceSample(bossVoices[this.type] || 'EXCELLENT');
                    }, 300);
                }
                
                gameState.combo = 0;
                updateUI();
                
                if (enemyBulletPool) enemyBulletPool.clear();
                
                if (bossDeathTimeoutId) {
                    clearTimeout(bossDeathTimeoutId);
                }
                
                bossDeathTimeoutId = setTimeout(() => {
                    if (gameState && gameState.running) {
                        if (waveManager && typeof waveManager.nextWave === 'function') {
                            waveManager.nextWave();
                        } else {
                            gameState.wave++;
                            if (waveManager) {
                                waveManager.enemiesKilled = 0;
                                waveManager.bossSpawned = false;
                            }
                        }
                        updateUI();
                    }
                }, 2000);
            }
        }

        // Particle System with enhanced optimization
        class ParticleSystem {
            constructor() {
                this.particles = [];
                this.maxParticles = 80; // 🚀 PERFORMANCE: Reduced from 150
                this.frameCount = 0;
                this.cleanupInterval = 120; // Clean every 2 seconds at 60fps
                this.emergencyCleanupThreshold = 100; // Emergency cleanup trigger
            }
            
            addMuzzleFlash(x, y, direction, color) {
                // 🚀 PERFORMANCE: Reduced muzzle flash particles
                if (this.particles.length > this.maxParticles - 5) return; // Skip if nearly full
                
                for (let i = 0; i < 2; i++) { // Reduced from 3
                    const angle = direction + (Math.random() - 0.5) * 0.3;
                    const speed = 2 + Math.random() * 2;
                    this.particles.push(new MuzzleParticle(
                        x + Math.cos(direction) * 10,
                        y + Math.sin(direction) * 10,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        color
                    ));
                }
            }
            
            addExplosion(x, y, color, count = 20) {
                // 🚀 PERFORMANCE: Intelligent explosion scaling
                const adjustedCount = Math.min(count, Math.max(5, this.maxParticles - this.particles.length));
                
                for (let i = 0; i < adjustedCount; i++) {
                    const angle = (Math.PI * 2 * i) / adjustedCount;
                    const speed = Math.random() * 10 + 3; // Reduced max speed
                    const particleColor = i % 4 === 0 ? '#ffffff' : color;
                    
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        color: particleColor,
                        life: 30 + Math.random() * 15, // Shorter lifespan
                        maxLife: 45, // Reduced from 60
                        size: Math.random() * 3 + 2, // Smaller particles
                        gravity: 0.1,
                        bounce: 0.6,
                        friction: 0.96, // Higher friction = faster slow down
                        active: true,
                        type: 'explosion',
                        trailLength: 0, // Disable trails for performance
                        update() {
                            this.vy += this.gravity;
                            this.vx *= this.friction;
                            this.vy *= this.friction;
                            
                            this.x += this.vx;
                            this.y += this.vy;
                            
                            if (this.y > config.height - this.size && this.vy > 0) {
                                this.vy *= -this.bounce;
                                this.vx *= 0.8;
                            }
                            
                            this.life--;
                            if (this.life <= 0) this.active = false;
                        },
                        draw(ctx) {
                            if (!this.active) return;
                            
                            const alpha = Math.min(this.life / this.maxLife, 0.8); // Cap alpha
                            
                            ctx.save();
                            ctx.globalAlpha = alpha;
                            ctx.fillStyle = this.color;
                            ctx.shadowBlur = 8; // Reduced shadow blur
                            ctx.shadowColor = this.color;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }
                    });
                }
            }
            
            update() {
                this.frameCount++;
                
                // 🚀 EMERGENCY CLEANUP: If particles exceed threshold, aggressive cleanup
                if (this.particles.length > this.emergencyCleanupThreshold) {
                    this.emergencyCleanup();
                }
                
                // Update existing particles
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    if (p && typeof p.update === 'function') {
                        p.update();
                        if (!p.active || p.life <= 0) {
                            this.particles.splice(i, 1);
                        }
                    } else {
                        // Remove invalid particles immediately
                        this.particles.splice(i, 1);
                    }
                }
                
                // Regular cleanup every 2 seconds
                if (this.frameCount % this.cleanupInterval === 0) {
                    this.performanceCleanup();
                }
                
                // Hard limit enforcement
                if (this.particles.length > this.maxParticles) {
                    const excess = this.particles.length - this.maxParticles;
                    this.particles.splice(0, excess);
                    console.log(`⚠️ Particle hard limit reached, removed ${excess} particles`);
                }
            }
            
            emergencyCleanup() {
                console.log(`🚨 Emergency particle cleanup! Count: ${this.particles.length}`);
                
                // Remove particles with very low life first
                this.particles = this.particles.filter(p => {
                    if (!p || !p.active) return false;
                    
                    if (p.life !== undefined && p.maxLife !== undefined) {
                        const lifeRatio = p.life / p.maxLife;
                        return lifeRatio > 0.2; // Keep only particles with >20% life
                    }
                    return true;
                });
                
                // If still too many, remove oldest half
                if (this.particles.length > this.maxParticles) {
                    const keepCount = Math.floor(this.maxParticles * 0.5);
                    this.particles = this.particles.slice(-keepCount); // Keep newest
                }
                
                console.log(`🧹 Emergency cleanup complete: ${this.particles.length} particles remaining`);
            }
            
            performanceCleanup() {
                const beforeCount = this.particles.length;
                
                // Remove particles that are nearly invisible, very old, or off-screen
                this.particles = this.particles.filter(p => {
                    if (!p || !p.active) return false;
                    
                    // Remove particles with very low life
                    if (p.life !== undefined && p.maxLife !== undefined) {
                        const lifeRatio = p.life / p.maxLife;
                        if (lifeRatio < 0.1) return false; // Remove particles with <10% life
                    }
                    
                    // Remove particles that are far off-screen
                    if (p.x < -150 || p.x > config.width + 150 || 
                        p.y < -150 || p.y > config.height + 150) {
                        return false;
                    }
                    
                    return true;
                });
                
                const afterCount = this.particles.length;
                if (beforeCount !== afterCount) {
                    console.log(`🧹 Particle cleanup: ${beforeCount} → ${afterCount} particles`);
                }
            }
            
            draw(ctx) {
                // 🚀 PERFORMANCE: Batch drawing with less state changes
                ctx.save();
                this.particles.forEach(p => {
                    try {
                        if (p && p.draw && p.active) {
                            p.draw(ctx);
                        }
                    } catch (err) {
                        // Remove problematic particles
                        p.active = false;
                    }
                });
                ctx.restore();
            }
        }

        // Bullet Pool with enhanced performance
        class BulletPool {
            constructor() {
                this.bullets = [];
                this.maxBullets = 100; // 🚀 PERFORMANCE: Reduced from 150
                this.cleanupCounter = 0;
                this.lastCleanupCount = 0;
            }
            
            get(x, y, vx, vy, isPlayerBullet) {
                // 🚀 PERFORMANCE: Early rejection if approaching limit
                if (this.bullets.length > this.maxBullets * 0.9 && !isPlayerBullet) {
                    return null; // Don't spawn enemy bullets when near limit
                }
                
                // Find inactive bullet first
                for (let bullet of this.bullets) {
                    if (!bullet.active) {
                        bullet.reset(x, y, vx, vy, isPlayerBullet);
                        return bullet;
                    }
                }
                
                // Create new bullet only if under limit
                if (this.bullets.length < this.maxBullets) {
                    const bullet = new Bullet(x, y, vx, vy, isPlayerBullet);
                    this.bullets.push(bullet);
                    return bullet;
                }
                
                // If at limit, reuse oldest enemy bullet (preserve player bullets)
                if (!isPlayerBullet) {
                    for (let bullet of this.bullets) {
                        if (!bullet.isPlayerBullet && (!bullet.active || 
                            bullet.x < -50 || bullet.x > config.width + 50 || 
                            bullet.y < -50 || bullet.y > config.height + 50)) {
                            bullet.reset(x, y, vx, vy, isPlayerBullet);
                            return bullet;
                        }
                    }
                }
                
                return null;
            }
            
            update() {
                this.cleanupCounter++;
                
                // Regular update
                this.bullets.forEach(bullet => {
                    if (bullet.active) {
                        bullet.update();
                    }
                });
                
                // 🚀 PERFORMANCE: More frequent cleanup when high bullet count
                const cleanupInterval = this.bullets.length > 50 ? 90 : 180; // 1.5s vs 3s
                
                if (this.cleanupCounter >= cleanupInterval) {
                    this.performCleanup();
                    this.cleanupCounter = 0;
                }
            }
            
            performCleanup() {
                const activeBefore = this.bullets.filter(b => b.active).length;
                
                // Remove bullets that are far off-screen
                this.bullets.forEach(bullet => {
                    if (bullet.active && (
                        bullet.x < -120 || bullet.x > config.width + 120 ||
                        bullet.y < -120 || bullet.y > config.height + 120
                    )) {
                        bullet.active = false;
                    }
                });
                
                // 🚀 PERFORMANCE: Remove inactive bullets from array when too many
                if (this.bullets.length > this.maxBullets * 0.8) {
                    this.bullets = this.bullets.filter(b => b.active);
                    console.log(`🧹 Bullet pool compacted: ${this.bullets.length} bullets remaining`);
                }
                
                const activeAfter = this.bullets.filter(b => b.active).length;
                if (activeBefore !== activeAfter && activeAfter < this.lastCleanupCount - 5) {
                    console.log(`🧹 Bullet cleanup: ${activeBefore} → ${activeAfter} active bullets`);
                }
                this.lastCleanupCount = activeAfter;
            }
            
            draw(ctx) {
                ctx.save();
                this.bullets.forEach(bullet => {
                    if (bullet.active) bullet.draw(ctx);
                });
                ctx.restore();
            }
            
            clear() {
                this.bullets.forEach(bullet => bullet.active = false);
            }
            
            getActiveBullets() {
                return this.bullets.filter(b => b.active);
            }
            
            // 🚀 PERFORMANCE: Get active count without filtering
            getActiveCount() {
                let count = 0;
                for (let bullet of this.bullets) {
                    if (bullet.active) count++;
                }
                return count;
            }
        }

        // Bullet Class
        class Bullet {
            constructor(x, y, vx, vy, isPlayerBullet) {
                this.reset(x, y, vx, vy, isPlayerBullet);
            }
            
            reset(x, y, vx, vy, isPlayerBullet) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.isPlayerBullet = isPlayerBullet;
                this.active = true;
                this.damage = isPlayerBullet ? 1 : 1;
            }
            
            update() {
                if (!this.active) return;
                
                this.x += this.vx;
                this.y += this.vy;
                
                if (this.x < -10 || this.x > config.width + 10 || 
                    this.y < -10 || this.y > config.height + 10) {
                    this.active = false;
                }
            }
            
            draw(ctx) {
                if (!this.active) return;
                
                ctx.save();
                
                const color = this.isPlayerBullet ? '#00ff00' : '#ff0066';
                
                ctx.fillStyle = color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = color;
                ctx.globalAlpha = 0.8;
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.isPlayerBullet ? 4 : 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#ffffff';
                ctx.globalAlpha = 1;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.isPlayerBullet ? 2 : 1.5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x - this.vx * 2, this.y - this.vy * 2);
                ctx.stroke();
                
                ctx.restore();
            }
        }

        // Enhanced Wave Manager with Formation Attacks and Progressive Difficulty
        class WaveManager {
            constructor() {
                this.enemiesKilled = 0;
                this.enemiesPerWave = 10;
                this.bossSpawned = false;
                this.enemySpawnTimer = 0;
                this.formationSpawnTimer = 0;
                this.swarmSpawnTimer = 0;
                this.currentFormation = null;
                this.waveIntensity = 1;
                this.specialAttackCooldown = 0;
        // Track whether a mini‑boss has been spawned this wave. Mini‑bosses are
        // special enemies that appear every other wave. They are tougher and
        // fire more complex bullet patterns.
        this.miniBossSpawned = false;
            }
            
            update(deltaTime) {
                // Check for bonus round
                if (bonusRound && bonusRound.active) {
                    bonusRound.update();
                    return;
                }
                
                if (!gameState.boss) {
                    if (this.enemiesKilled >= this.enemiesPerWave && !this.bossSpawned) {
                        this.spawnBoss();
                        this.bossSpawned = true;
                    } else if (!this.bossSpawned) {
                        this.updateEnemySpawns(deltaTime);
                        this.updateSpecialAttacks(deltaTime);
                    }
                }
                
                // Update wave intensity based on current wave
                this.waveIntensity = 1 + (gameState.wave * 0.15);
            }
            
            updateEnemySpawns(deltaTime) {
                if (!gameState.boss && !this.bossSpawned) {
                    this.enemySpawnTimer += deltaTime;
                    this.formationSpawnTimer += deltaTime;
                    this.swarmSpawnTimer += deltaTime;
                    
                    // Base spawn rate gets faster with waves but starts easier
                    let baseSpawnRate;
                    if (gameState.wave <= 2) {
                        baseSpawnRate = 150; // Very slow early
                    } else if (gameState.wave <= 4) {
                        baseSpawnRate = 120;
                    } else if (gameState.wave <= 6) {
                        baseSpawnRate = 90;
                    } else if (gameState.wave <= 10) {
                        baseSpawnRate = 70;
                    } else {
                        baseSpawnRate = 50; // Fast in late game
                    }
                    
                    const adjustedSpawnRate = baseSpawnRate / this.waveIntensity;
                    
                    // Max enemies on screen scales with wave
                    let maxEnemies = Math.min(4 + Math.floor(gameState.wave / 2), 16);
                    
                    // Regular enemy spawning
                    if (this.enemySpawnTimer > adjustedSpawnRate && gameState.enemies.length < maxEnemies) {
                        if (Math.random() < 0.7) { // 70% chance for regular spawn
                            this.spawnEnemy();
                        } else { // 30% chance for tactical spawn
                            this.spawnTacticalGroup();
                        }
                        this.enemySpawnTimer = 0;
                    }
                    
                    // Formation attacks (classic 1942 style)
                    if (this.formationSpawnTimer > 400 && Math.random() < 0.3 && gameState.wave >= 3) {
                        this.spawnFormationAttack();
                        this.formationSpawnTimer = 0;
                    }
                    
                    // Swarm attacks for higher waves
                    if (this.swarmSpawnTimer > 600 && Math.random() < 0.2 && gameState.wave >= 5) {
                        this.spawnSwarmAttack();
                        this.swarmSpawnTimer = 0;
                    }
                }
            }
            
            updateSpecialAttacks(deltaTime) {
                this.specialAttackCooldown += deltaTime;

                // Spawn a mini‑boss on even numbered waves if one has not yet
                // appeared in the current wave. Mini‑bosses add variety and
                // challenge by forcing the player to focus on a tougher foe
                // while regular enemies continue spawning. We wait until the
                // special attack cooldown exceeds a threshold to avoid
                // spawning the mini‑boss immediately at the start of the wave.
                if (!this.miniBossSpawned && gameState.wave % 2 === 0 && gameState.wave >= 4 && this.specialAttackCooldown > 600) {
                    this.spawnMiniBoss();
                    this.miniBossSpawned = true;
                    // Reset cooldown to avoid triggering other special attacks
                    this.specialAttackCooldown = 0;
                }
                
                // Special wave-based attacks
                if (this.specialAttackCooldown > 800) {
                    const attackRoll = Math.random();
                    
                    if (gameState.wave >= 8 && attackRoll < 0.15) {
                        this.spawnPincerAttack();
                        this.specialAttackCooldown = 0;
                    } else if (gameState.wave >= 6 && attackRoll < 0.1) {
                        this.spawnEliteSquad();
                        this.specialAttackCooldown = 0;
                    } else if (gameState.wave >= 10 && attackRoll < 0.05) {
                        this.spawnBossRush();
                        this.specialAttackCooldown = 0;
                    }
                }
            }
            
            spawnEnemy() {
                try {
                    let availableTypes = ['triangle'];
                    if (gameState.wave >= 2) availableTypes.push('square');
                    if (gameState.wave >= 3) availableTypes.push('sinewave');
                    if (gameState.wave >= 4) availableTypes.push('pentagon');
                    if (gameState.wave >= 5) availableTypes.push('divebomber');
                    
                    let type = this.selectEnemyType(availableTypes);
                    
                    const x = Math.random() * (config.width - 100) + 50;
                    const enemy = new Enemy(x, -50, type);
                    
                    if (enemy && this.validateEnemy(enemy)) {
                        gameState.enemies.push(enemy);
                    }
                } catch (error) {
                    console.error('Error spawning enemy:', error);
                }
            }
            
            selectEnemyType(availableTypes) {
                const rand = Math.random();
                const wave = gameState.wave;
                
                // Progressive enemy distribution
                if (wave >= 12) {
                    // Late game - dangerous mix
                    if (rand < 0.2) return 'divebomber';
                    else if (rand < 0.35) return 'pentagon';
                    else if (rand < 0.55) return 'sinewave';
                    else if (rand < 0.75) return 'square';
                    else return 'triangle';
                } else if (wave >= 8) {
                    // Mid-late game - more variety
                    if (rand < 0.15) return 'divebomber';
                    else if (rand < 0.3) return 'pentagon';
                    else if (rand < 0.5) return 'sinewave';
                    else if (rand < 0.75) return 'square';
                    else return 'triangle';
                } else if (wave >= 5) {
                    // Mid game - introduce kamikaze
                    if (rand < 0.08) return 'divebomber';
                    else if (rand < 0.25) return 'pentagon';
                    else if (rand < 0.45) return 'sinewave';
                    else if (rand < 0.7) return 'square';
                    else return 'triangle';
                } else if (wave >= 3) {
                    // Early-mid game
                    if (rand < 0.15) return 'pentagon';
                    else if (rand < 0.35) return 'sinewave';
                    else if (rand < 0.65) return 'square';
                    else return 'triangle';
                } else {
                    // Early game
                    return rand < 0.4 ? 'square' : 'triangle';
                }
            }
            
            spawnTacticalGroup() {
                // Spawn 2-3 enemies in tactical formation
                const groupTypes = [
                    { leader: 'pentagon', followers: ['triangle', 'triangle'] },
                    { leader: 'square', followers: ['triangle', 'square'] },
                    { leader: 'sinewave', followers: ['pentagon'] }
                ];
                
                const group = groupTypes[Math.floor(Math.random() * groupTypes.length)];
                const centerX = Math.random() * (config.width - 200) + 100;
                
                // Spawn leader
                const leader = new Enemy(centerX, -50, group.leader);
                leader.isGroupLeader = true;
                leader.alertLevel = 50; // Start alert
                gameState.enemies.push(leader);
                
                // Spawn followers
                group.followers.forEach((type, index) => {
                    const offsetX = (index - group.followers.length/2) * 60;
                    const follower = new Enemy(centerX + offsetX, -80 - (index * 30), type);
                    follower.isGroupFollower = true;
                    follower.groupLeader = leader;
                    follower.alertLevel = 30;
                    gameState.enemies.push(follower);
                });
            }
            
            spawnFormationAttack() {
                /*
                 * Spawn a formation of enemies in one of several classic patterns.  
                 * We randomly choose between V, LINE and CIRCLE patterns.  
                 * Only the chosen formation is spawned; we avoid overlapping
                 * formations by using distinct conditional branches rather than a
                 * fall‑through. This function scales the number of enemies with
                 * the current wave and adjusts the type of enemy based on the
                 * wave number.
                 */
                const rand = Math.random();
                let formationType;
                if (rand < 0.33) {
                    formationType = 'V';
                } else if (rand < 0.66) {
                    formationType = 'LINE';
                } else {
                    formationType = 'CIRCLE';
                }
                const enemyType = gameState.wave >= 6 ? 'pentagon' : 'square';
                const formationSize = Math.min(3 + Math.floor(gameState.wave / 3), 7);
                
                if (formationType === 'V') {
                    // V‑formation: two lines of enemies forming a V shape,
                    // similar to formations seen in 1942/1943.
                    const centerX = config.width / 2;
                    const spacing = 50;
                    for (let i = 0; i < formationSize; i++) {
                        const row = Math.floor(i / 2);
                        const side = i % 2 === 0 ? 1 : -1;
                        const offsetX = side * row * spacing;
                        const offsetY = -row * 40;
                        const enemy = new Enemy(centerX + offsetX, -100 + offsetY, enemyType);
                        enemy.isInFormation = true;
                        enemy.formationType = 'V';
                        enemy.formationSpeed = 1.5;
                        enemy.alertLevel = 40;
                        gameState.enemies.push(enemy);
                    }
                } else if (formationType === 'LINE') {
                    // Line formation: enemies spread evenly across the screen
                    // width. Good for forcing the player to weave vertically.
                    const startX = 100;
                    const spacing = (config.width - 200) / (formationSize - 1);
                    for (let i = 0; i < formationSize; i++) {
                        const x = startX + (i * spacing);
                        const enemy = new Enemy(x, -50, enemyType);
                        enemy.isInFormation = true;
                        enemy.formationType = 'LINE';
                        enemy.formationSpeed = 2;
                        enemy.alertLevel = 60;
                        gameState.enemies.push(enemy);
                    }
                } else {
                    // Circle/arc formation: spawn enemies along a semi‑circle arc
                    // across the top half of the screen. This pattern adds
                    // variety and is reminiscent of Geometry Wars arcs.
                    const centerX = config.width / 2;
                    const radius = 80;
                    for (let i = 0; i < formationSize; i++) {
                        // Spread enemies evenly across 180° (0° to 180°)
                        const angle = Math.PI * (i + 1) / (formationSize + 1);
                        const x = centerX + Math.cos(angle) * radius;
                        const y = -100 + Math.sin(angle) * radius;
                        const enemy = new Enemy(x, y, enemyType);
                        enemy.isInFormation = true;
                        enemy.formationType = 'CIRCLE';
                        enemy.formationSpeed = 1.8;
                        enemy.alertLevel = 50;
                        gameState.enemies.push(enemy);
                    }
                }
                // Play a voice cue occasionally to announce incoming formations.
                if (soundSystem && Math.random() < 0.3) {
                    setTimeout(() => {
                        soundSystem.playVoiceSample('GET READY');
                    }, 500);
                }
            }
            
            spawnSwarmAttack() {
                // Spawn many weak enemies quickly
                const swarmSize = Math.min(8 + gameState.wave, 15);
                const swarmType = 'triangle';
                
                for (let i = 0; i < swarmSize; i++) {
                    setTimeout(() => {
                        const x = Math.random() * config.width;
                        const enemy = new Enemy(x, -50, swarmType);
                        enemy.speed *= 1.5; // Faster swarm
                        enemy.isSwarmMember = true;
                        enemy.alertLevel = 80; // Very aggressive
                        gameState.enemies.push(enemy);
                    }, i * 100); // Staggered spawn
                }
                
                if (soundSystem) {
                    soundSystem.playVoiceSample('GET READY');
                }
            }
            
            spawnPincerAttack() {
                // Attack from both sides
                const enemyType = 'pentagon';
                const sideSize = 3;
                
                // Left pincer
                for (let i = 0; i < sideSize; i++) {
                    const enemy = new Enemy(50, -50 - (i * 60), enemyType);
                    enemy.isPincerAttacker = true;
                    enemy.pincerSide = 'left';
                    enemy.alertLevel = 70;
                    gameState.enemies.push(enemy);
                }
                
                // Right pincer
                for (let i = 0; i < sideSize; i++) {
                    const enemy = new Enemy(config.width - 50, -50 - (i * 60), enemyType);
                    enemy.isPincerAttacker = true;
                    enemy.pincerSide = 'right';
                    enemy.alertLevel = 70;
                    gameState.enemies.push(enemy);
                }
            }
            
            spawnEliteSquad() {
                // Small group of very dangerous enemies
                const eliteTypes = ['sinewave', 'pentagon'];
                const squadSize = 2 + Math.floor(gameState.wave / 5);
                
                for (let i = 0; i < squadSize; i++) {
                    const type = eliteTypes[i % eliteTypes.length];
                    const x = (config.width / (squadSize + 1)) * (i + 1);
                    const enemy = new Enemy(x, -100, type);
                    enemy.isElite = true;
                    enemy.hp += 2; // Extra health
                    enemy.speed *= 1.3;
                    enemy.bulletSpeed *= 1.4;
                    enemy.alertLevel = 90;
                    enemy.points *= 2; // Double points
                    gameState.enemies.push(enemy);
                }
                
                if (soundSystem) {
                    soundSystem.playVoiceSample('OUTSTANDING');
                }
            }
            
            spawnBossRush() {
                // Mini-boss before real boss
                if (gameState.wave >= 10) {
                    const miniBoss = new Enemy(config.width / 2, -100, 'pentagon');
                    miniBoss.isMiniBoss = true;
                    miniBoss.hp = 8 + gameState.wave;
                    miniBoss.size *= 1.5;
                    miniBoss.points = 1000;
                    miniBoss.speed = 1;
                    miniBoss.fireRate = 20;
                    miniBoss.bulletSpeed *= 1.5;
                    miniBoss.color = '#ff00ff';
                    miniBoss.alertLevel = 100;
                    gameState.enemies.push(miniBoss);
                    
                    if (soundSystem) {
                        soundSystem.playVoiceSample('EXCELLENT');
                    }
                }
            }

            /**
             * Spawn a mini‑boss enemy. Mini‑bosses appear on even numbered waves
             * to provide a tougher mid‑wave challenge. They have increased
             * hit points, a larger size and a special firing pattern. They
             * approach from the top of the screen and slowly descend while
             * attacking.
             */
            spawnMiniBoss() {
                try {
                    // Choose a base type for the mini‑boss. Using 'square' gives
                    // a heavy base with moderate speed and fire rate, which we
                    // enhance further. Alternatively pentagon could be used.
                    const baseType = gameState.wave < 6 ? 'square' : 'pentagon';
                    const boss = new Enemy(config.width / 2, -80, baseType);
                    boss.isMiniBoss = true;

                    // Increase stats to make the mini‑boss stand out. The hit
                    // points scale with the current wave so that later mini‑bosses
                    // take more hits to destroy.
                    boss.hp = (boss.hp || 3) + Math.floor(gameState.wave / 2) + 4;
                    boss.size *= 1.7;
                    boss.speed = Math.max(0.6, boss.speed * 0.8);
                    // Faster firing for a more intense challenge but never too
                    // extreme. Fire rate is capped to avoid excessive shots.
                    boss.fireRate = Math.max(15, Math.floor(60 - gameState.wave * 1.5));
                    boss.bulletSpeed *= 1.4;
                    boss.points = (boss.points || 200) + 300 + (gameState.wave * 15);
                    // Distinct colour to differentiate the mini‑boss visually.
                    boss.color = '#ff00ff';
                    boss.alertLevel = 100;
                    // Prevent the boss from being removed too early when off‑screen.
                    boss.isMiniBoss = true;

                    gameState.enemies.push(boss);
                    if (soundSystem) {
                        soundSystem.playVoiceSample('WATCH OUT');
                    }
                } catch (error) {
                    console.error('Error spawning mini‑boss:', error);
                }
            }
            
            validateEnemy(enemy) {
                return enemy && 
                       enemy.x !== undefined && 
                       enemy.y !== undefined && 
                       enemy.color && 
                       enemy.size && 
                       enemy.active !== undefined;
            }
            
            onEnemyKilled() {
                this.enemiesKilled++;
            }
            
            spawnBoss() {
                try {
                    if (!Boss || typeof Boss !== 'function') {
                        console.error('Boss class not defined');
                        this.bossSpawned = false;
                        return;
                    }
                    
                    gameState.boss = new Boss(gameState.wave);
                    
                    if (!gameState.boss || !gameState.boss.update) {
                        console.error('Boss creation failed');
                        gameState.boss = null;
                        this.bossSpawned = false;
                    } else {
                        // Boss arrival announcement
                        if (soundSystem) {
                            setTimeout(() => {
                                const bossVoices = {
                                    'spinner': 'GET READY',
                                    'fortress': 'OUTSTANDING',
                                    'hydra': 'EXCELLENT', 
                                    'phoenix': 'RADICAL',
                                    'motherbrain': 'PERFECT'
                                };
                                
                                const cycle = Math.floor((gameState.wave - 1) / 5);
                                let message = bossVoices[gameState.boss.type] || 'GET READY';
                                
                                // Special announcements for later cycles
                                if (cycle >= 1) {
                                    if (cycle === 1) message = 'EXCELLENT';
                                    else if (cycle === 2) message = 'OUTSTANDING';  
                                    else if (cycle >= 3) message = 'RADICAL';
                                }
                                
                                soundSystem.playVoiceSample(message);
                            }, 1000);
                        }
                    }
                } catch (error) {
                    console.error('Error spawning boss:', error);
                    this.bossSpawned = false;
                    gameState.boss = null;
                }
            }
            
            nextWave() {
                try {
                    gameState.wave++;
                    this.enemiesKilled = 0;
                    this.bossSpawned = false;
                    // Increase number of enemies per wave to make waves last longer
                    // Base increased from 12 to 18 and multiplier from 2 to 3
                    this.enemiesPerWave = Math.min(18 + gameState.wave * 3, 40);
                    
                    // Reset timers for new wave
                    this.enemySpawnTimer = 0;
                    this.formationSpawnTimer = 0;
                    this.swarmSpawnTimer = 0;
                    this.specialAttackCooldown = 0;

        // Reset mini‑boss flag when a new wave begins so that a fresh mini‑boss can be
        // spawned in the next even‑numbered wave.
        this.miniBossSpawned = false;
                    
                    // Theme change and other existing effects...
                    if (gameState.wave <= 6) {
                        gameState.themeChangeTimer = 120;
                        
                        if (vhsGlitch) {
                            vhsGlitch.triggerGlitch(1.5);
                        }
                        
                        const theme = getCurrentTheme();
                        
                        // Theme change effects (existing code)
                        if (particleSystem) {
                            for (let i = 0; i < 60; i++) {
                                const angle = (Math.PI * 2 * i) / 60;
                                const speed = Math.random() * 12 + 5;
                                
                                let color;
                                if (i % 3 === 0) color = theme.primary;
                                else if (i % 3 === 1) color = theme.secondary;
                                else color = theme.accent;
                                
                                particleSystem.particles.push({
                                    x: config.width / 2,
                                    y: config.height * 0.25,
                                    vx: Math.cos(angle) * speed,
                                    vy: Math.sin(angle) * speed,
                                    color: color,
                                    life: 90,
                                    maxLife: 90,
                                    size: Math.random() * 4 + 2,
                                    active: true,
                                    type: 'theme_particle',
                                    update() {
                                        this.x += this.vx;
                                        this.y += this.vy;
                                        this.vx *= 0.94;
                                        this.vy *= 0.94;
                                        this.life--;
                                        if (this.life <= 0) this.active = false;
                                    },
                                    draw(ctx) {
                                        const alpha = this.life / this.maxLife;
                                        ctx.save();
                                        ctx.globalAlpha = alpha;
                                        ctx.fillStyle = this.color;
                                        ctx.shadowBlur = 20;
                                        ctx.shadowColor = this.color;
                                        ctx.beginPath();
                                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                        ctx.fill();
                                        ctx.restore();
                                    }
                                });
                            }
                        }
                        
                        if (soundSystem) {
                            setTimeout(() => {
                                soundSystem.playVoiceSample('EXCELLENT');
                            }, 500);
                        }
                    }
                    
                    // Bonus round every 3 waves
                    if (gameState.wave % 3 === 0) {
                        bonusRound = new BonusRound(gameState.wave);
                        
                        gameState.particles.push({
                            text: 'BONUS ROUND!',
                            x: config.width / 2,
                            y: config.height / 2,
                            life: 120,
                            maxLife: 120,
                            scale: 0.1,
                            hue: 0,
                            active: true,
                            update() {
                                this.life--;
                                this.hue = (this.hue + 5) % 360;
                                if (this.scale < 2) this.scale += 0.15;
                                if (this.life <= 0) this.active = false;
                            },
                            draw(ctx) {
                                const alpha = this.life / this.maxLife;
                                ctx.save();
                                ctx.translate(this.x, this.y);
                                ctx.scale(this.scale, this.scale);
                                ctx.globalAlpha = alpha;
                                
                                ctx.font = 'bold 64px Courier New';
                                ctx.textAlign = 'center';
                                ctx.fillStyle = `hsl(${this.hue}, 100%, 50%)`;
                                ctx.shadowBlur = 40;
                                ctx.shadowColor = ctx.fillStyle;
                                ctx.fillText(this.text, 0, 0);
                                
                                ctx.restore();
                            }
                        });
                        
                        if (soundSystem) soundSystem.playVoiceSample('EXCELLENT');
                    }
                    
                    // Extra life every 5 waves (rarely)
                    // Only award an extra life if under the cap and with a low probability.
                    if (gameState.wave % 5 === 0 && gameState.lives < 5) {
                        // 30% chance to earn an extra life on the 5th, 10th, etc. wave
                        if (Math.random() < 0.3) {
                            gameState.lives++;
                            updateUI();
                        }
                    }
                } catch (error) {
                    console.error('Error advancing wave:', error);
                }
            }
        }

        // Enhanced PowerUp Class with Advanced Combination System
        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.active = true;
                this.lifetime = 400; // Increased lifetime for more chances to collect
                this.pulseTimer = 0;
                this.magnetRange = 0;
                
                this.setupPowerUpData();
            }
            
            setupPowerUpData() {
                const powerUpData = {
                    // Classic power-ups (common)
                    weapon: { color: '#ffff00', symbol: 'W', rarity: 'common', description: 'Upgrade weapon level' },
                    shield: { color: '#00ffff', symbol: 'S', rarity: 'common', description: 'Energy shield protection' },
                    bomb: { color: '#ff00ff', symbol: 'B', rarity: 'common', description: 'Screen-clearing explosion' },
                    rapid: { color: '#ff8800', symbol: 'R', rarity: 'common', description: 'Increased fire rate' },
                    health: { color: '#ff0000', symbol: '♥', rarity: 'common', description: 'Restore life' },
                    
                    // Weapon Enhancement (uncommon)
                    laser: { color: '#00ff00', symbol: 'L', rarity: 'uncommon', description: 'Continuous laser beam' },
                    homing: { color: '#ff0080', symbol: 'H', rarity: 'uncommon', description: 'Heat-seeking bullets' },
                    spread: { color: '#8000ff', symbol: 'X', rarity: 'uncommon', description: 'Multi-directional shots' },
                    pierce: { color: '#ffaa00', symbol: 'P', rarity: 'uncommon', description: 'Bullets pierce enemies' },
                    bounce: { color: '#00aa80', symbol: 'O', rarity: 'uncommon', description: 'Bullets ricochet off walls' },
                    chain: { color: '#aa0080', symbol: 'C', rarity: 'uncommon', description: 'Lightning chain damage' },
                    
                    // Tactical Systems (rare)  
                    time: { color: '#00ffaa', symbol: 'T', rarity: 'rare', description: 'Slow motion effect' },
                    magnet: { color: '#ff6600', symbol: 'M', rarity: 'rare', description: 'Attract power-ups' },
                    ghost: { color: '#aaaaff', symbol: 'G', rarity: 'rare', description: 'Phase through enemies' },
                    double: { color: '#ff00aa', symbol: 'D', rarity: 'rare', description: 'Mirror ship companion' },
                    nova: { color: '#ffff80', symbol: 'N', rarity: 'rare', description: 'Explosive nova blast' },
                    freeze: { color: '#80aaff', symbol: 'F', rarity: 'rare', description: 'Freeze all enemies' },
                    reflect: { color: '#ff8080', symbol: '↗', rarity: 'rare', description: 'Reflect enemy bullets' },
                    
                    // Advanced Systems (epic)
                    vortex: { color: '#80ff80', symbol: 'V', rarity: 'epic', description: 'Gravity manipulation' },
                    quantum: { color: '#ff80ff', symbol: 'Q', rarity: 'epic', description: 'Quantum entanglement shots' },
                    plasma: { color: '#80ffff', symbol: '∞', rarity: 'epic', description: 'Unlimited energy weapons' },
                    matrix: { color: '#40ff40', symbol: '█', rarity: 'epic', description: 'Bullet-time matrix mode' },
                    
                    // Ultimate Power (legendary)
                    omega: { color: '#ff8080', symbol: 'Ω', rarity: 'legendary', description: 'Ultimate destruction mode' },
                    fever: { color: '#ffffff', symbol: '★', rarity: 'legendary', description: 'Rainbow invincibility' },
                    infinity: { color: '#ffaa00', symbol: '∞', rarity: 'legendary', description: 'Infinite power loop' },
                    godmode: { color: '#aaaaaa', symbol: '◊', rarity: 'legendary', description: 'Transcendent power' }
                };
                
                const data = powerUpData[this.type] || powerUpData.weapon;
                this.color = data.color;
                this.symbol = data.symbol;
                this.rarity = data.rarity;
                this.rainbowHue = 0;
                
                // Set magnet range for magnet power-up
                if (this.type === 'magnet') {
                    this.magnetRange = 80;
                }
                
                // Special effects for rare+ power-ups
                if (['rare', 'epic', 'legendary'].includes(this.rarity)) {
                    this.lifetime += 100; // Last longer
                }
            }
            
            update() {
                this.lifetime--;
                this.pulseTimer += 0.1;
                
                // Rainbow effect for legendary items
                if (this.rarity === 'legendary') {
                    this.rainbowHue = (this.rainbowHue + 5) % 360;
                    this.color = `hsl(${this.rainbowHue}, 100%, 50%)`;
                }
                
                if (this.lifetime <= 0) {
                    this.active = false;
                }
                
                this.y += 0.5;
                
                // Magnet effect
                if (this.magnetRange > 0 && gameState && gameState.player) {
                    const dist = Math.hypot(this.x - gameState.player.x, this.y - gameState.player.y);
                    if (dist < this.magnetRange) {
                        const angle = Math.atan2(gameState.player.y - this.y, gameState.player.x - this.x);
                        const magnetForce = Math.max(0.5, (this.magnetRange - dist) / this.magnetRange * 3);
                        this.x += Math.cos(angle) * magnetForce;
                        this.y += Math.sin(angle) * magnetForce;
                    }
                }
                
                if (this.y > config.height + 30) {
                    this.active = false;
                }
            }
            
            draw(ctx) {
                const pulse = Math.sin(this.pulseTimer) * 0.3 + 0.7;
                const alpha = this.lifetime < 100 ? this.lifetime / 100 : 1;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Rarity-based effects
                if (this.rarity === 'legendary') {
                    // Rainbow legendary aura
                    ctx.rotate(this.pulseTimer * 2);
                    for (let i = 0; i < 6; i++) {
                        const hue = (this.rainbowHue + i * 60) % 360;
                        ctx.strokeStyle = `hsla(${hue}, 100%, 50%, ${alpha * (0.6 - i * 0.1)})`;
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 30;
                        ctx.shadowColor = ctx.strokeStyle;
                        ctx.beginPath();
                        ctx.arc(0, 0, 15 + i * 4, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.rotate(-this.pulseTimer * 2);
                } else if (this.rarity === 'epic') {
                    // Purple epic aura
                    ctx.strokeStyle = '#8000ff';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = '#8000ff';
                    ctx.globalAlpha = alpha * 0.7;
                    ctx.beginPath();
                    ctx.arc(0, 0, 20 + Math.sin(this.pulseTimer) * 5, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (this.rarity === 'rare') {
                    // Blue rare aura
                    ctx.strokeStyle = '#0080ff';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#0080ff';
                    ctx.globalAlpha = alpha * 0.6;
                    ctx.beginPath();
                    ctx.arc(0, 0, 18, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.globalAlpha = alpha;
                ctx.rotate(this.pulseTimer * 0.5);
                
                // Main power-up shape
                if (this.type === 'health') {
                    ctx.fillStyle = this.color;
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 20 * pulse;
                    ctx.shadowColor = this.color;
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.symbol, 0, 0);
                    ctx.strokeText(this.symbol, 0, 0);
                } else {
                    // Diamond/square shape for other power-ups
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 20 * pulse;
                    ctx.shadowColor = this.color;
                    
                    const size = this.rarity === 'legendary' ? 20 : 
                                this.rarity === 'epic' ? 18 :
                                this.rarity === 'rare' ? 16 : 15;
                    
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size, 0);
                    ctx.lineTo(0, size);
                    ctx.lineTo(-size, 0);
                    ctx.closePath();
                    ctx.stroke();
                    
                    ctx.fillStyle = this.color + (this.rarity === 'legendary' ? '66' : '33');
                    ctx.fill();
                    
                    // Symbol
                    ctx.fillStyle = '#ffffff';
                    const fontSize = this.rarity === 'legendary' ? 18 : 16;
                    ctx.font = `bold ${fontSize}px Courier New`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = this.color;
                    ctx.fillText(this.symbol, 0, 0);
                }
                
                // Magnet field visualization
                if (this.magnetRange > 0 && Math.sin(this.pulseTimer) > 0.5) {
                    ctx.strokeStyle = 'rgba(255, 102, 0, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(0, 0, this.magnetRange, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                ctx.restore();
            }
        }
        
        // Advanced Power-Up Combination System
        class PowerUpManager {
            constructor(player) {
                this.player = player;
                this.activePowerUps = new Map();
                this.combinations = new Map();
                this.synergies = new Map();
                this.comboEffects = [];
                this.powerUpHistory = [];
                this.comboMultiplier = 1.0;
                
                this.setupCombinations();
                this.setupSynergies();
            }
            
            setupCombinations() {
                // 2-Power Combinations
                this.combinations.set('laser+rapid', {
                    name: 'PULSE CANNON',
                    effect: 'Rapid continuous laser beams',
                    color: '#00ff88',
                    duration: 300,
                    tier: 1
                });
                
                this.combinations.set('weapon+spread', {
                    name: 'SHOTGUN ARRAY',
                    effect: 'Multi-level spread weapons',
                    color: '#ff8000',
                    duration: 280,
                    tier: 1
                });
                
                this.combinations.set('homing+pierce', {
                    name: 'SEEKER DRILL',
                    effect: 'Piercing heat-seeking rounds',
                    color: '#ff0080',
                    duration: 320,
                    tier: 1
                });
                
                this.combinations.set('bounce+chain', {
                    name: 'LIGHTNING WEB',
                    effect: 'Ricocheting chain lightning',
                    color: '#80ffaa',
                    duration: 300,
                    tier: 1
                });
                
                this.combinations.set('time+freeze', {
                    name: 'TEMPORAL LOCK',
                    effect: 'Slow-motion frozen time',
                    color: '#aaffff',
                    duration: 250,
                    tier: 1
                });
                
                this.combinations.set('magnet+vortex', {
                    name: 'GRAVITY WELL',
                    effect: 'Massive gravitational pull',
                    color: '#ff80ff',
                    duration: 400,
                    tier: 1
                });
                
                this.combinations.set('ghost+double', {
                    name: 'PHANTOM TWINS',
                    effect: 'Dual phasing mirror ships',
                    color: '#aaffff',
                    duration: 350,
                    tier: 1
                });
                
                this.combinations.set('shield+reflect', {
                    name: 'MIRROR FORTRESS',
                    effect: 'Reflecting energy shields',
                    color: '#ff8888',
                    duration: 380,
                    tier: 1
                });
                
                // 3-Power Elite Combinations
                this.combinations.set('laser+homing+pierce', {
                    name: 'OMEGA BEAM',
                    effect: 'Piercing homing laser destruction',
                    color: '#ff00ff',
                    duration: 400,
                    tier: 2
                });
                
                this.combinations.set('time+quantum+matrix', {
                    name: 'REALITY BREACH',
                    effect: 'Quantum bullet-time matrix',
                    color: '#00ffff',
                    duration: 500,
                    tier: 2
                });
                
                this.combinations.set('vortex+plasma+nova', {
                    name: 'STELLAR COLLAPSE',
                    effect: 'Gravitational plasma implosion',
                    color: '#ffaa00',
                    duration: 450,
                    tier: 2
                });
                
                this.combinations.set('shield+ghost+fever', {
                    name: 'ASCENSION MODE',
                    effect: 'Transcendent rainbow phasing',
                    color: '#ffffff',
                    duration: 600,
                    tier: 2
                });
                
                // 4+ Power Legendary Combinations
                this.combinations.set('omega+infinity+godmode+fever', {
                    name: 'DIGITAL GODHOOD',
                    effect: 'Ultimate transcendent power',
                    color: '#ffff00',
                    duration: 800,
                    tier: 3
                });
            }
            
            setupSynergies() {
                // Synergies boost existing power-ups when combined
                this.synergies.set('weapon+laser', { boost: 1.5, effect: 'Weapon upgrades boost laser power' });
                this.synergies.set('rapid+spread', { boost: 1.3, effect: 'Faster spread shot fire rate' });
                this.synergies.set('homing+magnet', { boost: 1.4, effect: 'Enhanced homing accuracy' });
                this.synergies.set('time+freeze', { boost: 1.6, effect: 'Extended slow-motion duration' });
                this.synergies.set('pierce+bounce', { boost: 1.3, effect: 'Piercing ricochets' });
                this.synergies.set('shield+reflect', { boost: 1.4, effect: 'Stronger reflective barriers' });
                this.synergies.set('ghost+quantum', { boost: 1.5, effect: 'Quantum phasing abilities' });
                this.synergies.set('vortex+nova', { boost: 1.7, effect: 'Gravitational explosions' });
                this.synergies.set('plasma+infinity', { boost: 2.0, effect: 'Infinite plasma energy' });
                this.synergies.set('fever+godmode', { boost: 2.5, effect: 'Divine rainbow power' });
            }
            
            addPowerUp(type, duration = 600) {
                const existingPowerUp = this.activePowerUps.get(type);
                
                if (existingPowerUp) {
                    // Refresh duration and increase potency
                    existingPowerUp.duration = Math.max(existingPowerUp.duration, duration);
                    existingPowerUp.stacks = Math.min(existingPowerUp.stacks + 1, 5); // Increased max stacks
                } else {
                    // Add new power-up
                    this.activePowerUps.set(type, {
                        duration: duration,
                        stacks: 1,
                        timer: 0,
                        synergy: 1.0
                    });
                }
                
                // Add to history for advanced tracking
                this.powerUpHistory.push({ type, timestamp: Date.now() });
                if (this.powerUpHistory.length > 10) {
                    this.powerUpHistory.shift();
                }
                
                this.checkCombinations();
                this.checkSynergies();
                this.applyPowerUpEffect(type);
                
                console.log(`⚡ Power-up activated: ${type.toUpperCase()} (Stacks: ${this.activePowerUps.get(type).stacks})`);
            }
            
            checkSynergies() {
                const activeTypes = Array.from(this.activePowerUps.keys());
                
                // Check all possible synergy pairs
                for (let [synergyPair, synergyData] of this.synergies) {
                    const [type1, type2] = synergyPair.split('+');
                    
                    if (activeTypes.includes(type1) && activeTypes.includes(type2)) {
                        // Apply synergy boost to both power-ups
                        if (this.activePowerUps.has(type1)) {
                            this.activePowerUps.get(type1).synergy = synergyData.boost;
                        }
                        if (this.activePowerUps.has(type2)) {
                            this.activePowerUps.get(type2).synergy = synergyData.boost;
                        }
                        
                        // Update combo multiplier
                        this.comboMultiplier = Math.max(this.comboMultiplier, synergyData.boost);
                        
                        console.log(`🔗 Synergy activated: ${synergyData.effect}`);
                    }
                }
            }
            
            checkCombinations() {
                const activeTypes = Array.from(this.activePowerUps.keys()).sort();
                
                // Check all possible combinations (2, 3, 4+ power-ups)
                for (let [combo, data] of this.combinations) {
                    const requiredTypes = combo.split('+').sort();
                    
                    if (requiredTypes.every(type => activeTypes.includes(type))) {
                        if (!this.comboEffects.find(effect => effect.name === data.name)) {
                            this.activateCombo(data, requiredTypes);
                        }
                    }
                }
            }
            
            activateCombo(comboData, requiredTypes) {
                this.comboEffects.push({
                    name: comboData.name,
                    effect: comboData.effect,
                    color: comboData.color,
                    duration: comboData.duration,
                    timer: 0,
                    active: true,
                    tier: comboData.tier || 1,
                    requiredTypes: requiredTypes
                });
                
                // Visual combo notification with tier-based effects
                if (gameState && gameState.particles) {
                    const intensity = comboData.tier || 1;
                    
                    gameState.particles.push({
                        text: comboData.name,
                        subtitle: comboData.effect,
                        tier: `TIER ${comboData.tier || 1}`,
                        x: config.width / 2,
                        y: config.height / 3,
                        life: 240 + (intensity * 60),
                        maxLife: 240 + (intensity * 60),
                        scale: 0.1,
                        active: true,
                        color: comboData.color,
                        intensity: intensity,
                        particles: [],
                        update() {
                            this.life--;
                            if (this.scale < 1.8) this.scale += 0.1 * this.intensity;
                            
                            // Generate celebration particles
                            if (this.life % 5 === 0 && this.particles.length < 50) {
                                for (let i = 0; i < this.intensity * 2; i++) {
                                    const angle = Math.random() * Math.PI * 2;
                                    const speed = Math.random() * 8 + 4;
                                    this.particles.push({
                                        x: 0,
                                        y: 0,
                                        vx: Math.cos(angle) * speed,
                                        vy: Math.sin(angle) * speed,
                                        color: this.color,
                                        life: 30,
                                        size: Math.random() * 3 + 2
                                    });
                                }
                            }
                            
                            // Update particles
                            this.particles = this.particles.filter(p => {
                                p.x += p.vx;
                                p.y += p.vy;
                                p.vx *= 0.95;
                                p.vy *= 0.95;
                                p.life--;
                                return p.life > 0;
                            });
                            
                            if (this.life <= 0) this.active = false;
                        },
                        draw(ctx) {
                            const alpha = this.life / this.maxLife;
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.scale(this.scale, this.scale);
                            ctx.globalAlpha = alpha;
                            
                            // Draw celebration particles
                            this.particles.forEach(p => {
                                const pAlpha = p.life / 30;
                                ctx.save();
                                ctx.globalAlpha = pAlpha;
                                ctx.fillStyle = p.color;
                                ctx.shadowBlur = 15;
                                ctx.shadowColor = p.color;
                                ctx.beginPath();
                                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.restore();
                            });
                            
                            // Main combo name with tier-based effects
                            const fontSize = 36 + (this.intensity * 8);
                            ctx.font = `bold ${fontSize}px Courier New`;
                            ctx.textAlign = 'center';
                            ctx.fillStyle = this.color;
                            ctx.shadowBlur = 30 + (this.intensity * 10);
                            ctx.shadowColor = this.color;
                            
                            // Tier-specific visual effects
                            if (this.intensity >= 2) {
                                // Rainbow effect for tier 2+
                                const gradient = ctx.createLinearGradient(-200, 0, 200, 0);
                                const hue = Date.now() * 0.01 % 360;
                                gradient.addColorStop(0, `hsl(${hue}, 100%, 50%)`);
                                gradient.addColorStop(0.5, `hsl(${(hue + 120) % 360}, 100%, 50%)`);
                                gradient.addColorStop(1, `hsl(${(hue + 240) % 360}, 100%, 50%)`);
                                ctx.fillStyle = gradient;
                            }
                            
                            ctx.fillText(this.text, 0, -20);
                            
                            // Tier indicator
                            ctx.font = 'bold 16px Courier New';
                            ctx.fillStyle = '#ffff00';
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = '#ffff00';
                            ctx.fillText(this.tier, 0, -50);
                            
                            // Effect description
                            ctx.font = 'bold 18px Courier New';
                            ctx.fillStyle = '#ffffff';
                            ctx.shadowBlur = 15;
                            ctx.shadowColor = this.color;
                            ctx.fillText(this.subtitle, 0, 25);
                            
                            ctx.restore();
                        }
                    });
                }
                
                if (soundSystem) {
                    const tier = comboData.tier || 1;
                    if (tier >= 3) {
                        soundSystem.playVoiceSample('GODLIKE');
                    } else if (tier >= 2) {
                        soundSystem.playVoiceSample('RADICAL');
                    } else {
                        soundSystem.playVoiceSample('EXCELLENT');
                    }
                    soundSystem.playPowerUp();
                }
                
                console.log(`🔥 TIER ${comboData.tier || 1} COMBO ACTIVATED: ${comboData.name} - ${comboData.effect}`);
            }
            
            applyPowerUpEffect(type) {
                if (!this.player) return;
                
                const powerUp = this.activePowerUps.get(type);
                const stacks = powerUp ? powerUp.stacks : 1;
                const synergy = powerUp ? powerUp.synergy : 1.0;
                const effectMultiplier = stacks * synergy;
                
                switch(type) {
                    // Classic power-ups
                    case 'weapon':
                        this.player.weaponLevel = Math.min(5, this.player.weaponLevel + stacks);
                        break;
                    case 'shield':
                        this.player.shield = Math.min(5, this.player.shield + (2 * stacks));
                        this.player.shieldActive = true;
                        break;
                    case 'bomb':
                        gameState.bombs = Math.min(9, gameState.bombs + stacks);
                        break;
                    case 'rapid':
                        this.player.fireRate = Math.max(2, this.player.fireRate - (stacks * synergy));
                        break;
                    case 'health':
                        gameState.lives = Math.min(7, gameState.lives + stacks);
                        break;
                        
                    // Weapon Enhancement
                    case 'laser':
                        this.player.hasLaser = true;
                        this.player.laserPower = Math.floor(stacks * synergy);
                        break;
                    case 'homing':
                        this.player.hasHoming = true;
                        this.player.homingStrength = Math.floor(stacks * synergy);
                        break;
                    case 'spread':
                        this.player.hasSpread = true;
                        this.player.spreadCount = 2 + Math.floor(stacks * synergy);
                        break;
                    case 'pierce':
                        this.player.hasPierce = true;
                        this.player.pierceCount = Math.floor((stacks + 1) * synergy);
                        break;
                    case 'bounce':
                        this.player.hasBounce = true;
                        this.player.bounceCount = Math.floor(2 + (stacks * synergy));
                        break;
                    case 'chain':
                        this.player.hasChain = true;
                        this.player.chainRange = Math.floor(80 + (stacks * 20 * synergy));
                        break;
                        
                    // Tactical Systems
                    case 'time':
                        gameState.slowMotion = Math.max(gameState.slowMotion, 
                            Math.floor(120 * effectMultiplier));
                        break;
                    case 'magnet':
                        this.player.magnetRange = Math.floor(100 + (stacks * 40 * synergy));
                        break;
                    case 'ghost':
                        this.player.ghostMode = Math.floor(300 + (stacks * 120 * synergy));
                        this.player.invulnerable = true;
                        break;
                    case 'double':
                        this.player.mirrorShip = Math.floor(400 + (stacks * 150 * synergy));
                        break;
                    case 'nova':
                        this.player.novaReady = true;
                        this.player.novaPower = Math.floor(stacks * synergy);
                        break;
                    case 'freeze':
                        this.player.freezePower = Math.floor(180 + (stacks * 60 * synergy));
                        this.freezeAllEnemies();
                        break;
                    case 'reflect':
                        this.player.reflectActive = Math.floor(240 + (stacks * 80 * synergy));
                        break;
                        
                    // Advanced Systems
                    case 'vortex':
                        this.player.vortexActive = Math.floor(350 + (stacks * 120 * synergy));
                        this.player.vortexPower = Math.floor(stacks * synergy);
                        break;
                    case 'quantum':
                        this.player.quantumMode = Math.floor(300 + (stacks * 100 * synergy));
                        this.player.quantumShots = Math.floor(3 + (stacks * 2 * synergy));
                        break;
                    case 'plasma':
                        this.player.plasmaMode = Math.floor(400 + (stacks * 150 * synergy));
                        this.player.fireRate = Math.max(1, Math.floor(this.player.fireRate / (1 + synergy)));
                        break;
                    case 'matrix':
                        this.player.matrixMode = Math.floor(280 + (stacks * 100 * synergy));
                        gameState.slowMotion = Math.max(gameState.slowMotion, 
                            Math.floor(300 * effectMultiplier));
                        break;
                        
                    // Ultimate Power
                    case 'omega':
                        this.player.omegaMode = Math.floor(600 + (stacks * 200 * synergy));
                        this.player.invulnerable = true;
                        break;
                    case 'fever':
                        this.player.feverMode = Math.floor(360 + (stacks * 120 * synergy));
                        this.player.invulnerable = true;
                        this.activateFeverMode();
                        break;
                    case 'infinity':
                        this.player.infinityMode = Math.floor(500 + (stacks * 180 * synergy));
                        this.player.infinitePower = true;
                        break;
                    case 'godmode':
                        this.player.godMode = Math.floor(800 + (stacks * 300 * synergy));
                        this.player.invulnerable = true;
                        this.player.infinitePower = true;
                        this.player.speed *= (1 + synergy * 0.5);
                        break;
                }
                
                console.log(`✨ Applied ${type.toUpperCase()}: Stacks=${stacks}, Synergy=${synergy.toFixed(1)}x`);
            }
            
            freezeAllEnemies() {
                if (gameState && gameState.enemies) {
                    gameState.enemies.forEach(enemy => {
                        if (enemy.active) {
                            enemy.frozen = true;
                            enemy.frozenTimer = this.player.freezePower || 180;
                            enemy.originalSpeed = enemy.speed;
                            enemy.speed = 0;
                            
                            // Ice effect particles
                            if (particleSystem) {
                                for (let i = 0; i < 15; i++) {
                                    const angle = (Math.PI * 2 * i) / 15;
                                    particleSystem.particles.push({
                                        x: enemy.x,
                                        y: enemy.y,
                                        vx: Math.cos(angle) * 3,
                                        vy: Math.sin(angle) * 3,
                                        color: '#80aaff',
                                        life: 40,
                                        maxLife: 40,
                                        size: 2,
                                        active: true,
                                        update() {
                                            this.x += this.vx;
                                            this.y += this.vy;
                                            this.vx *= 0.95;
                                            this.vy *= 0.95;
                                            this.life--;
                                            if (this.life <= 0) this.active = false;
                                        },
                                        draw(ctx) {
                                            const alpha = this.life / this.maxLife;
                                            ctx.save();
                                            ctx.globalAlpha = alpha;
                                            ctx.fillStyle = this.color;
                                            ctx.shadowBlur = 10;
                                            ctx.shadowColor = this.color;
                                            ctx.beginPath();
                                            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                            ctx.fill();
                                            ctx.restore();
                                        }
                                    });
                                }
                            }
                        }
                    });
                }
            }
            
            activateFeverMode() {
                // Enhanced fever mode with more effects
                if (gameState && gameState.enemies) {
                    gameState.enemies.forEach(e => {
                        e.behavior = 'flee';
                        e.points *= 3; // Increased from 2
                        e.color = '#ffffff';
                        e.speed *= 0.5; // Slow them down
                    });
                }
                
                // Rainbow explosion effect
                if (particleSystem) {
                    for (let i = 0; i < 100; i++) { // Increased particles
                        const angle = (Math.PI * 2 * i) / 100;
                        const speed = Math.random() * 15 + 8;
                        particleSystem.particles.push({
                            x: gameState.player.x,
                            y: gameState.player.y,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            color: `hsl(${i * 3.6}, 100%, 50%)`,
                            life: 80,
                            maxLife: 80,
                            size: Math.random() * 6 + 3,
                            active: true,
                            update() {
                                this.x += this.vx;
                                this.y += this.vy;
                                this.vx *= 0.94;
                                this.vy *= 0.94;
                                this.life--;
                                if (this.life <= 0) this.active = false;
                            },
                            draw(ctx) {
                                const alpha = this.life / this.maxLife;
                                ctx.save();
                                ctx.globalAlpha = alpha;
                                ctx.fillStyle = this.color;
                                ctx.shadowBlur = 25;
                                ctx.shadowColor = this.color;
                                ctx.beginPath();
                                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.restore();
                            }
                        });
                    }
                }
            }
            
            update() {
                // Update active power-ups
                for (let [type, powerUp] of this.activePowerUps) {
                    powerUp.duration--;
                    powerUp.timer++;
                    
                    if (powerUp.duration <= 0) {
                        this.removePowerUp(type);
                    }
                }
                
                // Update combo effects
                this.comboEffects = this.comboEffects.filter(effect => {
                    effect.duration--;
                    effect.timer++;
                    
                    if (effect.duration <= 0) {
                        console.log(`⏰ Combo expired: ${effect.name}`);
                        return false;
                    }
                    return true;
                });
            }
            
            removePowerUp(type) {
                this.activePowerUps.delete(type);
                
                // Remove power-up effects from player
                if (this.player) {
                    switch(type) {
                        case 'laser':
                            this.player.hasLaser = false;
                            break;
                        case 'homing':
                            this.player.hasHoming = false;
                            break;
                        case 'spread':
                            this.player.hasSpread = false;
                            break;
                        case 'pierce':
                            this.player.hasPierce = false;
                            break;
                        case 'magnet':
                            this.player.magnetRange = 0;
                            break;
                        case 'ghost':
                            this.player.ghostMode = 0;
                            break;
                        case 'double':
                            this.player.mirrorShip = 0;
                            break;
                        case 'nova':
                            this.player.novaReady = false;
                            break;
                        case 'vortex':
                            this.player.vortexActive = 0;
                            break;
                        case 'omega':
                            this.player.omegaMode = 0;
                            break;
                    }
                }
                
                console.log(`💨 Power-up expired: ${type.toUpperCase()}`);
            }
            
            getActiveEffects() {
                return {
                    powerUps: this.activePowerUps,
                    combos: this.comboEffects
                };
            }
            
            drawUI(ctx) {
                if (!gameState || attractMode) return;
                
                const effects = this.getActiveEffects();
                let yOffset = 140;
                
                // Draw active power-ups with enhanced visuals
                let index = 0;
                for (let [type, data] of effects.powerUps) {
                    const x = 20 + (index * 45);
                    const alpha = data.duration < 60 ? (data.duration / 60) : 1;
                    const pulse = Math.sin(Date.now() * 0.01) * 0.2 + 0.8;
                    
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.translate(x, yOffset);
                    
                    // Power-up icon background with rarity color
                    const rarityColors = {
                        'common': '#888888',
                        'uncommon': '#00ff00',
                        'rare': '#0088ff',
                        'epic': '#8800ff',
                        'legendary': '#ffaa00'
                    };
                    
                    // Get power-up data to determine rarity
                    const powerUpData = {
                        weapon: 'common', shield: 'common', bomb: 'common', rapid: 'common', health: 'common',
                        laser: 'uncommon', homing: 'uncommon', spread: 'uncommon', pierce: 'uncommon', 
                        bounce: 'uncommon', chain: 'uncommon',
                        time: 'rare', magnet: 'rare', ghost: 'rare', double: 'rare', nova: 'rare', 
                        freeze: 'rare', reflect: 'rare',
                        vortex: 'epic', quantum: 'epic', plasma: 'epic', matrix: 'epic',
                        omega: 'legendary', fever: 'legendary', infinity: 'legendary', godmode: 'legendary'
                    };
                    
                    const rarity = powerUpData[type] || 'common';
                    const rarityColor = rarityColors[rarity];
                    
                    // Animated border for rare+ items
                    if (rarity !== 'common') {
                        ctx.shadowBlur = 15 * pulse;
                        ctx.shadowColor = rarityColor;
                        ctx.strokeStyle = rarityColor;
                        ctx.lineWidth = 2;
                        ctx.strokeRect(-15, -15, 30, 30);
                    }
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.fillRect(-12, -12, 24, 24);
                    
                    // Power-up symbol
                    ctx.fillStyle = rarityColor;
                    ctx.font = 'bold 14px Courier New';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = rarityColor;
                    ctx.fillText(type.charAt(0).toUpperCase(), 0, 0);
                    
                    // Stack indicator
                    if (data.stacks > 1) {
                        ctx.fillStyle = '#ffff00';
                        ctx.font = 'bold 10px Courier New';
                        ctx.shadowBlur = 5;
                        ctx.shadowColor = '#ffff00';
                        ctx.fillText(data.stacks.toString(), 8, -8);
                    }
                    
                    // Synergy indicator
                    if (data.synergy > 1) {
                        ctx.fillStyle = '#ff00ff';
                        ctx.font = 'bold 8px Courier New';
                        ctx.shadowBlur = 5;
                        ctx.shadowColor = '#ff00ff';
                        ctx.fillText('⚡', -8, 8);
                    }
                    
                    // Duration bar
                    const barWidth = 20;
                    const barHeight = 2;
                    const durationPercent = data.duration / 600; // Assuming base 600 duration
                    
                    ctx.fillStyle = durationPercent > 0.3 ? '#00ff00' : 
                                   durationPercent > 0.1 ? '#ffff00' : '#ff0000';
                    ctx.fillRect(-barWidth/2, 15, barWidth * durationPercent, barHeight);
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(-barWidth/2, 15, barWidth, barHeight);
                    
                    ctx.restore();
                    index++;
                }
                
                // Draw active combos with tier indicators
                effects.combos.forEach((combo, i) => {
                    const alpha = combo.duration < 60 ? (combo.duration / 60) : 1;
                    const comboY = yOffset + 40 + (i * 25);
                    
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    
                    // Tier background
                    const tierColors = {
                        1: '#00ff00',
                        2: '#ffaa00', 
                        3: '#ff0000'
                    };
                    const tierColor = tierColors[combo.tier || 1];
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(15, comboY - 10, 250, 20);
                    
                    ctx.strokeStyle = tierColor;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = tierColor;
                    ctx.strokeRect(15, comboY - 10, 250, 20);
                    
                    // Combo text
                    ctx.fillStyle = combo.color;
                    ctx.font = 'bold 14px Courier New';
                    ctx.textAlign = 'left';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = combo.color;
                    
                    const tierText = combo.tier ? `[T${combo.tier}] ` : '';
                    ctx.fillText(`${tierText}⚡ ${combo.name}`, 20, comboY + 2);
                    
                    // Duration bar
                    const comboDurationPercent = combo.duration / (combo.tier === 3 ? 800 : combo.tier === 2 ? 500 : 300);
                    ctx.fillStyle = comboDurationPercent > 0.3 ? tierColor : '#ff0000';
                    ctx.globalAlpha = alpha * 0.8;
                    ctx.fillRect(20, comboY + 8, 240 * comboDurationPercent, 2);
                    
                    ctx.restore();
                });
                
                // Power-up collection tips
                if (effects.powerUps.size === 0 && effects.combos.length === 0) {
                    ctx.save();
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.font = 'bold 12px Courier New';
                    ctx.textAlign = 'left';
                    ctx.fillText('💎 COLLECT POWER-UPS TO UNLOCK COMBINATIONS', 20, yOffset + 20);
                    ctx.fillText('🔗 COMBINE DIFFERENT TYPES FOR SYNERGY BONUSES', 20, yOffset + 35);
                    ctx.restore();
                }
            }
        }

        // Attract Mode AI
        class AttractModeAI {
            constructor() {
                this.targetEnemy = null;
                this.dodgeDirection = 0;
                this.shootCooldown = 0;
            }
            
            update(player, enemies, enemyBullets) {
                if (!player) return;
                
                this.targetEnemy = null;
                let closestDist = Infinity;
                
                enemies.forEach(enemy => {
                    if (enemy.active) {
                        const dist = Math.hypot(enemy.x - player.x, enemy.y - player.y);
                        if (dist < closestDist) {
                            closestDist = dist;
                            this.targetEnemy = enemy;
                        }
                    }
                });
                
                keys = {};
                
                let closestBullet = null;
                let bulletDist = Infinity;
                
                enemyBullets.forEach(bullet => {
                    if (bullet.active) {
                        const dist = Math.hypot(bullet.x - player.x, bullet.y - player.y);
                        if (dist < 100 && dist < bulletDist) {
                            bulletDist = dist;
                            closestBullet = bullet;
                        }
                    }
                });
                
                if (closestBullet) {
                    const bulletAngle = Math.atan2(closestBullet.vy, closestBullet.vx);
                    const dodgeAngle = bulletAngle + Math.PI / 2;
                    
                    if (Math.cos(dodgeAngle) > 0.3) keys['d'] = true;
                    else if (Math.cos(dodgeAngle) < -0.3) keys['a'] = true;
                    
                    if (Math.sin(dodgeAngle) > 0.3) keys['s'] = true;
                    else if (Math.sin(dodgeAngle) < -0.3) keys['w'] = true;
                } else if (this.targetEnemy) {
                    const dx = this.targetEnemy.x - player.x;
                    const dy = this.targetEnemy.y - player.y;
                    
                    if (Math.abs(dx) > 30) {
                        if (dx > 0) keys['d'] = true;
                        else keys['a'] = true;
                    }
                    
                    if (player.y > config.height * 0.6) {
                        keys['w'] = true;
                    } else if (player.y < 100 && dy > 0) {
                        keys['s'] = true;
                    }
                }
                
                this.shootCooldown--;
                if (this.targetEnemy && closestDist < 300 && this.shootCooldown <= 0) {
                    keys[' '] = true;
                    this.shootCooldown = 10;
                } else {
                    keys[' '] = false;
                }
            }
        }

        // Get high scores from localStorage with better error handling
        function getHighScores() {
            try {
                // Check if localStorage is available
                if (typeof Storage === "undefined" || !localStorage) {
                    console.warn('localStorage not available, using default scores');
                    return getDefaultHighScores();
                }
                
                const scores = localStorage.getItem('geometryHighScores');
                if (scores) {
                    const parsedScores = JSON.parse(scores);
                    // Validate the data structure and sort properly
                    if (Array.isArray(parsedScores) && parsedScores.length > 0) {
                        // Ensure all entries have required properties
                        const validScores = parsedScores.filter(entry => 
                            entry && 
                            typeof entry.score === 'number' && 
                            typeof entry.initials === 'string' && 
                            entry.initials.length === 3
                        );
                        
                        // Ensure proper sorting (highest to lowest)
                        validScores.sort((a, b) => b.score - a.score);
                        return validScores.slice(0, 10); // Keep only top 10
                    }
                }
            } catch (error) {
                console.warn('Error loading high scores:', error);
            }
            
            return getDefaultHighScores();
        }
        
        function getDefaultHighScores() {
            return [
                { initials: 'ACE', score: 50000, wave: 5 },
                { initials: 'MAX', score: 40000, wave: 4 },
                { initials: 'ZAP', score: 30000, wave: 3 },
                { initials: 'NEO', score: 25000, wave: 3 },
                { initials: 'DOT', score: 20000, wave: 2 },
                { initials: 'BIT', score: 15000, wave: 2 },
                { initials: 'HEX', score: 10000, wave: 1 },
                { initials: 'CPU', score: 8000, wave: 1 },
                { initials: 'RAM', score: 5000, wave: 1 },
                { initials: 'ROM', score: 2000, wave: 1 }
            ];
        }
        
        function saveHighScores(scores) {
            try {
                // Check if localStorage is available
                if (typeof Storage === "undefined" || !localStorage) {
                    console.warn('localStorage not available, cannot save scores');
                    return false;
                }
                
                // Validate scores before saving
                if (!Array.isArray(scores)) {
                    console.warn('Invalid scores array, cannot save');
                    return false;
                }
                
                // Filter and validate each score entry
                const validScores = scores.filter(entry => 
                    entry && 
                    typeof entry.score === 'number' && 
                    typeof entry.initials === 'string' && 
                    entry.initials.length === 3 &&
                    entry.score >= 0
                ).slice(0, 10); // Ensure only top 10
                
                // Sort before saving
                validScores.sort((a, b) => b.score - a.score);
                
                localStorage.setItem('geometryHighScores', JSON.stringify(validScores));
                console.log('✅ High scores saved successfully:', validScores);
                return true;
            } catch (error) {
                console.warn('Error saving high scores:', error);
                return false;
            }
        }
        
        function isHighScore(score) {
            if (typeof score !== 'number' || score <= 0) return false;
            
            const highScores = getHighScores();
            if (!highScores || highScores.length === 0) return true;
            
            // Check if score is higher than the lowest high score
            // or if we have less than 10 entries
            return highScores.length < 10 || score > highScores[highScores.length - 1].score;
        }
        
        function getHighScorePosition(score) {
            if (typeof score !== 'number') return -1;
            
            const highScores = getHighScores();
            for (let i = 0; i < highScores.length; i++) {
                if (score > highScores[i].score) {
                    return i;
                }
            }
            return highScores.length < 10 ? highScores.length : -1;
        }

        // Game Functions
        window.startGame = function() {
            if (credits <= 0) {
                const insertCoinEl = document.getElementById('insertCoinText');
                insertCoinEl.style.color = '#ff0000';
                insertCoinEl.style.animation = 'blink 0.2s ease-in-out 6';
                setTimeout(() => {
                    insertCoinEl.style.color = '#ffff00';
                    insertCoinEl.style.animation = 'blink 1s ease-in-out infinite';
                }, 1200);
                return;
            }
            
            credits--;
            updateCreditsDisplay();
            
            if (musicEnabled && menuMusic && gameMusic) {
                try {
                    menuMusic.pause();
                    menuMusic.currentTime = 0;
                    gameMusic.play().catch(err => console.warn("Game music play failed:", err));
                } catch (error) {
                    console.warn("Music control failed:", error);
                }
            }
            
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            document.getElementById('menuScreen').style.display = 'none';
            document.getElementById('gameUI').style.display = 'block';
            
            keys = {};
            
            bulletPool = new BulletPool();
            enemyBulletPool = new BulletPool();
            particleSystem = new ParticleSystem();
            soundSystem = new SoundSystem();
            waveManager = new WaveManager();
            
            // 🎬 VISUAL EFFECTS SHOULD ALREADY BE INITIALIZED
            // Just reset epic explosions array for new game
            epic80sExplosions = [];
            
            // 🌟 ENSURE STARFIELD IS READY FOR GAME
            if (!starfield) {
                try {
                    starfield = new Starfield();
                    console.log('⭐ Starfield created for game session');
                } catch (error) {
                    console.warn('Failed to create starfield for game:', error);
                }
            } else {
                // Reset starfield for new game
                starfield.resize(config.width, config.height);
                console.log('⭐ Starfield reset for new game');
            }
            
            starfield = new Starfield();
            formationManager = new FormationManager();
            ufoManager = new UFOManager();
            bonusRound = null;
            
            gameState = {
                running: true,
                paused: false,
                score: 0,
                lastScoreIncrease: 0,
                lives: 3,
                bombs: 3,
                wave: 1,
                combo: 0,
                maxCombo: 0,
                comboTimer: 0,
                comboTimeout: 180,
                enemies: [],
                particles: [],
                powerUps: [],
                boss: null,
                player: new Player(config.width / 2, config.height - 100),
                powerUpManager: null, // Will be initialized when first power-up is collected
                radicalSlang: new RadicalSlang(),
                screenShake: { x: 0, y: 0, intensity: 0, duration: 0 },
                slowMotion: 0,
                promoTexts: null,
                currentPromoIndex: 0,
                promoTimer: 0,
                themeChangeTimer: 120 // Show initial theme
            };
            
            // Initialize PowerUpManager for the player
            gameState.powerUpManager = new PowerUpManager(gameState.player);
            
            // 🎬 TRIGGER EPIC GAME START EFFECT
            if (vhsGlitch) {
                vhsGlitch.triggerGlitch(2);
            }
            
            updateUI();
            gameLoop();
            
            resetAttractModeTimeout();
        }
        
        window.gameOver = function() {
            if (!gameState) return;
            
            // 📺 VHS GLITCH ON GAME OVER!
            if (vhsGlitch) {
                vhsGlitch.triggerGlitch(2.5);
            }
            
            if (musicEnabled && gameMusic) {
                try {
                    gameMusic.pause();
                    gameMusic.currentTime = 0;
                } catch (error) {
                    console.warn("Music control failed:", error);
                }
            }
            
            gameState.paused = true;
            gameState.running = false;
            
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            // Add delay before showing continue screen
            setTimeout(() => {
                // Clear excess particles to free memory
                if (particleSystem && particleSystem.particles.length > 50) {
                    particleSystem.particles = particleSystem.particles.slice(0, 50);
                }
                
                if (typeof window.showContinueScreen === 'function') {
                    window.showContinueScreen();
                } else {
                    console.error('showContinueScreen function not found');
                }
            }, 500);
            
            keys = {};
            if (soundSystem) soundSystem.enabled = false;
            resetAttractModeTimeout();
        }
        
        window.showContinueScreen = function() {
            if (gameState) {
                const continueScoreEl = document.getElementById('continueScoreDisplay');
                if (continueScoreEl) {
                    continueScoreEl.textContent = gameState.score.toLocaleString();
                }
            }
            
            showingContinueScreen = true;
            continueTimer = maxContinueTime;
            const continueScreen = document.getElementById('continueScreen');
            const gameUI = document.getElementById('gameUI');
            
            if (continueScreen) continueScreen.style.display = 'flex';
            if (gameUI) gameUI.style.display = 'none';
            
            setTimeout(() => {
                if (soundSystem) {
                    soundSystem.playVoiceSample('GAME OVER');
                }
            }, 200);
            
            setTimeout(() => {
                if (soundSystem) {
                    soundSystem.playVoiceSample('CONTINUE');
                }
            }, 2000);
            
            // Optimized countdown (10fps instead of 60fps)
            const continueCountdown = setInterval(() => {
                continueTimer -= 6;
                const seconds = Math.ceil(continueTimer / 60);
                const timerEl = document.getElementById('continueTimerDisplay');
                
                if (timerEl) {
                    timerEl.textContent = seconds;
                    
                    if (seconds <= 3) {
                        timerEl.style.color = '#ff0000';
                        timerEl.style.animation = 'blink 0.2s ease-in-out infinite';
                    } else {
                        timerEl.style.color = '#ffff00';
                        timerEl.style.animation = 'none';
                    }
                }
                
                if (continueTimer <= 0 || !showingContinueScreen) {
                    clearInterval(continueCountdown);
                    if (showingContinueScreen) {
                        window.finalGameOver();
                    }
                }
            }, 100);
        }
        
        window.continueGame = function() {
            if (credits <= 0) return;
            
            credits--;
            updateCreditsDisplay();
            showingContinueScreen = false;
            
            const continueScreen = document.getElementById('continueScreen');
            if (continueScreen) {
                continueScreen.style.display = 'none';
            }
            
            if (gameState) {
                gameState.lives = 3;
                gameState.running = true;
                gameState.paused = false;
                if (gameState.player) {
                    gameState.player.invulnerable = true;
                    gameState.player.invulnerableTimer = 180;
                }
                
                if (enemyBulletPool) enemyBulletPool.clear();
                
                if (musicEnabled && gameMusic) {
                    try {
                        gameMusic.play().catch(err => console.warn("Continue music play failed:", err));
                    } catch (error) {
                        console.warn("Music control failed:", error);
                    }
                }
                
                const gameUI = document.getElementById('gameUI');
                if (gameUI) {
                    gameUI.style.display = 'block';
                }
                
                if (soundSystem) soundSystem.enabled = true;
                if (typeof gameLoop === 'function') gameLoop();
            }
            
            if (typeof updateUI === 'function') updateUI();
        }
        
        window.finalGameOver = function() {
            showingContinueScreen = false;
            const continueScreen = document.getElementById('continueScreen');
            if (continueScreen) {
                continueScreen.style.display = 'none';
            }
            
            if (gameState) {
                const finalScoreEl = document.getElementById('finalScoreDisplay');
                const finalWaveEl = document.getElementById('finalWaveDisplay'); 
                const finalComboEl = document.getElementById('finalComboDisplay');
                
                if (finalScoreEl) finalScoreEl.textContent = gameState.score.toLocaleString();
                if (finalWaveEl) finalWaveEl.textContent = gameState.wave;
                if (finalComboEl) finalComboEl.textContent = gameState.maxCombo;
                
                if (typeof isHighScore === 'function' && isHighScore(gameState.score)) {
                    if (typeof getHighScorePosition === 'function') {
                        newHighScoreIndex = getHighScorePosition(gameState.score);
                    }
                    if (typeof showHighScoreEntry === 'function') {
                        showHighScoreEntry();
                    }
                } else {
                    setTimeout(() => {
                        const gameOverScreen = document.getElementById('gameOverScreen');
                        const gameUI = document.getElementById('gameUI');
                        if (gameOverScreen) gameOverScreen.style.display = 'flex';
                        if (gameUI) gameUI.style.display = 'none';
                    }, 500);
                }
            }
        }
        
        window.restartGame = function() {
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            if (soundSystem) soundSystem.enabled = true;
            
            document.getElementById('gameOverScreen').style.display = 'none';
            startGame();
        }
        
        window.backToMenu = function() {
            if (musicEnabled && menuMusic && gameMusic) {
                try {
                    gameMusic.pause();
                    gameMusic.currentTime = 0;
                    menuMusic.play().catch(err => console.warn("Menu music play failed:", err));
                } catch (error) {
                    console.warn("Music control failed:", error);
                }
            }
            
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('menuScreen').style.display = 'flex';
            document.getElementById('gameUI').style.display = 'none';
            
            setTimeout(() => {
                if (soundSystem) {
                    soundSystem.playVoiceSample('GET READY');
                }
            }, 1000);
            
            if (gameState) {
                gameState.running = false;
                gameState = null;
            }
            
            if (bulletPool) bulletPool.clear();
            if (enemyBulletPool) enemyBulletPool.clear();
            
            keys = {};
            
            if (bossDeathTimeoutId) {
                clearTimeout(bossDeathTimeoutId);
                bossDeathTimeoutId = null;
            }
            
            resetAttractModeTimeout();
        }
        
        window.showHighScoreEntry = function() {
            document.getElementById('newHighScoreValue').textContent = gameState.score.toLocaleString();
            document.getElementById('highScoreEntryScreen').style.display = 'flex';
            document.getElementById('gameUI').style.display = 'none';
            
            document.getElementById('initial1').value = '';
            document.getElementById('initial2').value = '';
            document.getElementById('initial3').value = '';
            
            setupInitialInputs();
            
            setTimeout(() => {
                const firstInput = document.getElementById('initial1');
                firstInput.focus();
                firstInput.select();
                console.log('🏆 High score entry ready - type your initials!');
            }, 200);
        }
        
        function setupInitialInputs() {
            const inputs = ['initial1', 'initial2', 'initial3'];
            
            inputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                const newInput = input.cloneNode(true);
                input.parentNode.replaceChild(newInput, input);
            });
            
            inputs.forEach((inputId, index) => {
                const input = document.getElementById(inputId);
                input.value = '';
                input.maxLength = 1;
                
                input.addEventListener('input', function(e) {
                    console.log('🏆 Input detected:', e.target.value);
                    
                    let value = e.target.value.toUpperCase().replace(/[^A-Z]/g, '');
                    e.target.value = value;
                    
                    if (value.length === 1 && index < 2) {
                        const nextInput = document.getElementById(inputs[index + 1]);
                        setTimeout(() => {
                            nextInput.focus();
                            nextInput.select();
                        }, 50);
                    }
                });
                
                input.addEventListener('keydown', function(e) {
                    console.log('🏆 Key pressed:', e.key);
                    
                    if (e.key === 'Backspace' && e.target.value === '' && index > 0) {
                        const prevInput = document.getElementById(inputs[index - 1]);
                        setTimeout(() => {
                            prevInput.focus();
                            prevInput.select();
                        }, 50);
                    } else if (e.key === 'Enter') {
                        e.preventDefault();
                        submitHighScore();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        skipHighScore();
                    } else if (e.key === 'ArrowLeft' && index > 0) {
                        e.preventDefault();
                        document.getElementById(inputs[index - 1]).focus();
                    } else if (e.key === 'ArrowRight' && index < 2) {
                        e.preventDefault();
                        document.getElementById(inputs[index + 1]).focus();
                    }
                });
                
                input.addEventListener('focus', function(e) {
                    e.target.select();
                });
            });
            
            console.log('🏆 Initial inputs setup complete');
        }
        
        window.submitHighScore = function() {
            console.log('🏆 Attempting to submit high score...');
            
            // Get and validate initials
            const initial1 = (document.getElementById('initial1').value || 'A').toUpperCase().substring(0, 1);
            const initial2 = (document.getElementById('initial2').value || 'A').toUpperCase().substring(0, 1);
            const initial3 = (document.getElementById('initial3').value || 'A').toUpperCase().substring(0, 1);
            const initials = initial1 + initial2 + initial3;
            
            // Validate score
            if (!gameState || typeof gameState.score !== 'number' || gameState.score <= 0) {
                console.error('❌ Invalid game state or score');
                skipHighScore();
                return;
            }
            
            const highScores = getHighScores();
            const newEntry = {
                initials: initials,
                score: gameState.score,
                wave: gameState.wave || 1
            };
            
            console.log('🏆 New entry:', newEntry);
            console.log('🏆 Current high scores:', highScores);
            
            // Find correct position and insert
            let insertPosition = highScores.length; // Default to end
            for (let i = 0; i < highScores.length; i++) {
                if (gameState.score > highScores[i].score) {
                    insertPosition = i;
                    break;
                }
            }
            
            // Insert the new entry
            highScores.splice(insertPosition, 0, newEntry);
            
            // Keep only top 10 and ensure proper sorting
            highScores.sort((a, b) => b.score - a.score);
            highScores.splice(10);
            
            // Update the global position for highlighting
            newHighScoreIndex = Math.min(insertPosition, 9);
            
            console.log('🏆 Updated high scores:', highScores);
            console.log('🏆 New entry position:', newHighScoreIndex);
            
            if (saveHighScores(highScores)) {
                console.log('✅ High score saved successfully!');
            } else {
                console.warn('⚠️ Failed to save high score');
            }
            
            document.getElementById('highScoreEntryScreen').style.display = 'none';
            showHighScoreList();
        }
        
        function skipHighScore() {
            document.getElementById('highScoreEntryScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'flex';
        }
        
        window.showHighScoreList = function() {
            if (attractMode) {
                highScoreFromAttractMode = true;
            }
            
            const highScores = getHighScores();
            const listElement = document.getElementById('highScoreList');
            
            let html = '<div style="display: flex; justify-content: space-between; width: 500px; margin-bottom: 20px; padding: 10px 20px; border-bottom: 2px solid #00ffff; font-weight: 900; color: #ffff00;">';
            html += '<div class="rank">RANK</div>';
            html += '<div class="initials">NAME</div>';
            html += '<div class="score">SCORE</div>';
            html += '</div>';
            
            highScores.forEach((entry, index) => {
                const isNewEntry = (index === newHighScoreIndex);
                const entryClass = isNewEntry ? 'high-score-entry new-entry' : 'high-score-entry';
                
                html += `<div class="${entryClass}">`;
                html += `<div class="rank">${String(index + 1).padStart(2, '0')}.</div>`;
                html += `<div class="initials">${entry.initials}</div>`;
                html += `<div class="score">${entry.score.toLocaleString()}</div>`;
                html += '</div>';
            });
            
            listElement.innerHTML = html;
            document.getElementById('highScoreListScreen').style.display = 'flex';
            document.getElementById('gameUI').style.display = 'none';
            
            if (highScoreFromAttractMode) {
                setTimeout(() => {
                    if (document.getElementById('highScoreListScreen').style.display === 'flex') {
                        closeHighScores();
                    }
                }, 5000);
            }
        }
        
        window.closeHighScores = function() {
            document.getElementById('highScoreListScreen').style.display = 'none';
            
            if (highScoreFromAttractMode) {
                highScoreFromAttractMode = false;
                attractMode = false;
                attractModeAI = null;
                document.getElementById('menuScreen').style.display = 'flex';
                document.getElementById('gameUI').style.display = 'none';
                resetAttractModeTimeout();
                return;
            }
            
            if (newHighScoreIndex >= 0) {
                document.getElementById('gameOverScreen').style.display = 'flex';
                newHighScoreIndex = -1;
            } else {
                backToMenu();
            }
        }
        
        function updateCreditsDisplay() {
            const creditsEl = document.getElementById('creditsCount');
            if (creditsEl) {
                creditsEl.textContent = credits;
                
                const startBtn = document.getElementById('startGameBtn');
                if (startBtn) {
                    if (credits > 0) {
                        startBtn.style.opacity = '1';
                        startBtn.style.pointerEvents = 'auto';
                    } else {
                        startBtn.style.opacity = '0.5';
                        startBtn.style.pointerEvents = 'none';
                    }
                }
            }
        }
        
        function insertCoin() {
            credits++;
            updateCreditsDisplay();
            
            if (soundSystem) {
                soundSystem.playCoinDrop();
            }
            
            const insertCoinEl = document.getElementById('insertCoinText');
            if (insertCoinEl) {
                const originalText = insertCoinEl.textContent;
                insertCoinEl.textContent = 'THANK YOU';
                insertCoinEl.style.color = '#00ff00';
                insertCoinEl.style.animation = 'none';
                
                setTimeout(() => {
                    insertCoinEl.textContent = originalText;
                    insertCoinEl.style.color = '#ffff00';
                    insertCoinEl.style.animation = 'blink 1s ease-in-out infinite';
                }, 1500);
            }
            
            if (showingContinueScreen && credits > 0) {
                continueGame();
            }
            
            if (typeof resetAttractModeTimeout === 'function') {
                resetAttractModeTimeout();
            }
        }
        
        function updateUI() {
            if (!gameState) return;
            
            // Extra life system - every 300,000 points (rarer bonus)
            const oldLifeThreshold = Math.floor((gameState.lastScoreIncrease || 0) / 300000);
            const newLifeThreshold = Math.floor(gameState.score / 300000);
            
            if (newLifeThreshold > oldLifeThreshold && gameState.lives < 5) {
                gameState.lives++;
                console.log(`🎯 Extra life earned! Score: ${gameState.score}, Lives: ${gameState.lives}`);
                
                if (soundSystem) {
                    setTimeout(() => soundSystem.playVoiceSample('EXCELLENT'), 300);
                }
                
                if (particleSystem) {
                    for (let i = 0; i < 50; i++) {
                        const angle = (Math.PI * 2 * i) / 50;
                        particleSystem.particles.push({
                            x: config.width / 2,
                            y: config.height / 2,
                            vx: Math.cos(angle) * 10,
                            vy: Math.sin(angle) * 10,
                            color: `hsl(${i * 7}, 100%, 50%)`,
                            life: 60,
                            maxLife: 60,
                            size: 4,
                            active: true,
                            update() {
                                this.x += this.vx;
                                this.y += this.vy;
                                this.vx *= 0.95;
                                this.vy *= 0.95;
                                this.life--;
                                if (this.life <= 0) this.active = false;
                            },
                            draw(ctx) {
                                const alpha = this.life / this.maxLife;
                                ctx.save();
                                ctx.globalAlpha = alpha;
                                ctx.fillStyle = this.color;
                                ctx.shadowBlur = 20;
                                ctx.shadowColor = this.color;
                                ctx.beginPath();
                                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.restore();
                            }
                        });
                    }
                }
                if (soundSystem) soundSystem.playPowerUp();
            }
            
            gameState.lastScoreIncrease = gameState.score;
            
            // Update UI elements
            const scoreElement = document.getElementById('scoreDisplay');
            const waveElement = document.getElementById('waveDisplay');
            const livesElement = document.getElementById('livesDisplay');
            const bombsElement = document.getElementById('bombsDisplay');
            
            if (scoreElement) scoreElement.textContent = gameState.score.toLocaleString();
            if (waveElement) waveElement.textContent = gameState.wave;
            if (livesElement) livesElement.textContent = gameState.lives;
            if (bombsElement) bombsElement.textContent = gameState.bombs;
            
            // Update high score display
            const highScores = getHighScores();
            const topScore = highScores.length > 0 ? highScores[0].score : 0;
            const highScoreElement = document.getElementById('highScoreDisplay');
            if (highScoreElement) {
                highScoreElement.textContent = topScore.toLocaleString();
            }
            
            console.log(`📊 UI Updated - Score: ${gameState.score}, Lives: ${gameState.lives}, Wave: ${gameState.wave}`);
        }

        // Collision Detection
        function checkCollisions() {
            if (!gameState || !gameState.player) return;
            
            bulletPool.getActiveBullets().forEach(bullet => {
                if (bullet.isPlayerBullet && bullet.active) {
                    // Check UFO collisions
                    if (ufoManager && ufoManager.ufos) {
                        ufoManager.ufos.forEach(ufo => {
                            if (ufo && ufo.active) {
                                const dist = Math.hypot(
                                    bullet.x - ufo.x,
                                    bullet.y - ufo.y
                                );
                                
                                if (dist < ufo.size) {
                                    bullet.active = false;
                                    const damage = bullet.damage || 1;
                                    ufo.takeDamage(damage);
                                    
                                    if (!ufo.active) {
                                        // UFO gives huge score bonus!
                                        let ufoScore = ufo.points;
                                        gameState.score += ufoScore;
                                        
                                        console.log(`🛸 UFO destroyed! Score: ${ufoScore}, Total Score: ${gameState.score}`);
                                        
                                        // 🎆 EPIC UFO EXPLOSION!
                                        epic80sExplosions.push(new Epic80sExplosion(ufo.x, ufo.y, 2.0));
                                        
                                        if (particleSystem) {
                                            for (let i = 0; i < 40; i++) {
                                                const angle = (Math.PI * 2 * i) / 40;
                                                const speed = Math.random() * 15 + 5;
                                                particleSystem.particles.push({
                                                    x: ufo.x,
                                                    y: ufo.y,
                                                    vx: Math.cos(angle) * speed,
                                                    vy: Math.sin(angle) * speed,
                                                    color: i % 3 === 0 ? ufo.color : (i % 3 === 1 ? '#ffffff' : '#ffff00'),
                                                    life: 80,
                                                    maxLife: 80,
                                                    size: Math.random() * 6 + 3,
                                                    active: true,
                                                    type: 'ufo_debris',
                                                    rotation: Math.random() * Math.PI * 2,
                                                    rotationSpeed: (Math.random() - 0.5) * 0.2,
                                                    update() {
                                                        this.x += this.vx;
                                                        this.y += this.vy;
                                                        this.vx *= 0.96;
                                                        this.vy *= 0.96;
                                                        this.rotation += this.rotationSpeed;
                                                        this.life--;
                                                        if (this.life <= 0) this.active = false;
                                                    },
                                                    draw(ctx) {
                                                        const alpha = this.life / this.maxLife;
                                                        ctx.save();
                                                        ctx.translate(this.x, this.y);
                                                        ctx.rotate(this.rotation);
                                                        ctx.globalAlpha = alpha;
                                                        ctx.fillStyle = this.color;
                                                        ctx.shadowBlur = 20;
                                                        ctx.shadowColor = this.color;
                                                        ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
                                                        ctx.restore();
                                                    }
                                                });
                                            }
                                        }
                                        
                                        const popup = new ScorePopup(
                                            ufo.x, 
                                            ufo.y, 
                                            ufoScore,
                                            ufo.color,
                                            true
                                        );
                                        gameState.particles.push(popup);
                                        
                                        if (gameState.screenShake) {
                                            gameState.screenShake.intensity = 20;
                                            gameState.screenShake.duration = 30;
                                        }
                                        
                                        if (soundSystem) {
                                            soundSystem.playUFODestroy();
                                            
                                            const ufoVoices = {
                                                'scout': 'EXCELLENT',
                                                'cruiser': 'OUTSTANDING', 
                                                'mothership': 'RADICAL'
                                            };
                                            
                                            setTimeout(() => {
                                                soundSystem.playVoiceSample(ufoVoices[ufo.type.type] || 'EXCELLENT');
                                            }, 200);
                                        }
                                    }
                                    
                                    updateUI();
                                }
                            }
                        });
                    }
                    
                    if (gameState.boss && gameState.boss.active) {
                        const dist = Math.hypot(
                            bullet.x - gameState.boss.x,
                            bullet.y - gameState.boss.y
                        );
                        
                        if (dist < gameState.boss.size) {
                            bullet.active = false;
                            if (gameState.boss && gameState.boss.takeDamage) {
                                gameState.boss.takeDamage(bullet.damage);
                            }
                            if (particleSystem) {
                                particleSystem.addExplosion(bullet.x, bullet.y, gameState.boss.color || '#ff00ff', 5);
                            }
                        }
                    }
                    
                    gameState.enemies.forEach(enemy => {
                        if (enemy && enemy.active && enemy.color) {
                            const dist = Math.hypot(
                                bullet.x - enemy.x,
                                bullet.y - enemy.y
                            );
                            
                            if (dist < enemy.size) {
                                bullet.active = false;
                                const damage = bullet.damage || 1;
                                enemy.takeDamage(damage);
                                
                                if (!enemy.active) {
                                    // Calculate score with combo multiplier
                                    let baseScore = enemy.points || 100;
                                    let comboMultiplier = Math.max(1, Math.floor(gameState.combo / 3));
                                    let scoreValue = baseScore * comboMultiplier;
                                    
                                    let finalScore = scoreValue;
                                    if (enemy.isFormationLeader && enemy.formationBonus) {
                                        finalScore += enemy.formationBonus;
                                        
                                        if (particleSystem) {
                                            for (let i = 0; i < 20; i++) {
                                                const angle = (Math.PI * 2 * i) / 20;
                                                particleSystem.particles.push({
                                                    x: enemy.x,
                                                    y: enemy.y,
                                                    vx: Math.cos(angle) * 8,
                                                    vy: Math.sin(angle) * 8,
                                                    color: '#ffff00',
                                                    life: 30,
                                                    maxLife: 30,
                                                    size: 3,
                                                    active: true,
                                                    update() {
                                                        this.x += this.vx;
                                                        this.y += this.vy;
                                                        this.vx *= 0.95;
                                                        this.vy *= 0.95;
                                                        this.life--;
                                                        if (this.life <= 0) this.active = false;
                                                    },
                                                    draw(ctx) {
                                                        const alpha = this.life / this.maxLife;
                                                        ctx.save();
                                                        ctx.globalAlpha = alpha;
                                                        ctx.fillStyle = this.color;
                                                        ctx.shadowBlur = 15;
                                                        ctx.shadowColor = this.color;
                                                        ctx.beginPath();
                                                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                                        ctx.fill();
                                                        ctx.restore();
                                                    }
                                                });
                                            }
                                        }
                                        
                                        setTimeout(() => {
                                            if (soundSystem) {
                                                soundSystem.playVoiceSample('EXCELLENT');
                                            }
                                        }, 100);
                                    }
                                    
                                    // Add score and increment combo
                                    gameState.score += finalScore;
                                    gameState.combo++;
                                    gameState.comboTimer = 0;
                                    
                                    console.log(`💥 Enemy killed! Base: ${baseScore}, Combo: ${comboMultiplier}x, Final: ${finalScore}, Total Score: ${gameState.score}`);
                                    
                                    const popup = new ScorePopup(
                                        enemy.x, 
                                        enemy.y, 
                                        finalScore,
                                        enemy.color || '#ffffff',
                                        gameState.combo > 5 || enemy.isFormationLeader
                                    );
                                    gameState.particles.push(popup);
                                    
                                    if (particleSystem) {
                                        particleSystem.addExplosion(enemy.x, enemy.y, enemy.color || '#ffffff', 20);
                                    }
                                    
                                    if (gameState.combo > gameState.maxCombo) {
                                        gameState.maxCombo = gameState.combo;
                                    }
                                    
                                    if (gameState.radicalSlang) {
                                        gameState.radicalSlang.trigger(gameState.combo);
                                    }
                                    
                                    if (soundSystem && gameState.combo > 2) {
                                        soundSystem.playCombo(Math.min(gameState.combo / 5, 10));
                                        
                                        if (gameState.combo >= 20) {
                                            setTimeout(() => soundSystem.playVoiceSample('RADICAL'), 200);
                                        } else if (gameState.combo >= 10) {
                                            setTimeout(() => soundSystem.playVoiceSample('EXCELLENT'), 200);
                                        } else if (gameState.combo >= 5 && gameState.combo % 5 === 0) {
                                            setTimeout(() => soundSystem.playVoiceSample('PERFECT'), 200);
                                        }
                                    }
                                    
                                    if (gameState.screenShake) {
                                        gameState.screenShake.intensity = 5 + Math.min(gameState.combo, 10);
                                        gameState.screenShake.duration = 10;
                                    }
                                    
                                    if (soundSystem) soundSystem.playExplosion();
                                    
                                    if (waveManager) waveManager.onEnemyKilled();
                                    
                                    // Enhanced power-up spawning with rarity system
                                    if (Math.random() < 0.25) { // Increased spawn rate
                                        let powerUpTypes = {
                                            common: ['weapon', 'shield', 'bomb', 'rapid', 'health'],
                                            uncommon: ['laser', 'homing', 'spread', 'pierce', 'bounce', 'chain'],
                                            rare: ['time', 'magnet', 'ghost', 'double', 'nova', 'freeze', 'reflect'],
                                            epic: ['vortex', 'quantum', 'plasma', 'matrix'],
                                            legendary: ['omega', 'fever', 'infinity', 'godmode']
                                        };
                                        
                                        let selectedType;
                                        const roll = Math.random();
                                        
                                        // Rarity chances (affected by wave number)
                                        const waveBonus = Math.min(gameState.wave * 0.02, 0.3);
                                        
                                        if (roll < 0.02 + waveBonus && gameState.wave >= 15) {
                                            // Legendary (2% + wave bonus, wave 15+)
                                            selectedType = powerUpTypes.legendary[Math.floor(Math.random() * powerUpTypes.legendary.length)];
                                        } else if (roll < 0.08 + waveBonus && gameState.wave >= 10) {
                                            // Epic (8% + wave bonus, wave 10+)
                                            selectedType = powerUpTypes.epic[Math.floor(Math.random() * powerUpTypes.epic.length)];
                                        } else if (roll < 0.20 + waveBonus && gameState.wave >= 5) {
                                            // Rare (20% + wave bonus, wave 5+)
                                            selectedType = powerUpTypes.rare[Math.floor(Math.random() * powerUpTypes.rare.length)];
                                        } else if (roll < 0.45 + waveBonus && gameState.wave >= 2) {
                                            // Uncommon (45% + wave bonus, wave 2+)
                                            selectedType = powerUpTypes.uncommon[Math.floor(Math.random() * powerUpTypes.uncommon.length)];
                                        } else {
                                            // Common (remaining %)
                                            selectedType = powerUpTypes.common[Math.floor(Math.random() * powerUpTypes.common.length)];
                                        }
                                        
                                        // Emergency health when low on lives
                                        // Emergency health when low on lives
                                        // Reduce drop rate to make extra lives rarer
                                        if (gameState.lives <= 1 && Math.random() < 0.2) {
                                            selectedType = 'health';
                                        }
                                        
                                        // Special fever chance during high combo
                                        if (gameState.combo >= 15 && Math.random() < 0.15) {
                                            selectedType = 'fever';
                                        }
                                        
                                        const powerUp = new PowerUp(enemy.x, enemy.y, selectedType);
                                        gameState.powerUps.push(powerUp);
                                        
                                        console.log(`💎 Power-up spawned: ${selectedType.toUpperCase()} (Rarity: ${powerUp.rarity})`);
                                    }
                                }
                                
                                updateUI();
                            }
                        }
                    });
                }
            });
            
            if (!gameState.player.invulnerable && gameState.player.feverMode <= 0 && gameState.player.isAlive) {
                enemyBulletPool.getActiveBullets().forEach(bullet => {
                    if (!bullet.isPlayerBullet && bullet.active) {
                        const dist = Math.hypot(
                            bullet.x - gameState.player.x,
                            bullet.y - gameState.player.y
                        );
                        
                        if (dist < gameState.player.size) {
                            bullet.active = false;
                            
                            if (gameState.player.takeDamage()) {
                                gameState.lives--;
                                gameState.combo = 0;
                                updateUI();
                                
                                // Clear enemy bullets after player death
                                if (enemyBulletPool) enemyBulletPool.clear();
                                
                                if (gameState.lives <= 0) {
                                    gameOver();
                                }
                            }
                        }
                    }
                });
            }
            
            if (!gameState.player.invulnerable && gameState.player.feverMode <= 0 && gameState.player.isAlive) {
                gameState.enemies.forEach(enemy => {
                    if (enemy && enemy.active && enemy.size && enemy.x !== undefined && enemy.y !== undefined) {
                        const dist = Math.hypot(
                            enemy.x - gameState.player.x,
                            enemy.y - gameState.player.y
                        );
                        
                        if (dist < enemy.size + gameState.player.size) {
                            if (gameState.player.takeDamage()) {
                                gameState.lives--;
                                enemy.active = false;
                                gameState.combo = 0;
                                updateUI();
                                
                                // Clear enemy bullets after player death
                                if (enemyBulletPool) enemyBulletPool.clear();
                                
                                if (gameState.lives <= 0) {
                                    gameOver();
                                } else {
                                    // Enemy collision explosion
                                    if (particleSystem && enemy.color) {
                                        particleSystem.addExplosion(enemy.x, enemy.y, enemy.color, 15);
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            gameState.powerUps.forEach(powerUp => {
                if (powerUp && powerUp.active) {
                    const dist = Math.hypot(
                        powerUp.x - gameState.player.x,
                        powerUp.y - gameState.player.y
                    );
                    
                    if (dist < 30) {
                        powerUp.active = false;
                        
                        // Initialize PowerUpManager if not exists
                        if (!gameState.powerUpManager) {
                            gameState.powerUpManager = new PowerUpManager(gameState.player);
                        }
                        
                        switch(powerUp.type) {
                            // Classic power-ups (immediate effects)
                            case 'weapon':
                                gameState.player.weaponLevel = Math.min(5, gameState.player.weaponLevel + 1);
                                break;
                            case 'shield':
                                gameState.player.shield = Math.min(5, gameState.player.shield + 3);
                                gameState.player.shieldActive = true;
                                break;
                            case 'bomb':
                                gameState.bombs = Math.min(9, gameState.bombs + 1);
                                break;
                            case 'rapid':
                                gameState.player.fireRate = Math.max(2, gameState.player.fireRate - 2);
                                break;
                            case 'health':
                                gameState.lives = Math.min(7, gameState.lives + 1);
                                if (particleSystem) {
                                    particleSystem.addExplosion(powerUp.x, powerUp.y, '#ff0000', 25);
                                }
                                break;
                                
                            // All other power-ups use the advanced system
                            default:
                                gameState.powerUpManager.addPowerUp(powerUp.type, 
                                    powerUp.rarity === 'legendary' ? 800 : 
                                    powerUp.rarity === 'epic' ? 700 : 
                                    powerUp.rarity === 'rare' ? 600 : 500);
                                break;
                        }
                        
                        // Special effects based on rarity
                        let particleCount = 10;
                        let soundEffect = 'OUTSTANDING';
                        
                        switch(powerUp.rarity) {
                            case 'legendary':
                                particleCount = 50;
                                soundEffect = 'RADICAL';
                                gameState.screenShake.intensity = 15;
                                gameState.screenShake.duration = 30;
                                break;
                            case 'epic':
                                particleCount = 35;
                                soundEffect = 'EXCELLENT';
                                gameState.screenShake.intensity = 10;
                                gameState.screenShake.duration = 20;
                                break;
                            case 'rare':
                                particleCount = 25;
                                soundEffect = 'PERFECT';
                                break;
                            case 'uncommon':
                                particleCount = 15;
                                break;
                        }
                        
                        if (soundSystem) {
                            soundSystem.playPowerUp();
                            setTimeout(() => {
                                soundSystem.playVoiceSample(soundEffect);
                            }, 100);
                        }
                        
                        updateUI();
                        
                        if (particleSystem && powerUp && powerUp.color) {
                            particleSystem.addExplosion(powerUp.x, powerUp.y, powerUp.color, particleCount);
                            
                            // Extra sparkle effect for rare+ items
                            if (['rare', 'epic', 'legendary'].includes(powerUp.rarity)) {
                                for (let i = 0; i < 20; i++) {
                                    const angle = (Math.PI * 2 * i) / 20;
                                    const speed = Math.random() * 12 + 6;
                                    particleSystem.particles.push({
                                        x: powerUp.x,
                                        y: powerUp.y,
                                        vx: Math.cos(angle) * speed,
                                        vy: Math.sin(angle) * speed,
                                        color: powerUp.color,
                                        life: 60,
                                        maxLife: 60,
                                        size: Math.random() * 4 + 2,
                                        sparkle: true,
                                        active: true,
                                        update() {
                                            this.x += this.vx;
                                            this.y += this.vy;
                                            this.vx *= 0.92;
                                            this.vy *= 0.92;
                                            this.life--;
                                            if (this.life <= 0) this.active = false;
                                        },
                                        draw(ctx) {
                                            const alpha = this.life / this.maxLife;
                                            ctx.save();
                                            ctx.globalAlpha = alpha;
                                            ctx.fillStyle = this.color;
                                            ctx.shadowBlur = 25;
                                            ctx.shadowColor = this.color;
                                            
                                            if (this.sparkle) {
                                                // Diamond sparkle shape
                                                ctx.translate(this.x, this.y);
                                                ctx.rotate(this.life * 0.1);
                                                ctx.beginPath();
                                                ctx.moveTo(0, -this.size);
                                                ctx.lineTo(this.size, 0);
                                                ctx.lineTo(0, this.size);
                                                ctx.lineTo(-this.size, 0);
                                                ctx.closePath();
                                                ctx.fill();
                                            } else {
                                                ctx.beginPath();
                                                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                                ctx.fill();
                                            }
                                            
                                            ctx.restore();
                                        }
                                    });
                                }
                            }
                        }
                    }
                }
            });
        }

        // Attract Mode Functions
        function resetAttractModeTimeout() {
            if (attractModeTimer) {
                clearTimeout(attractModeTimer);
            }
            
            attractModeTimer = setTimeout(() => {
                if (!gameState || !gameState.running) {
                    startAttractMode();
                }
            }, 10000);
        }
        
        function startAttractMode() {
            if (attractMode || (gameState && gameState.running)) return;
            
            console.log('🕹️ Starting attract mode - classic arcade demo!');
            
            if (musicEnabled && menuMusic && gameMusic) {
                try {
                    gameMusic.pause();
                    gameMusic.currentTime = 0;
                    menuMusic.play().catch(err => console.warn("Attract mode menu music play failed:", err));
                } catch (error) {
                    console.warn("Music control failed:", error);
                }
            }
            
            attractMode = true;
            attractModeAI = new AttractModeAI();
            
            document.getElementById('menuScreen').style.display = 'none';
            document.getElementById('gameUI').style.display = 'block';
            
            particleSystem = new ParticleSystem();
            soundSystem = new SoundSystem();
            soundSystem.enabled = false;
            bulletPool = new BulletPool();
            enemyBulletPool = new BulletPool();
            
            // 🎬 VISUAL EFFECTS SHOULD ALREADY BE INITIALIZED
            // Just reset epic explosions array for attract mode
            epic80sExplosions = [];
            
            // 🌟 ENSURE STARFIELD IS READY FOR ATTRACT MODE
            if (!starfield) {
                try {
                    starfield = new Starfield();
                    console.log('⭐ Starfield created for attract mode');
                } catch (error) {
                    console.warn('Failed to create starfield for attract mode:', error);
                }
            }
            
            if (!starfield) starfield = new Starfield();
            if (!formationManager) formationManager = new FormationManager();
            if (!ufoManager) ufoManager = new UFOManager();
            
            const newRadicalSlang = new RadicalSlang();
            
            gameState = {
                running: true,
                paused: false,
                score: Math.floor(Math.random() * 50000),
                lastScoreIncrease: 0,
                lives: 3,
                bombs: 3,
                wave: Math.floor(Math.random() * 5) + 1,
                combo: 0,
                maxCombo: 0,
                comboTimer: 0,
                comboTimeout: 180,
                enemies: [],
                particles: [],
                powerUps: [],
                boss: null,
                player: new Player(config.width / 2, config.height - 100),
                radicalSlang: newRadicalSlang,
                screenShake: { x: 0, y: 0, intensity: 0, duration: 0 },
                promoTexts: [
                    "INSERT COIN TO PLAY",
                    "HIGH SCORE: " + (getHighScores()[0]?.score?.toLocaleString() || '0'),
                    "*** GEOMETRY 3044 ***",
                    "DEFEAT THE GEOMETRIC MENACE",
                    "COLLECT POWER-UPS FOR MAXIMUM FIREPOWER",
                    "USE BOMBS WISELY - CLEAR THE SCREEN",
                    "CHAIN COMBOS FOR RADICAL SCORES",
                    "FASTER SHIP FOR SUPERIOR MANEUVERS",
                    "EVERY 100,000 POINTS = EXTRA LIFE",
                    "🛸 MYSTERY UFO = MASSIVE BONUS 🛸",
                    "FORMATION LEADERS = 500+ BONUS",
                    "PRESS C TO INSERT COIN",
                    "🏆 HIGH SCORES 🏆",
                    "© 2024 NEON ARCADE SYSTEMS",
                    "CHALLENGE THE VOID..."
                ],
                currentPromoIndex: 0,
                promoTimer: 0
            };
            
            gameState.player.weaponLevel = Math.floor(Math.random() * 3) + 1;
            
            waveManager = new WaveManager();
            updateUI();
            
            document.getElementById('scoreDisplay').textContent = 'DEMO';
            
            requestAnimationFrame(attractModeLoop);
        }
        
        function exitAttractMode() {
            if (!attractMode) return;
            
            console.log('🕹️ Exiting attract mode - player interaction detected!');
            
            attractMode = false;
            attractModeAI = null;
            highScoreFromAttractMode = false;
            
            if (gameState) {
                gameState.running = false;
            }
            
            if (bulletPool) bulletPool.clear();
            if (enemyBulletPool) enemyBulletPool.clear();
            
            document.getElementById('menuScreen').style.display = 'flex';
            document.getElementById('gameUI').style.display = 'none';
            
            if (soundSystem) soundSystem.enabled = true;
            
            resetAttractModeTimeout();
        }
        
        function attractModeLoop() {
            if (!attractMode || !gameState || !gameState.running) {
                return;
            }
            
            if (attractModeAI && gameState.player) {
                const enemyBullets = enemyBulletPool ? enemyBulletPool.getActiveBullets() : [];
                attractModeAI.update(gameState.player, gameState.enemies, enemyBullets);
            }
            
            update();
            render();
            
            if (attractMode && gameState && gameState.running) {
                requestAnimationFrame(attractModeLoop);
            }
        }

        // Game Loop
        function gameLoop() {
            try {
                if (gameState && gameState.running) {
                    if (!gameState.paused || gameState.lives <= 0) {
                        update();
                        render();
                    }
                    
                    gameLoopId = requestAnimationFrame(gameLoop);
                }
            } catch (error) {
                console.error('Game loop error:', error);
                console.error('Stack trace:', error.stack);
                if (gameState && gameState.running) {
                    gameLoopId = requestAnimationFrame(gameLoop);
                }
            }
        }

        function update() {
            try {
                if (!gameState || !gameState.running) return;
                
                // 🚀 PERFORMANCE MONITOR
                const frameStart = performance.now();
                
                const timeScale = gameState.slowMotion > 0 ? 0.3 : 1.0;
                if (gameState.slowMotion > 0) gameState.slowMotion--;
                
                // 🎬 UPDATE ADVANCED VISUAL EFFECTS (with null checks and performance limits)
                if (vhsGlitch && frameStart % 2 === 0) vhsGlitch.update(); // Every other frame
                if (oscilloscopeUI && frameStart % 3 === 0) oscilloscopeUI.update(); // Every 3rd frame
                if (holographicUI && frameStart % 4 === 0) holographicUI.update(); // Every 4th frame
                if (laserTargeting) laserTargeting.update();
                
                // Update epic explosions with limit check
                if (epic80sExplosions && epic80sExplosions.length > 0) {
                    // 🚀 PERFORMANCE: Limit concurrent explosions
                    if (epic80sExplosions.length > 3) {
                        epic80sExplosions = epic80sExplosions.slice(-3); // Keep only newest 3
                    }
                    epic80sExplosions = epic80sExplosions.filter(explosion => {
                        explosion.update();
                        return explosion.active;
                    });
                }
                
                if (attractMode) {
                    gameState.promoTimer++;
                    if (gameState.promoTimer > 90) {
                        gameState.currentPromoIndex = (gameState.currentPromoIndex + 1) % gameState.promoTexts.length;
                        gameState.promoTimer = 0;
                        
                        if (gameState.promoTexts[gameState.currentPromoIndex] === "🏆 HIGH SCORES 🏆") {
                            showHighScoreList();
                            return;
                        }
                    }
                }
                
                if (gameState.radicalSlang) gameState.radicalSlang.update();
                if (particleSystem) particleSystem.update();
                if (bulletPool) bulletPool.update();
                if (enemyBulletPool && timeScale === 1) enemyBulletPool.update();
                
                if (starfield) starfield.update();
                if (formationManager && timeScale === 1) formationManager.update();
                if (ufoManager && timeScale === 1) ufoManager.update();
                
                if (gameState.combo > 0) {
                    gameState.comboTimer++;
                    if (gameState.comboTimer > gameState.comboTimeout) {
                        gameState.combo = 0;
                        gameState.comboTimer = 0;
                        updateUI();
                    }
                }
                
                if (gameState.player) gameState.player.update();
                
                // Update PowerUpManager
                if (gameState.powerUpManager) {
                    gameState.powerUpManager.update();
                }
                
                if (gameState.enemies && timeScale === 1) {
                    // 🚀 PERFORMANCE: Limit enemy count and updates
                    if (gameState.enemies.length > 15) {
                        gameState.enemies = gameState.enemies.slice(0, 15); // Hard cap at 15 enemies
                    }
                    
                    gameState.enemies = gameState.enemies.filter(enemy => {
                        if (enemy && enemy.active && typeof enemy.update === 'function') {
                            enemy.update();
                            
                            // 🎯 ADD LASER TARGETING TO ENEMIES (reduced frequency)
                            if (laserTargeting && Math.random() < 0.005) { // Reduced from 0.02
                                laserTargeting.addTarget(enemy.x, enemy.y, enemy.type);
                            }
                            
                            return true;
                        }
                        return false;
                    });
                }
                
                if (gameState.boss && gameState.boss.active && timeScale === 1) {
                    gameState.boss.update();
                    
                    // 🎯 BOSS TARGETING (reduced frequency)
                    if (laserTargeting && Math.random() < 0.01) { // Reduced from 0.05
                        laserTargeting.addTarget(gameState.boss.x, gameState.boss.y, 'boss');
                    }
                }
                
                // 🚀 PERFORMANCE: Optimize particle updates with batching
                if (gameState.particles && gameState.particles.length > 0) {
                    // Limit particle processing per frame
                    const maxParticlesPerFrame = 30;
                    const particlesToProcess = Math.min(gameState.particles.length, maxParticlesPerFrame);
                    
                    for (let i = 0; i < particlesToProcess; i++) {
                        const p = gameState.particles[i];
                        try {
                            if (p && typeof p.update === 'function') {
                                p.update();
                                if (p.active === false) {
                                    gameState.particles.splice(i, 1);
                                    i--;
                                    break; // Only remove one per frame to avoid hitching
                                }
                            }
                        } catch (err) {
                            console.warn('Particle update error:', err);
                            gameState.particles.splice(i, 1);
                            i--;
                        }
                    }
                    
                    // Clean up expired particles periodically
                    if (frameStart % 120 === 0) { // Every 2 seconds
                        gameState.particles = gameState.particles.filter(p => 
                            p && p.active !== false && (p.life === undefined || p.life > 0)
                        );
                    }
                }
                
                if (gameState.powerUps) {
                    gameState.powerUps = gameState.powerUps.filter(p => {
                        if (p && typeof p.update === 'function') {
                            p.update();
                            return p.active;
                        }
                        return false;
                    });
                }
                
                if (waveManager && timeScale === 1) waveManager.update(1);
                
                if (gameState.screenShake && gameState.screenShake.duration > 0) {
                    gameState.screenShake.duration--;
                    const intensity = gameState.screenShake.intensity * (gameState.screenShake.duration / 30);
                    gameState.screenShake.x = (Math.random() - 0.5) * intensity;
                    gameState.screenShake.y = (Math.random() - 0.5) * intensity;
                } else if (gameState.screenShake) {
                    gameState.screenShake.x = 0;
                    gameState.screenShake.y = 0;
                }
                
                checkCollisions();
                
                // 🚀 PERFORMANCE: Monitor frame time and log warnings
                const frameTime = performance.now() - frameStart;
                
                // Show performance warnings
                if (frameTime > 20) { // Frame took longer than 20ms (below 50fps)
                    console.warn(`⚠️ Slow frame detected: ${frameTime.toFixed(2)}ms`);
                    
                    // Emergency performance measures
                    if (frameTime > 50) { // Extremely slow frame (below 20fps)
                        console.error(`🚨 CRITICAL: Frame time ${frameTime.toFixed(2)}ms - activating emergency measures`);
                        
                        // Emergency cleanup
                        if (particleSystem && particleSystem.particles.length > 20) {
                            particleSystem.particles = particleSystem.particles.slice(-20);
                        }
                        if (epic80sExplosions && epic80sExplosions.length > 1) {
                            epic80sExplosions = epic80sExplosions.slice(-1);
                        }
                        if (gameState.particles && gameState.particles.length > 10) {
                            gameState.particles = gameState.particles.slice(-10);
                        }
                        
                        // Disable some visual effects temporarily
                        if (vhsGlitch) vhsGlitch.transitionTimer = 0;
                    }
                }
                
            } catch (error) {
                console.error('Update error:', error);
                console.error('Stack trace:', error.stack);
            }
        }

        function render() {
            if (!ctx || !gameState) return;
            
            try {
                ctx.save();
                
                if (gameState.screenShake) {
                    ctx.translate(gameState.screenShake.x || 0, gameState.screenShake.y || 0);
                }
                
                // 🎨 THEMED BACKGROUND SYSTEM WITH ENHANCED STARFIELD
                try {
                    const theme = getCurrentTheme();
                    
                    // Create deep space background gradient
                    const bgGradient = ctx.createLinearGradient(0, 0, 0, config.height);
                    bgGradient.addColorStop(0, theme.bgStart);
                    bgGradient.addColorStop(0.3, theme.bgEnd);
                    bgGradient.addColorStop(0.7, '#000011');
                    bgGradient.addColorStop(1, '#000000');
                    ctx.fillStyle = bgGradient;
                    ctx.fillRect(0, 0, config.width, config.height);
                    
                    // Always draw starfield if available
                    if (starfield) {
                        starfield.draw(ctx);
                    }
                } catch (bgErr) {
                    console.warn('Background render error:', bgErr);
                    // Fallback - simpler background
                    const bgGradient = ctx.createLinearGradient(0, 0, 0, config.height);
                    bgGradient.addColorStop(0, '#000428');
                    bgGradient.addColorStop(1, '#004e92');
                    ctx.fillStyle = bgGradient;
                    ctx.fillRect(0, 0, config.width, config.height);
                    
                    // Simple fallback starfield if main one fails
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)'; // Reduced from 0.8
                    for (let i = 0; i < 100; i++) {
                        const x = Math.random() * config.width;
                        const y = (Math.random() * config.height + Date.now() * 0.1) % (config.height + 50) - 50;
                        const size = Math.random() * 1.5; // Reduced from 2
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // 🎯 LASER TARGETING GRID (with null check)
                if (laserTargeting) {
                    laserTargeting.drawTargetingGrid(ctx);
                }
                
                drawThemedGrid();
                
                // 📊 OSCILLOSCOPE SCAN LINES (with null check)
                if (oscilloscopeUI) {
                    oscilloscopeUI.drawScanLines(ctx);
                }
                
                // Draw bonus round
                if (bonusRound && bonusRound.active) {
                    bonusRound.draw(ctx);
                }
                
                if (particleSystem) {
                    particleSystem.draw(ctx);
                }
                
                // 🎆 EPIC 80S EXPLOSIONS (with null check)
                if (epic80sExplosions && epic80sExplosions.length > 0) {
                    epic80sExplosions.forEach(explosion => {
                        if (explosion.active) {
                            explosion.draw(ctx);
                        }
                    });
                }
                
                if (gameState.particles) {
                    gameState.particles.forEach(p => {
                        try {
                            if (p && p.draw && p.active !== false) p.draw(ctx);
                        } catch (err) {
                            console.warn('Particle draw error:', err);
                        }
                    });
                }
                
                if (gameState.enemies) {
                    gameState.enemies.forEach(e => {
                        try {
                            if (e && e.draw && e.active) e.draw(ctx);
                        } catch (err) {
                            console.warn('Enemy draw error:', err);
                        }
                    });
                }
                
                if (gameState.boss) {
                    try {
                        gameState.boss.draw(ctx);
                    } catch (err) {}
                }
                
                if (bulletPool) bulletPool.draw(ctx);
                if (enemyBulletPool) enemyBulletPool.draw(ctx);
                
                if (gameState.powerUps) {
                    gameState.powerUps.forEach(p => {
                        try {
                            if (p && p.draw) p.draw(ctx);
                        } catch (err) {}
                    });
                }
                
                if (ufoManager) {
                    try {
                        ufoManager.draw(ctx);
                    } catch (err) {}
                }
                
                // 🎯 LASER TARGETING OVERLAYS (with null check)
                if (laserTargeting) {
                    laserTargeting.drawTargets(ctx);
                }
                
                if (gameState.player && gameState.player.isAlive) {
                    if (!gameState.player.invulnerable || Math.floor(Date.now() / 100) % 2) {
                        gameState.player.draw(ctx);
                    }
                }
                
                if (gameState.radicalSlang) {
                    gameState.radicalSlang.draw(ctx);
                }
                
                ctx.restore();
                
                // 🎨 THEME DISPLAY
                drawThemeDisplay(ctx);
                
                // 🌀 HOLOGRAPHIC UI ELEMENTS (with null check)
                if (holographicUI && !attractMode && gameState.running) {
                    drawHolographicUI(ctx);
                }
                
                // Power-Up Manager UI
                if (gameState.powerUpManager && !attractMode && gameState.running) {
                    gameState.powerUpManager.drawUI(ctx);
                }
                
                if (attractMode && gameState.promoTexts) {
                    ctx.save();
                    
                    // Use terminal text function if available, otherwise fallback to basic
                    if (typeof drawTerminalText === 'function') {
                        drawTerminalText(ctx, gameState.promoTexts[gameState.currentPromoIndex], 
                                       config.width / 2, config.height * 0.85, {
                            font: 'bold 24px ' + (terminalFonts ? terminalFonts.display : 'Courier New'),
                            color: '#00ffff',
                            align: 'center',
                            flicker: true,
                            shadowBlur: 20
                        });
                        
                        drawTerminalText(ctx, 'DEMO MODE', config.width / 2, 30, {
                            font: 'bold 16px ' + (terminalFonts ? terminalFonts.terminal : 'Courier New'),
                            color: '#ff00ff',
                            align: 'center',
                            flicker: true,
                            shadowBlur: 15
                        });
                        
                        if (gameState.promoTexts[gameState.currentPromoIndex].includes('PRESS ANY KEY') || 
                            gameState.promoTexts[gameState.currentPromoIndex].includes('PRESS C TO INSERT')) {
                            
                            drawTerminalText(ctx, 'PRESS C TO INSERT COIN', config.width / 2, config.height * 0.92, {
                                font: 'bold 20px ' + (terminalFonts ? terminalFonts.primary : 'Courier New'),
                                color: '#ffff00',
                                align: 'center',
                                flicker: Math.sin(Date.now() * 0.008) > 0,
                                shadowBlur: 25
                            });
                        }
                    } else {
                        // Fallback to original rendering
                        ctx.font = 'bold 24px Courier New';
                        ctx.textAlign = 'center';
                        ctx.fillStyle = '#00ffff';
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#00ffff';
                        ctx.globalAlpha = 0.8 + Math.sin(Date.now() * 0.005) * 0.2;
                        ctx.fillText(
                            gameState.promoTexts[gameState.currentPromoIndex], 
                            config.width / 2, 
                            config.height * 0.85
                        );
                        
                        ctx.font = 'bold 16px Courier New';
                        ctx.fillStyle = '#ff00ff';
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#ff00ff';
                        ctx.globalAlpha = 0.6 + Math.sin(Date.now() * 0.01) * 0.4;
                        ctx.fillText('DEMO MODE', config.width / 2, 30);
                        
                        if (gameState.promoTexts[gameState.currentPromoIndex].includes('PRESS ANY KEY') || 
                            gameState.promoTexts[gameState.currentPromoIndex].includes('PRESS C TO INSERT')) {
                            ctx.font = 'bold 20px Courier New';
                            ctx.fillStyle = '#ffff00';
                            ctx.shadowBlur = 25;
                            ctx.shadowColor = '#ffff00';
                            ctx.globalAlpha = Math.sin(Date.now() * 0.008) > 0 ? 1 : 0.3;
                            ctx.fillText('PRESS C TO INSERT COIN', config.width / 2, config.height * 0.92);
                        }
                    }
                    
                    ctx.restore();
                }
                
                if (gameState.combo > 0) {
                    if (typeof drawHolographicComboMeter === 'function' && holographicUI) {
                        drawHolographicComboMeter(ctx);
                    } else {
                        // Fallback to original combo meter
                        ctx.save();
                        
                        const meterWidth = Math.min(250, config.width * 0.3);
                        const meterHeight = 12;
                        const meterX = config.width / 2 - meterWidth / 2;
                        const meterY = config.height * 0.15;
                        const comboPercent = Math.min(gameState.comboTimer / gameState.comboTimeout, 1);
                        
                        ctx.fillStyle = 'rgba(30, 0, 50, 0.8)';
                        ctx.fillRect(meterX - 2, meterY - 2, meterWidth + 4, meterHeight + 4);
                        
                        const gradient = ctx.createLinearGradient(meterX, 0, meterX + meterWidth, 0);
                        gradient.addColorStop(0, '#ff00ff');
                        gradient.addColorStop(0.3, '#ff006e');
                        gradient.addColorStop(0.6, '#8b00ff');
                        gradient.addColorStop(1, '#00ffff');
                        
                        ctx.fillStyle = gradient;
                        ctx.fillRect(meterX, meterY, meterWidth * (1 - comboPercent), meterHeight);
                        
                        ctx.strokeStyle = '#00ffff';
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#00ffff';
                        ctx.strokeRect(meterX, meterY, meterWidth, meterHeight);
                        
                        const comboSize = Math.min(36 + gameState.combo * 2, 48);
                        ctx.font = `bold ${comboSize}px Courier New`;
                        ctx.textAlign = 'center';
                        ctx.shadowBlur = 30;
                        ctx.shadowColor = '#ff00ff';
                        
                        const textGradient = ctx.createLinearGradient(config.width / 2 - 100, 0, config.width / 2 + 100, 0);
                        textGradient.addColorStop(0, '#ff00ff');
                        textGradient.addColorStop(0.5, '#00ffff');
                        textGradient.addColorStop(1, '#ff00ff');
                        
                        ctx.fillStyle = textGradient;
                        ctx.globalAlpha = 0.9 + Math.sin(Date.now() * 0.01) * 0.1;
                        
                        const comboText = `${gameState.combo}x COMBO`;
                        ctx.fillText(comboText, config.width / 2, meterY - 15);
                        
                        ctx.font = 'bold 20px Courier New';
                        ctx.fillStyle = '#ffffff';
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#ffffff';
                        ctx.globalAlpha = 0.9;
                        ctx.fillText(`Score ×${gameState.combo}`, config.width / 2, meterY + meterHeight + 25);
                        
                        ctx.restore();
                    }
                }
                
                if (gameState.lives <= 0 && gameState.paused) {
                    ctx.save();
                    
                    if (typeof drawTerminalText === 'function') {
                        drawTerminalText(ctx, 'GAME OVER', config.width / 2, config.height / 2, {
                            font: 'bold 72px ' + (terminalFonts ? terminalFonts.display : 'Courier New'),
                            color: '#ff0000',
                            align: 'center',
                            baseline: 'middle',
                            flicker: true,
                            glitch: true,
                            shadowBlur: 30
                        });
                    } else {
                        // Fallback to original
                        ctx.fillStyle = '#ff0000';
                        ctx.font = 'bold 72px Courier New';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.shadowBlur = 30;
                        ctx.shadowColor = '#ff0000';
                        ctx.globalAlpha = 0.8 + Math.sin(Date.now() * 0.01) * 0.2;
                        ctx.fillText('GAME OVER', config.width / 2, config.height / 2);
                    }
                    
                    ctx.restore();
                }
                
                // 🌀 HOLOGRAPHIC SCANNING LINE (with null check)
                if (holographicUI) {
                    holographicUI.drawScanningLine(ctx, getCurrentTheme().secondary);
                }
                
                // 🎮 Enhanced CRT/Scanline effect
                drawEnhancedCRT(ctx);
                
                // Draw performance indicator if needed
                if (gameState && gameState.wave >= 5) {
                    const particleCount = particleSystem ? particleSystem.particles.length : 0;
                    const bulletCount = bulletPool ? bulletPool.bullets.filter(b => b.active).length : 0;
                    const enemyBulletCount = enemyBulletPool ? enemyBulletPool.bullets.filter(b => b.active).length : 0;
                    
                    // Show performance warning if counts are high
                    if (particleCount > 100 || bulletCount > 100 || enemyBulletCount > 80) {
                        ctx.save();
                        ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
                        ctx.font = 'bold 12px Courier New';
                        ctx.textAlign = 'left';
                        ctx.fillText('⚡ PERFORMANCE MODE', 10, config.height - 30);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                        ctx.font = '10px Courier New';
                        ctx.fillText(`P:${particleCount} B:${bulletCount} E:${enemyBulletCount}`, 10, config.height - 15);
                        ctx.restore();
                    }
                }
                
                // 📺 VHS GLITCH EFFECTS (APPLIED LAST) (with null check)
                if (vhsGlitch) {
                    vhsGlitch.apply(ctx);
                }
                
            } catch (error) {
                console.error('Render error:', error);
            }
        }

        // 🎨 THEMED GRID SYSTEM
        function drawThemedGrid() {
            if (!ctx) return;
            
            const theme = getCurrentTheme();
            
            ctx.save();
            
            const pulse = Math.sin(Date.now() * 0.001) * 0.3 + 0.7;
            const colorShift = Math.sin(Date.now() * 0.0005) * 30;
            
            const hue = theme.gridHue + colorShift;
            ctx.strokeStyle = `hsla(${hue}, 100%, 50%, ${0.15 * pulse})`;
            ctx.lineWidth = 1;
            ctx.shadowBlur = 8 * pulse;
            ctx.shadowColor = `hsla(${hue}, 100%, 50%, 0.4)`;
            
            const gridSize = 60;
            const offset = (Date.now() * 0.02) % gridSize;
            
            // Vertical grid lines with perspective
            for (let x = -gridSize; x < config.width + gridSize; x += gridSize) {
                const perspectiveFactor = 1 + (config.height - 400) / config.height * 0.5;
                const startX = x + offset;
                const endX = (x - config.width/2) * perspectiveFactor + config.width/2 + offset;
                
                ctx.beginPath();
                ctx.moveTo(startX, 0);
                ctx.lineTo(endX, config.height);
                ctx.stroke();
            }
            
            // Horizontal grid lines
            for (let y = 0; y < config.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(config.width, y);
                ctx.stroke();
            }
            
            // Themed horizon gradient
            ctx.globalAlpha = 0.12;
            const gradient = ctx.createLinearGradient(0, config.height - 150, 0, config.height);
            gradient.addColorStop(0, 'transparent');
            gradient.addColorStop(0.5, `hsla(${theme.gridHue}, 100%, 50%, 0.25)`);
            gradient.addColorStop(1, `hsla(${theme.gridHue + 60}, 100%, 50%, 0.35)`);
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, config.height - 150, config.width, 150);
            
            ctx.restore();
        }

        // 🌀 HOLOGRAPHIC UI DRAWING FUNCTIONS
        function drawHolographicUI(ctx) {
            if (!holographicUI || !gameState) return;
            
            try {
                const theme = getCurrentTheme();
                
                // Holographic score display
                holographicUI.drawHolographicBox(ctx, 20, 20, 200, 60, theme.primary, 0.8);
                drawTerminalText(ctx, `SCORE: ${gameState.score.toLocaleString()}`, 30, 35, {
                    font: 'bold 18px ' + (terminalFonts ? terminalFonts.terminal : 'Courier New'),
                    color: theme.primary,
                    flicker: true,
                    shadowBlur: 15
                });
                
                // Holographic wave display
                holographicUI.drawHolographicBox(ctx, config.width - 160, 20, 140, 60, theme.secondary, 0.8);
                drawTerminalText(ctx, `WAVE: ${gameState.wave}`, config.width - 150, 35, {
                    font: 'bold 18px ' + (terminalFonts ? terminalFonts.terminal : 'Courier New'),
                    color: theme.secondary,
                    flicker: true,
                    shadowBlur: 15
                });
                
                // Holographic lives display
                holographicUI.drawHolographicBox(ctx, 20, 90, 120, 40, '#00ff00', 0.8);
                drawTerminalText(ctx, `LIVES: ${gameState.lives}`, 30, 105, {
                    font: 'bold 14px ' + (terminalFonts ? terminalFonts.terminal : 'Courier New'),
                    color: '#00ff00',
                    flicker: gameState.lives <= 1,
                    shadowBlur: 12
                });
                
                // Holographic bombs display
                holographicUI.drawHolographicBox(ctx, 150, 90, 120, 40, '#ffff00', 0.8);
                drawTerminalText(ctx, `BOMBS: ${gameState.bombs}`, 160, 105, {
                    font: 'bold 14px ' + (terminalFonts ? terminalFonts.terminal : 'Courier New'),
                    color: '#ffff00',
                    flicker: gameState.bombs === 0,
                    shadowBlur: 12
                });
            } catch (error) {
                console.warn('Error drawing holographic UI:', error);
            }
        }
        
        function drawHolographicComboMeter(ctx) {
            if (!holographicUI || !gameState || gameState.combo <= 0) return;
            
            try {
                const theme = getCurrentTheme();
                const meterWidth = Math.min(300, config.width * 0.35);
                const meterHeight = 20;
                const meterX = config.width / 2 - meterWidth / 2;
                const meterY = config.height * 0.12;
                const comboPercent = Math.min(gameState.comboTimer / gameState.comboTimeout, 1);
                
                // Holographic meter background
                holographicUI.drawHolographicBox(ctx, meterX - 10, meterY - 35, meterWidth + 20, 80, theme.accent, 0.6);
                
                // Meter fill with holographic effect
                ctx.save();
                ctx.globalAlpha = 0.8 + (holographicUI.flickerIntensity || 0);
                
                const gradient = ctx.createLinearGradient(meterX, 0, meterX + meterWidth, 0);
                gradient.addColorStop(0, theme.primary);
                gradient.addColorStop(0.5, theme.secondary);
                gradient.addColorStop(1, theme.accent);
                
                ctx.fillStyle = gradient;
                ctx.shadowBlur = 20;
                ctx.shadowColor = theme.accent;
                ctx.fillRect(meterX, meterY, meterWidth * (1 - comboPercent), meterHeight);
                
                // Holographic border
                ctx.strokeStyle = theme.secondary;
                ctx.lineWidth = 2;
                ctx.shadowBlur = 15;
                ctx.shadowColor = theme.secondary;
                ctx.strokeRect(meterX, meterY, meterWidth, meterHeight);
                
                ctx.restore();
                
                // Combo text with terminal font
                const comboSize = Math.min(36 + gameState.combo * 1.5, 48);
                drawTerminalText(ctx, `${gameState.combo}x COMBO`, config.width / 2, meterY - 30, {
                    font: `bold ${comboSize}px ` + (terminalFonts ? terminalFonts.display : 'Courier New'),
                    color: theme.primary,
                    align: 'center',
                    flicker: true,
                    glitch: gameState.combo > 10,
                    shadowBlur: 30
                });
                
                drawTerminalText(ctx, `SCORE MULTIPLIER ACTIVE`, config.width / 2, meterY + meterHeight + 10, {
                    font: 'bold 16px ' + (terminalFonts ? terminalFonts.terminal : 'Courier New'),
                    color: theme.secondary,
                    align: 'center',
                    flicker: true,
                    shadowBlur: 15
                });
            } catch (error) {
                console.warn('Error drawing holographic combo meter:', error);
            }
        }
        function drawThemeDisplay(ctx) {
            if (!gameState || attractMode) return;
            
            const theme = getCurrentTheme();
            
            // Show theme change notification
            if (gameState.themeChangeTimer) {
                gameState.themeChangeTimer--;
                
                ctx.save();
                ctx.translate(config.width / 2, config.height * 0.25);
                
                const alpha = gameState.themeChangeTimer > 60 ? 
                    (120 - gameState.themeChangeTimer) / 60 :
                    gameState.themeChangeTimer / 60;
                
                const scale = gameState.themeChangeTimer > 90 ? 
                    1 + (120 - gameState.themeChangeTimer) / 30 : 1;
                
                ctx.scale(scale, scale);
                ctx.globalAlpha = alpha;
                
                // Theme name
                ctx.font = 'bold 48px Courier New';
                ctx.textAlign = 'center';
                ctx.fillStyle = theme.primary;
                ctx.shadowBlur = 30;
                ctx.shadowColor = theme.primary;
                ctx.fillText(theme.name, 0, -20);
                
                // Theme activated text
                ctx.font = 'bold 24px Courier New';
                ctx.fillStyle = theme.secondary;
                ctx.shadowBlur = 20;
                ctx.shadowColor = theme.secondary;
                ctx.fillText('THEME ACTIVATED', 0, 20);
                
                // Color preview bars
                const barWidth = 200;
                const barHeight = 8;
                const barSpacing = 12;
                
                ctx.shadowBlur = 0;
                
                // Primary color bar
                ctx.fillStyle = theme.primary;
                ctx.fillRect(-barWidth/2, 35, barWidth, barHeight);
                
                // Secondary color bar
                ctx.fillStyle = theme.secondary;
                ctx.fillRect(-barWidth/2, 35 + barSpacing, barWidth, barHeight);
                
                // Accent color bar
                ctx.fillStyle = theme.accent;
                ctx.fillRect(-barWidth/2, 35 + barSpacing * 2, barWidth, barHeight);
                
                ctx.restore();
            }
            
            // Small theme indicator in corner
            if (!gameState.themeChangeTimer) {
                ctx.save();
                ctx.translate(config.width - 120, 30);
                
                ctx.font = 'bold 14px Courier New';
                ctx.textAlign = 'right';
                ctx.fillStyle = theme.secondary;
                ctx.shadowBlur = 10;
                ctx.shadowColor = theme.secondary;
                ctx.globalAlpha = 0.7;
                ctx.fillText(theme.name, 0, 0);
                
                // Mini color indicators
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 0.8;
                
                ctx.fillStyle = theme.primary;
                ctx.fillRect(10, -8, 15, 3);
                
                ctx.fillStyle = theme.secondary;
                ctx.fillRect(10, -4, 15, 3);
                
                ctx.fillStyle = theme.accent;
                ctx.fillRect(10, 0, 15, 3);
                
                ctx.restore();
            }
        }

        // 🎮 ENHANCED CRT EFFECT with chromatic aberration
        function drawEnhancedCRT(ctx) {
            ctx.save();
            
            // Scanlines
            ctx.globalAlpha = 0.04;
            ctx.fillStyle = '#000000';
            
            for (let y = 0; y < config.height; y += 4) {
                ctx.fillRect(0, y, config.width, 2);
            }
            
            // Chromatic aberration (RGB shift)
            ctx.globalCompositeOperation = 'screen';
            ctx.globalAlpha = 0.03;
            
            // Red shift
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(2, 0, config.width, config.height);
            
            // Blue shift
            ctx.fillStyle = '#0000ff';
            ctx.fillRect(-2, 0, config.width, config.height);
            
            ctx.globalCompositeOperation = 'source-over';
            
            // Vignette
            const gradient = ctx.createRadialGradient(
                config.width/2, config.height/2, Math.min(config.width, config.height)/3,
                config.width/2, config.height/2, Math.max(config.width, config.height)/2
            );
            gradient.addColorStop(0, 'rgba(0,0,0,0)');
            gradient.addColorStop(0.7, 'rgba(0,0,0,0.1)');
            gradient.addColorStop(1, 'rgba(0,0,0,0.4)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, config.width, config.height);
            
            // Random flicker
            if (Math.random() < 0.02) {
                ctx.globalAlpha = 0.02;
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(0, 0, config.width, config.height);
            }
            
            // Horizontal distortion lines (like old TVs)
            if (Math.random() < 0.05) {
                const y = Math.random() * config.height;
                ctx.globalAlpha = 0.1;
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, y, config.width, 2);
            }
            
            ctx.restore();
        }

        // Bomb function
        window.useBomb = function() {
            if (!gameState || gameState.bombs <= 0) return;
            
            gameState.bombs--;
            updateUI();
            
            gameState.particles.push({
                x: gameState.player.x,
                y: gameState.player.y,
                radius: 0,
                maxRadius: Math.max(config.width, config.height),
                life: 30,
                maxLife: 30,
                active: true,
                update() {
                    this.radius += (this.maxRadius / this.maxLife) * 2;
                    this.life--;
                    if (this.life <= 0) this.active = false;
                },
                draw(ctx) {
                    const alpha = this.life / this.maxLife;
                    ctx.save();
                    
                    for (let i = 0; i < 3; i++) {
                        const ringRadius = this.radius - (i * 20);
                        if (ringRadius > 0) {
                            ctx.strokeStyle = i === 0 ? '#ffffff' : (i === 1 ? '#00ffff' : '#0099ff');
                            ctx.lineWidth = 5 - i;
                            ctx.globalAlpha = alpha * (1 - i * 0.3);
                            ctx.shadowBlur = 30;
                            ctx.shadowColor = ctx.strokeStyle;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, ringRadius, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                    }
                    
                    if (this.life > 25) {
                        ctx.fillStyle = '#ffffff';
                        ctx.globalAlpha = (this.life - 25) / 5;
                        ctx.fillRect(0, 0, config.width, config.height);
                    }
                    
                    ctx.restore();
                }
            });
            
            enemyBulletPool.clear();
            
            gameState.enemies.forEach(enemy => {
                if (enemy.active) {
                    const dist = Math.hypot(enemy.x - gameState.player.x, enemy.y - gameState.player.y);
                    const delay = Math.min(dist / 20, 15);
                    
                    setTimeout(() => {
                        if (enemy.active) {
                            enemy.takeDamage(5);
                            if (!enemy.active) {
                                gameState.score += enemy.points;
                                particleSystem.addExplosion(enemy.x, enemy.y, enemy.color, 15);
                            }
                        }
                    }, delay * 16);
                }
            });
            
            if (gameState.boss && gameState.boss.active) {
                gameState.boss.takeDamage(5);
            }
            
            for (let i = 0; i < 16; i++) {
                const angle = (Math.PI * 2 * i) / 16;
                const speed = 12;
                bulletPool.get(
                    gameState.player.x,
                    gameState.player.y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    true
                );
            }
            
            gameState.screenShake.intensity = 25;
            gameState.screenShake.duration = 40;
            
            particleSystem.addExplosion(gameState.player.x, gameState.player.y, '#ffffff', 50);
            soundSystem.playExplosion();
            
            setTimeout(() => {
                if (soundSystem) {
                    soundSystem.playVoiceSample('EXCELLENT');
                }
            }, 300);
            
            gameState.slowMotion = 30;
        }

        // Initialize everything when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            try {
                canvas = document.getElementById('gameCanvas');
                if (!canvas) {
                    console.error('Canvas not found!');
                    return;
                }
                
                ctx = canvas.getContext('2d');
                if (!ctx) {
                    console.error('Could not get canvas context!');
                    return;
                }
                
                function resizeCanvas() {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    
                    config.width = canvas.width;
                    config.height = canvas.height;
                    
                    if (starfield) {
                        starfield.resize(canvas.width, canvas.height);
                    }
                }
                
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                
                // 🎬 INITIALIZE ALL VISUAL EFFECTS EARLY
                try {
                    vhsGlitch = new VHSGlitchEffects();
                    oscilloscopeUI = new OscilloscopeUI();
                    holographicUI = new HolographicUI();
                    laserTargeting = new LaserTargetingSystem();
                    epic80sExplosions = [];
                    
                    // 🌟 INITIALIZE STARFIELD EARLY
                    starfield = new Starfield();
                    console.log('🎬 Visual effects and starfield initialized successfully!');
                } catch (effectsError) {
                    console.warn('Visual effects initialization failed:', effectsError);
                    // Set fallbacks
                    vhsGlitch = null;
                    oscilloscopeUI = null;
                    holographicUI = null;
                    laserTargeting = null;
                    epic80sExplosions = [];
                    
                    // Always try to create a basic starfield even if other effects fail
                    try {
                        starfield = new Starfield();
                        console.log('⭐ Basic starfield created as fallback');
                    } catch (starfieldError) {
                        console.warn('Even basic starfield failed:', starfieldError);
                        starfield = null;
                    }
                }
                
                const highScores = getHighScores();
                const topScore = highScores.length > 0 ? highScores[0].score : 0;
                document.getElementById('highScoreDisplay').textContent = topScore.toLocaleString();
                
                soundSystem = new SoundSystem();
                
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                if (isMobile) {
                    document.getElementById('mobileControls').style.display = 'block';
                    setupTouchControls();
                }
                
                keys = {};
                
                resetAttractModeTimeout();
                
                let musicStarted = false;
                function startMenuMusicOnFirstInteraction() {
                    if (!musicStarted && musicEnabled && menuMusic) {
                        try {
                            musicStarted = true;
                            menuMusic.play().catch(err => console.warn("Initial menu music play failed:", err));
                            document.removeEventListener('click', startMenuMusicOnFirstInteraction);
                            document.removeEventListener('keydown', startMenuMusicOnFirstInteraction);
                        } catch (error) {
                            console.warn("Music initialization failed:", error);
                        }
                    }
                }
                document.addEventListener('click', startMenuMusicOnFirstInteraction);
                document.addEventListener('keydown', startMenuMusicOnFirstInteraction);
                
                setTimeout(() => {
                    updateCreditsDisplay();
                }, 100);
                
                console.log('Game initialized successfully');
            } catch (error) {
                console.error('Initialization error:', error);
            }
        });

        // 🌟 ENHANCED MENU EFFECTS GENERATOR
        function initializeMenuEffects() {
            createNeonParticles();
            createFloatingGeometry();
            createDigitalRain();
            createNeonStreaks();
            startMenuAnimationLoop();
        }

        function createNeonParticles() {
            const particleSystem = document.getElementById('menuParticleSystem');
            if (!particleSystem) return;

            // Create falling neon particles
            for (let i = 0; i < 50; i++) {
                setTimeout(() => {
                    const particle = document.createElement('div');
                    particle.className = 'neon-particle';
                    particle.style.left = Math.random() * 100 + '%';
                    particle.style.animationDelay = Math.random() * 8 + 's';
                    particle.style.animationDuration = (6 + Math.random() * 4) + 's';
                    particleSystem.appendChild(particle);

                    // Remove and recreate particle after animation
                    setTimeout(() => {
                        if (particle.parentNode) {
                            particle.remove();
                        }
                        if (document.getElementById('menuScreen').style.display !== 'none') {
                            createNeonParticles();
                        }
                    }, 8000);
                }, i * 150);
            }
        }

        function createFloatingGeometry() {
            const menuScreen = document.getElementById('menuScreen');
            if (!menuScreen) return;

            const shapes = ['triangle', 'square', 'pentagon', 'hexagon'];
            const colors = ['#00ffff', '#ff00ff', '#ffff00', '#00ff00', '#ff0080'];

            for (let i = 0; i < 8; i++) {
                setTimeout(() => {
                    const geometry = document.createElement('div');
                    geometry.className = 'floating-geometry';
                    
                    const size = 20 + Math.random() * 40;
                    const shape = shapes[Math.floor(Math.random() * shapes.length)];
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    
                    geometry.style.width = size + 'px';
                    geometry.style.height = size + 'px';
                    geometry.style.left = Math.random() * 100 + '%';
                    geometry.style.borderColor = color;
                    geometry.style.animationDelay = Math.random() * 15 + 's';
                    geometry.style.animationDuration = (12 + Math.random() * 8) + 's';
                    
                    // Different shapes
                    if (shape === 'triangle') {
                        geometry.style.borderRadius = '0';
                        geometry.style.clipPath = 'polygon(50% 0%, 0% 100%, 100% 100%)';
                    } else if (shape === 'pentagon') {
                        geometry.style.clipPath = 'polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%)';
                    } else if (shape === 'hexagon') {
                        geometry.style.clipPath = 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)';
                    } else {
                        geometry.style.borderRadius = shape === 'square' ? '0' : '50%';
                    }
                    
                    menuScreen.appendChild(geometry);

                    setTimeout(() => {
                        if (geometry.parentNode) {
                            geometry.remove();
                        }
                    }, 20000);
                }, i * 2000);
            }
        }

        function createDigitalRain() {
            const menuScreen = document.getElementById('menuScreen');
            if (!menuScreen) return;

            const digitalChars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ<>()[]{}/*-+';
            
            for (let i = 0; i < 15; i++) {
                setTimeout(() => {
                    const rain = document.createElement('div');
                    rain.className = 'digital-rain';
                    
                    let text = '';
                    for (let j = 0; j < 20; j++) {
                        text += digitalChars.charAt(Math.floor(Math.random() * digitalChars.length));
                    }
                    
                    rain.textContent = text;
                    rain.style.left = Math.random() * 100 + '%';
                    rain.style.animationDelay = Math.random() * 6 + 's';
                    rain.style.animationDuration = (4 + Math.random() * 4) + 's';
                    
                    menuScreen.appendChild(rain);

                    setTimeout(() => {
                        if (rain.parentNode) {
                            rain.remove();
                        }
                    }, 8000);
                }, i * 400);
            }
        }

        function createNeonStreaks() {
            const menuScreen = document.getElementById('menuScreen');
            if (!menuScreen) return;

            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const streak = document.createElement('div');
                    streak.className = 'neon-streak';
                    
                    streak.style.top = Math.random() * 100 + '%';
                    streak.style.width = (200 + Math.random() * 400) + 'px';
                    streak.style.animationDelay = Math.random() * 3 + 's';
                    streak.style.animationDuration = (2 + Math.random() * 2) + 's';
                    
                    menuScreen.appendChild(streak);

                    setTimeout(() => {
                        if (streak.parentNode) {
                            streak.remove();
                        }
                    }, 5000);
                }, i * 1000);
            }
        }

        function startMenuAnimationLoop() {
            setInterval(() => {
                if (document.getElementById('menuScreen').style.display !== 'none') {
                    // Continuously create new effects
                    if (Math.random() < 0.3) createNeonParticles();
                    if (Math.random() < 0.2) createFloatingGeometry();
                    if (Math.random() < 0.1) createDigitalRain();
                    if (Math.random() < 0.15) createNeonStreaks();
                }
            }, 3000);
        }

        // Initialize menu effects when page loads
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                initializeMenuEffects();
            }, 1000);
        });

        // Input handling
        window.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' && e.target.classList.contains('initial-letter')) {
                return;
            }
            
            e.preventDefault();
            
            const key = e.key.toLowerCase();
            
            if (attractMode) {
                exitAttractMode();
                if (musicEnabled && menuMusic && gameMusic) {
                    try {
                        gameMusic.pause();
                        gameMusic.currentTime = 0;
                        menuMusic.play().catch(err => console.warn("Menu music play failed:", err));
                    } catch (error) {
                        console.warn("Music control failed:", error);
                    }
                }
                return;
            }
            
            if (document.getElementById('highScoreEntryScreen').style.display === 'flex') {
                if (!e.target.classList.contains('initial-letter')) {
                    if (key === 'enter') {
                        submitHighScore();
                    } else if (key === 'escape') {
                        skipHighScore();
                    }
                }
                return;
            }
            
            if (document.getElementById('highScoreListScreen').style.display === 'flex') {
                if (key === 'enter' || key === 'escape' || key === ' ') {
                    closeHighScores();
                }
                return;
            }
            
            keys[key] = true;
            
            if (e.key.startsWith('Arrow')) {
                keys[e.key] = true;
            }
            
            if (key === 'p') {
                if (gameState && gameState.running) {
                    gameState.paused = !gameState.paused;
                    document.getElementById('pauseOverlay').style.display = 
                        gameState.paused ? 'block' : 'none';
                }
            }
            
            if (key === 'b' && gameState && gameState.bombs > 0) {
                useBomb();
            }
            
            // Removed Q key toggle for auto-fire.
            
            // Removed M key toggle for music.
            
            if (key === 'c') {
                insertCoin();
            }
            
            // Emergency performance reset (hidden feature)
            if (key === 'r' && keys['shift'] && gameState && gameState.running) {
                console.log('🚨 Emergency performance reset triggered!');
                
                // Clear all particles and effects
                if (particleSystem) {
                    particleSystem.particles = [];
                }
                if (gameState.particles) {
                    gameState.particles = [];
                }
                if (bulletPool) {
                    bulletPool.bullets.forEach(b => {
                        if (!b.isPlayerBullet) b.active = false;
                    });
                }
                if (enemyBulletPool) {
                    enemyBulletPool.clear();
                }
                if (epic80sExplosions) {
                    epic80sExplosions = [];
                }
                
                // Show confirmation message
                if (gameState.player) {
                    gameState.particles.push({
                        text: 'SYSTEM RESET',
                        x: config.width / 2,
                        y: config.height / 2,
                        life: 120,
                        maxLife: 120,
                        scale: 0.1,
                        active: true,
                        update() {
                            this.life--;
                            if (this.scale < 1.5) this.scale += 0.1;
                            if (this.life <= 0) this.active = false;
                        },
                        draw(ctx) {
                            const alpha = this.life / this.maxLife;
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.scale(this.scale, this.scale);
                            ctx.globalAlpha = alpha;
                            
                            ctx.font = 'bold 32px Courier New';
                            ctx.textAlign = 'center';
                            ctx.fillStyle = '#00ff00';
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = '#00ff00';
                            ctx.fillText(this.text, 0, 0);
                            
                            ctx.restore();
                        }
                    });
                }
            }
            
            resetAttractModeTimeout();
        });

        window.addEventListener('mousemove', (e) => {
            if (!gameState || !gameState.running) {
                resetAttractModeTimeout();
            }
        });

        window.addEventListener('click', (e) => {
            if (attractMode) {
                exitAttractMode();
            } else if (!gameState || !gameState.running) {
                resetAttractModeTimeout();
            }
        });

        window.addEventListener('keyup', (e) => {
            e.preventDefault();
            
            const key = e.key.toLowerCase();
            keys[key] = false;
            delete keys[key];
            
            if (e.key.startsWith('Arrow')) {
                keys[e.key] = false;
                delete keys[e.key];
            }
            
            if (e.key === ' ') {
                keys[' '] = false;
                delete keys[' '];
            }
        });

        // Touch controls setup
        function setupTouchControls() {
            const joystick = document.getElementById('touchJoystick');
            const fireBtn = document.getElementById('touchFire');
            const bombBtn = document.getElementById('touchBomb');
            
            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystick.getBoundingClientRect();
                touchJoystick.active = true;
                touchJoystick.startX = touch.clientX - rect.left - rect.width/2;
                touchJoystick.startY = touch.clientY - rect.top - rect.height/2;
            });
            
            joystick.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (touchJoystick.active) {
                    const touch = e.touches[0];
                    const rect = joystick.getBoundingClientRect();
                    touchJoystick.currentX = touch.clientX - rect.left - rect.width/2;
                    touchJoystick.currentY = touch.clientY - rect.top - rect.height/2;
                }
            });
            
            joystick.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchJoystick.active = false;
            });
            
            fireBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchButtons.fire = true;
            });
            
            fireBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchButtons.fire = false;
            });
            
            bombBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameState && gameState.bombs > 0) {
                    useBomb();
                }
            });
        }

        document.addEventListener('touchmove', (e) => {
            if (e.target.closest('#gameContainer')) {
                e.preventDefault();
            }
        }, { passive: false });
    </script>
</body>
</html>