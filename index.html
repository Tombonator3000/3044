<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometry 3044</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        // ü™ô INSERT COIN FUNCTIONS
        window.insertCoin = function() {
            credits++;
            updateCreditsDisplay();
            
            // Play coin drop sound
            if (soundSystem) {
                soundSystem.playCoinDrop();
            }
            
            // Show "THANK YOU" message briefly
            const insertCoinEl = document.getElementById('insertCoinText');
            const originalText = insertCoinEl.textContent;
            insertCoinEl.textContent = 'THANK YOU';
            insertCoinEl.style.color = '#00ff00';
            insertCoinEl.style.animation = 'none';
            
            setTimeout(() => {
                insertCoinEl.textContent = originalText;
                insertCoinEl.style.color = '#ffff00';
                insertCoinEl.style.animation = 'blink 1s ease-in-out infinite';
            }, 1500);
            
            // If on continue screen, continue the game
            if (showingContinueScreen && credits > 0) {
                continueGame();
            }
            
            resetAttractModeTimeout();
            
            // üîä VOICE: "GET READY!" n√•r spillet starter
            setTimeout(() => {
                if (soundSystem) {
                    soundSystem.playVoiceSample('GET READY');
                }
            }, 500);
        }
        
        window.finalGameOver = function() {
            showingContinueScreen = false;
            document.getElementById('continueScreen').style.display = 'none';
            
            // Show normal game over process
            if (gameState) {
                document.getElementById('finalScoreDisplay').textContent = gameState.score.toLocaleString();
                document.getElementById('finalWaveDisplay').textContent = gameState.wave;
                document.getElementById('finalComboDisplay').textContent = gameState.maxCombo;
                
                // üèÜ Check if player achieved a high score
                if (isHighScore(gameState.score)) {
                    newHighScoreIndex = getHighScorePosition(gameState.score);
                    showHighScoreEntry();
                } else {
                    // No high score, show regular game over screen
                    setTimeout(() => {
                        document.getElementById('gameOverScreen').style.display = 'flex';
                        document.getElementById('gameUI').style.display = 'none';
                    }, 500);
                }
            }
        }
        
        function showContinueScreen() {
            if (gameState) {
                const continueScoreEl = document.getElementById('continueScoreDisplay');
                if (continueScoreEl) {
                    continueScoreEl.textContent = gameState.score.toLocaleString();
                }
            }
            
            showingContinueScreen = true;
            continueTimer = maxContinueTime;
            const continueScreen = document.getElementById('continueScreen');
            const gameUI = document.getElementById('gameUI');
            
            if (continueScreen) continueScreen.style.display = 'flex';
            if (gameUI) gameUI.style.display = 'none';
            
            // üîä VOICE: "GAME OVER" n√•r continue screen vises
            setTimeout(() => {
                if (soundSystem) {
                    soundSystem.playVoiceSample('GAME OVER');
                }
            }, 200);
            
            // üîä VOICE: "CONTINUE" etter en kort pause
            setTimeout(() => {
                if (soundSystem) {
                    soundSystem.playVoiceSample('CONTINUE');
                }
            }, 2000);
            
            // Start continue countdown
            const continueCountdown = setInterval(() => {
                continueTimer--;
                const seconds = Math.ceil(continueTimer / 60);
                const timerEl = document.getElementById('continueTimerDisplay');
                
                if (timerEl) {
                    timerEl.textContent = seconds;
                    
                    // Flash red when time is running out
                    if (seconds <= 3) {
                        timerEl.style.color = '#ff0000';
                        timerEl.style.animation = 'blink 0.2s ease-in-out infinite';
                    } else {
                        timerEl.style.color = '#ffff00';
                        timerEl.style.animation = 'none';
                    }
                }
                
                if (continueTimer <= 0 || !showingContinueScreen) {
                    clearInterval(continueCountdown);
                    if (showingContinueScreen) {
                        // Time's up, show final game over
                        finalGameOver();
                    }
                }
            }, 1000/60); // 60fps countdown
        }
        
        window.updateCreditsDisplay = function() {
            const creditsEl = document.getElementById('creditsCount');
            if (creditsEl) {
                creditsEl.textContent = credits;
                
                // Update start button state
                const startBtn = document.getElementById('startGameBtn');
                if (credits > 0) {
                    startBtn.style.opacity = '1';
                    startBtn.style.pointerEvents = 'auto';
                } else {
                    startBtn.style.opacity = '0.5';
                    startBtn.style.pointerEvents = 'none';
                }
            }
        }
        
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        
        body {
            background: #000;
            color: #0ff;
            font-family: 'Courier New', monospace;
        }
        
        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            border: none;
        }
        
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        #menuScreen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        
        .logo {
            font-size: 4em;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.5em;
            text-shadow: 0 0 20px #0ff, 0 0 40px #0ff, 0 0 60px #0ff;
            animation: pulse 2s ease-in-out infinite;
        }
        
        .logo .year {
            color: #f0f;
            text-shadow: 0 0 20px #f0f, 0 0 40px #f0f;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }
        
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .btn {
            padding: 15px 40px;
            font-size: 1.2em;
            font-weight: 700;
            text-transform: uppercase;
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            cursor: pointer;
            transition: all 0.3s;
            letter-spacing: 0.1em;
            position: relative;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        
        .btn:hover {
            color: #000;
            transform: scale(1.05);
            box-shadow: 0 0 20px #0ff, inset 0 0 20px #0ff;
        }
        
        .btn:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: #0ff;
            transition: left 0.3s;
            z-index: -1;
        }
        
        .btn:hover:before {
            left: 0;
        }
        
        #gameUI {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: none;
            z-index: 5;
        }
        
        .ui-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .ui-element {
            font-size: 1.2em;
            font-weight: 700;
            text-transform: uppercase;
            text-shadow: 0 0 10px currentColor;
        }
        
        .score { color: #0ff; }
        .lives { color: #0f0; }
        .bombs { color: #ff0; }
        .wave { color: #f0f; }
        
        #highScore {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1em;
            color: #ff0;
            text-transform: uppercase;
            text-shadow: 0 0 10px #ff0;
        }
        
        .controls {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 0.9em;
            color: #0ff;
            opacity: 0.7;
        }
        
        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }
        
        #highScoreEntryScreen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 25;
        }
        
        #highScoreListScreen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 25;
        }
        
        .high-score-title {
            font-size: 3em;
            font-weight: 900;
            color: #ffff00;
            text-transform: uppercase;
            margin-bottom: 30px;
            text-shadow: 0 0 30px #ffff00;
            animation: pulse 2s ease-in-out infinite;
        }
        
        .initial-input {
            display: flex;
            gap: 20px;
            margin: 30px 0;
        }
        
        .initial-letter {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #00ffff;
            color: #00ffff;
            font-size: 2em;
            font-weight: 900;
            font-family: 'Courier New', monospace;
            text-align: center;
            text-transform: uppercase;
            box-shadow: 0 0 20px #00ffff;
            outline: none;
            cursor: text;
        }
        
        .initial-letter:focus {
            outline: none;
            border-color: #ffff00;
            color: #ffff00;
            box-shadow: 0 0 30px #ffff00;
        }
        
        .high-score-list {
            font-family: 'Courier New', monospace;
            font-size: 1.4em;
            color: #00ffff;
            text-align: center;
            margin: 20px 0;
            min-height: 400px;
        }
        
        .high-score-entry {
            display: flex;
            justify-content: space-between;
            width: 500px;
            margin: 10px 0;
            padding: 10px 20px;
            border: 1px solid #00ffff;
            background: rgba(0, 255, 255, 0.1);
        }
        
        .high-score-entry.new-entry {
            border-color: #ffff00;
            color: #ffff00;
            background: rgba(255, 255, 0, 0.2);
            text-shadow: 0 0 15px #ffff00;
            animation: flash 1s ease-in-out infinite;
        }
        
        @keyframes flash {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.6; }
        }
        
        /* ü™ô INSERT COIN BLINK ANIMATION */
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }
        
        /* ü™ô CONTINUE SCREEN STYLING */
        #continueScreen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 30;
            color: #ff0000;
            font-family: 'Courier New', monospace;
            text-align: center;
        }
        
        .continue-title {
            font-size: 3em;
            font-weight: 900;
            text-transform: uppercase;
            margin-bottom: 30px;
            text-shadow: 0 0 30px #ff0000;
            animation: pulse 1s ease-in-out infinite;
        }
        
        .continue-timer {
            font-size: 2em;
            color: #ffff00;
            margin: 20px 0;
            text-shadow: 0 0 20px #ffff00;
        }
        
        .continue-instruction {
            font-size: 1.5em;
            color: #00ff00;
            margin-bottom: 20px;
            text-shadow: 0 0 15px #00ff00;
            animation: blink 0.5s ease-in-out infinite;
        }
        
        .rank { width: 50px; text-align: left; }
        .initials { width: 80px; text-align: center; font-weight: 900; }
        .score { width: 150px; text-align: right; }
        
        @media (max-width: 768px) {
            .high-score-entry { width: 90%; }
            .high-score-title { font-size: 2em; }
        }
        
        #pauseOverlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            font-weight: 900;
            color: #ff0;
            text-shadow: 0 0 30px #ff0;
            display: none;
            z-index: 15;
            text-transform: uppercase;
        }
        
        #mobileControls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            display: none;
            z-index: 20;
            pointer-events: none;
        }
        
        .touch-button {
            position: absolute;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: #0ff;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
        }
        
        #touchJoystick {
            width: 120px;
            height: 120px;
            bottom: 20px;
            left: 20px;
        }
        
        #touchFire {
            width: 80px;
            height: 80px;
            bottom: 40px;
            right: 120px;
        }
        
        #touchBomb {
            width: 60px;
            height: 60px;
            bottom: 40px;
            right: 30px;
        }
        
        @media (max-width: 768px) {
            .logo { font-size: 3em; }
            .btn { font-size: 1em; padding: 12px 30px; }
            .ui-element { font-size: 1em; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="menuScreen">
            <h1 class="logo">Geometry <span class="year">3044</span></h1>
            <div class="menu-buttons">
                <button class="btn" onclick="startGame()" id="startGameBtn">Start Game</button>
            </div>
            
            <!-- ü™ô CREDITS & INSERT COIN DISPLAY -->
            <div id="creditsDisplay" style="position: absolute; top: 20px; right: 20px; font-family: 'Courier New', monospace; color: #00ff00; font-size: 1.2em; text-shadow: 0 0 10px #00ff00;">
                CREDITS: <span id="creditsCount">3</span>
            </div>
            
            <div id="insertCoinText" style="position: absolute; bottom: 130px; left: 50%; transform: translateX(-50%); font-family: 'Courier New', monospace; color: #ffff00; font-size: 1.4em; text-transform: uppercase; text-shadow: 0 0 15px #ffff00; animation: blink 1s ease-in-out infinite;">
                INSERT COIN
            </div>
            
            <div class="controls">
                WASD/Arrows: Move | Space: Shoot | Q: Auto-fire | B: Bomb | M: Music | P: Pause<br>
                <span style="color: #ffff00; font-weight: bold;">C: INSERT COIN</span>
            </div>
        </div>
        
        <div id="gameOverScreen">
            <h2 style="font-size: 3em; margin-bottom: 30px; text-transform: uppercase; animation: pulse 1s ease-in-out infinite; background: linear-gradient(45deg, #ff006e, #ff4e50, #fc466b, #ff006e); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-shadow: 0 0 40px #ff006e;">GAME OVER MAN, GAME OVER!</h2>
            <div style="font-size: 1.5em; color: #00ffff; margin-bottom: 20px; text-shadow: 0 0 20px #00ffff;">
                Final Score: <span id="finalScoreDisplay">0</span>
            </div>
            <div style="font-size: 1.2em; color: #ffff00; margin-bottom: 20px; text-shadow: 0 0 15px #ffff00;">
                Wave Reached: <span id="finalWaveDisplay">1</span>
            </div>
            <div style="font-size: 1.2em; color: #ff00ff; margin-bottom: 40px; text-shadow: 0 0 15px #ff00ff;">
                Max Combo: <span id="finalComboDisplay">0</span>
            </div>
            <button class="btn" onclick="restartGame()">Play Again</button>
            <button class="btn" onclick="backToMenu()" style="margin-top: 20px;">Main Menu</button>
        </div>
        
        <div id="highScoreEntryScreen">
            <div class="high-score-title">üèÜ NEW HIGH SCORE! üèÜ</div>
            <div style="font-size: 2em; color: #00ffff; margin-bottom: 20px; text-shadow: 0 0 20px #00ffff;">
                Score: <span id="newHighScoreValue">0</span>
            </div>
            <div style="font-size: 1.4em; color: #ffff00; margin-bottom: 30px; text-transform: uppercase;">
                Enter Your Initials
            </div>
            <div class="initial-input">
                <input type="text" class="initial-letter" id="initial1" maxlength="1">
                <input type="text" class="initial-letter" id="initial2" maxlength="1">
                <input type="text" class="initial-letter" id="initial3" maxlength="1">
            </div>
            <button class="btn" onclick="submitHighScore()" style="margin-top: 30px;">Submit Score</button>
            <div style="font-size: 0.9em; color: #666; margin-top: 20px;">
                Press ENTER to submit or ESC to skip
            </div>
        </div>
        
        <div id="highScoreListScreen">
            <div class="high-score-title">üèÜ HIGH SCORES üèÜ</div>
            <div class="high-score-list" id="highScoreList">
                <!-- High scores will be populated here -->
            </div>
            <button class="btn" onclick="closeHighScores()">Continue</button>
        </div>
        
        <!-- ü™ô CONTINUE SCREEN (Classic Arcade) -->
        <div id="continueScreen">
            <div class="continue-title">CONTINUE?</div>
            <div style="font-size: 1.8em; color: #00ffff; margin-bottom: 20px; text-shadow: 0 0 20px #00ffff;">
                Final Score: <span id="continueScoreDisplay">0</span>
            </div>
            <div class="continue-timer">
                <span id="continueTimerDisplay">10</span>
            </div>
            <div class="continue-instruction">
                INSERT COIN TO CONTINUE
            </div>
            <div style="font-size: 1.2em; color: #ff00ff; text-shadow: 0 0 15px #ff00ff;">
                Press C to Insert Coin
            </div>
        </div>
        
        <div id="gameUI">
            <div class="ui-row">
                <div class="ui-element score">Score: <span id="scoreDisplay">0</span></div>
                <div class="ui-element wave">Wave: <span id="waveDisplay">1</span></div>
            </div>
            <div class="ui-row">
                <div class="ui-element lives">Lives: <span id="livesDisplay">3</span></div>
                <div class="ui-element bombs">Bombs: <span id="bombsDisplay">3</span></div>
            </div>
        </div>
        
        <div id="highScore">High Score: <span id="highScoreDisplay">0</span></div>
        <div id="pauseOverlay">PAUSED</div>
        
        <div id="mobileControls">
            <div id="touchJoystick" class="touch-button">MOVE</div>
            <div id="touchFire" class="touch-button">FIRE</div>
            <div id="touchBomb" class="touch-button">BOMB</div>
        </div>
    </div>

    <script>
        // Global variables
        let canvas, ctx;
        let gameState = null;
        let keys = {};
        
        // ü™ô INSERT COIN SYSTEM (Classic Arcade)
        let credits = 3;  // Start with 3 free play credits
        let coinInsertSound = null;
        let continueTimer = 0;
        let maxContinueTime = 600; // 10 seconds at 60fps
        let showingContinueScreen = false;
        
        // ü™ô CREDITS FUNCTIONS (Define early)
        function updateCreditsDisplay() {
            const creditsEl = document.getElementById('creditsCount');
            if (creditsEl) {
                creditsEl.textContent = credits;
                
                // Update start button state
                const startBtn = document.getElementById('startGameBtn');
                if (startBtn) {
                    if (credits > 0) {
                        startBtn.style.opacity = '1';
                        startBtn.style.pointerEvents = 'auto';
                    } else {
                        startBtn.style.opacity = '0.5';
                        startBtn.style.pointerEvents = 'none';
                    }
                }
            }
        }
        
        function insertCoin() {
            credits++;
            updateCreditsDisplay();
            
            // Play coin drop sound
            if (soundSystem) {
                soundSystem.playCoinDrop();
            }
            
            // Show "THANK YOU" message briefly
            const insertCoinEl = document.getElementById('insertCoinText');
            if (insertCoinEl) {
                const originalText = insertCoinEl.textContent;
                insertCoinEl.textContent = 'THANK YOU';
                insertCoinEl.style.color = '#00ff00';
                insertCoinEl.style.animation = 'none';
                
                setTimeout(() => {
                    insertCoinEl.textContent = originalText;
                    insertCoinEl.style.color = '#ffff00';
                    insertCoinEl.style.animation = 'blink 1s ease-in-out infinite';
                }, 1500);
            }
            
            // If on continue screen, continue the game
            if (showingContinueScreen && credits > 0) {
                continueGame();
            }
            
            if (typeof resetAttractModeTimeout === 'function') {
                resetAttractModeTimeout();
            }
        }
        
        function continueGame() {
            if (credits <= 0) return;
            
            // Use credit
            credits--;
            updateCreditsDisplay();
            showingContinueScreen = false;
            
            // Hide continue screen
            const continueScreen = document.getElementById('continueScreen');
            if (continueScreen) {
                continueScreen.style.display = 'none';
            }
            
            // Restore player with reduced lives and continue from current wave
            if (gameState) {
                gameState.lives = 3; // Restore some lives
                gameState.running = true;
                gameState.paused = false;
                if (gameState.player) {
                    gameState.player.invulnerable = true;
                    gameState.player.invulnerableTimer = 180; // 3 seconds of invulnerability
                }
                
                // Clear enemy bullets
                if (enemyBulletPool) enemyBulletPool.clear();
                
                // Restart music
                if (musicEnabled && gameMusic) {
                    try {
                        gameMusic.play().catch(err => console.warn("Continue music play failed:", err));
                    } catch (error) {
                        console.warn("Music control failed:", error);
                    }
                }
                
                // Show game UI
                const gameUI = document.getElementById('gameUI');
                if (gameUI) {
                    gameUI.style.display = 'block';
                }
                
                // Restart game loop
                if (soundSystem) soundSystem.enabled = true;
                if (typeof gameLoop === 'function') gameLoop();
            }
            
            if (typeof updateUI === 'function') updateUI();
        }
        
        function finalGameOver() {
            showingContinueScreen = false;
            const continueScreen = document.getElementById('continueScreen');
            if (continueScreen) {
                continueScreen.style.display = 'none';
            }
            
            // Show normal game over process
            if (gameState) {
                const finalScoreEl = document.getElementById('finalScoreDisplay');
                const finalWaveEl = document.getElementById('finalWaveDisplay'); 
                const finalComboEl = document.getElementById('finalComboDisplay');
                
                if (finalScoreEl) finalScoreEl.textContent = gameState.score.toLocaleString();
                if (finalWaveEl) finalWaveEl.textContent = gameState.wave;
                if (finalComboEl) finalComboEl.textContent = gameState.maxCombo;
                
                // üèÜ Check if player achieved a high score
                if (typeof isHighScore === 'function' && isHighScore(gameState.score)) {
                    if (typeof getHighScorePosition === 'function') {
                        newHighScoreIndex = getHighScorePosition(gameState.score);
                    }
                    if (typeof showHighScoreEntry === 'function') {
                        showHighScoreEntry();
                    }
                } else {
                    // No high score, show regular game over screen
                    setTimeout(() => {
                        const gameOverScreen = document.getElementById('gameOverScreen');
                        const gameUI = document.getElementById('gameUI');
                        if (gameOverScreen) gameOverScreen.style.display = 'flex';
                        if (gameUI) gameUI.style.display = 'none';
                    }, 500);
                }
            }
        }
        
        // üéµ GRATIS SYNTHWAVE MUSIKK (CC Licensed)
        // üé∂ VOYAGER 1 by John Tasoulas (CC BY 3.0) - Cyberpunk menu music
        // üé∂ SUMMER NIGHTS by Vyra (CC BY-SA 3.0) - Alternative option
        // üé∂ NEON UNDERWORLD by Punch Deck (CC BY 3.0) - Intense gameplay music
        let menuMusic = null;
        let gameMusic = null;
        let musicEnabled = false;
        
        // Pr√∏v √• laste musikk, men fortsett spillet selv om det feiler
        try {
            // üé∂ VOYAGER 1 by John Tasoulas (CC BY 3.0) - Perfect for cyberpunk menu
            // TODO: Replace with actual URL to Voyager 1 track
            menuMusic = new Audio("https://archive.org/download/voyager-1-synthwave/Voyager1.mp3");
            menuMusic.loop = true;
            menuMusic.volume = 0.4; // Lower volume for menu music
            
            // üé∂ NEON UNDERWORLD by Punch Deck (CC BY 3.0) - Perfect for gameplay  
            // TODO: Replace with actual URL to Neon Underworld track
            gameMusic = new Audio("https://archive.org/download/neon-underworld-synthwave/NeonUnderworld.mp3");
            gameMusic.loop = true;
            gameMusic.volume = 0.4; // Lower volume for better gameplay
            
            // Test om musikken kan lastes
            menuMusic.addEventListener('canplaythrough', () => { 
                musicEnabled = true; 
                console.log('üéµ Synthwave music system loaded successfully!');
            });
            menuMusic.addEventListener('error', () => { 
                console.warn('üéµ Menu music failed to load - trying fallback URLs'); 
                // Fallback to original URLs if these don't work
                tryFallbackMusic();
            });
            
        } catch (error) {
            console.warn('Music system failed to initialize:', error);
            tryFallbackMusic();
        }
        
        // Fallback music URLs if the synthwave tracks don't work
        function tryFallbackMusic() {
            try {
                menuMusic = new Audio("https://raw.githubusercontent.com/Tombonator3000/temp-mp3/main/Start%20Screen%20Arcade.mp3");
                gameMusic = new Audio("https://raw.githubusercontent.com/Tombonator3000/temp-mp3/main/Pixel%20Blitz.mp3");
                menuMusic.loop = true;
                gameMusic.loop = true;
                menuMusic.volume = 0.5;
                gameMusic.volume = 0.5;
                console.log('üéµ Using fallback music URLs');
            } catch (fallbackError) {
                console.warn('üéµ All music sources failed - running without audio');
                musicEnabled = false;
            }
        }
        
        let config = {
            width: 800,  // Will be updated on resize
            height: 600, // Will be updated on resize
            colors: {
                player: '#00ff00',
                enemyTriangle: '#ff0066',
                enemySquare: '#0099ff', 
                enemyPentagon: '#00ff66',
                boss: '#ff00ff',
                bullet: '#ffff00',
                grid: '#00ffff',
                particle: '#ffffff'
            }
        };
        
        // Touch controls
        let touchJoystick = { active: false, startX: 0, startY: 0, currentX: 0, currentY: 0 };
        let touchButtons = { fire: false, bomb: false };
        
        // Game systems
        let particleSystem, bulletPool, enemyBulletPool, waveManager, soundSystem;
        let attractMode = false;
        let attractModeTimer = null;
        let attractModeAI = null;
        let bossDeathTimeoutId = null;
        let gameLoopId = null;  // Track the animation frame ID
        let musicMuted = false;  // üé∂ MUSIKK: Mute state
        
        // üåü STARFIELD BACKGROUND SYSTEM
        let starfield = null;
        
        class Starfield {
            constructor() {
                this.layers = [];
                this.nebulae = [];
                
                // Create multiple star layers for parallax effect
                for (let layer = 0; layer < 4; layer++) {
                    const stars = [];
                    const numStars = 50 - (layer * 10); // Fewer stars in distant layers
                    
                    for (let i = 0; i < numStars; i++) {
                        stars.push({
                            x: Math.random() * config.width,
                            y: Math.random() * config.height,
                            brightness: Math.random(),
                            twinkleSpeed: 0.01 + Math.random() * 0.02,
                            twinklePhase: Math.random() * Math.PI * 2,
                            size: 1 + layer * 0.5,
                            speed: 0.2 + layer * 0.3 // Closer layers move faster
                        });
                    }
                    this.layers.push(stars);
                }
                
                // Create nebula clouds
                for (let i = 0; i < 3; i++) {
                    this.nebulae.push({
                        x: Math.random() * config.width * 2,
                        y: Math.random() * config.height,
                        size: 100 + Math.random() * 200,
                        hue: Math.random() * 360,
                        speed: 0.1 + Math.random() * 0.2,
                        opacity: 0.1 + Math.random() * 0.15
                    });
                }
            }
            
            update() {
                // Update stars with parallax scrolling
                this.layers.forEach((layer, layerIndex) => {
                    layer.forEach(star => {
                        star.y += star.speed;
                        star.twinklePhase += star.twinkleSpeed;
                        
                        // Wrap around when star goes off screen
                        if (star.y > config.height + 10) {
                            star.y = -10;
                            star.x = Math.random() * config.width;
                        }
                    });
                });
                
                // Update nebulae
                this.nebulae.forEach(nebula => {
                    nebula.y += nebula.speed;
                    nebula.hue += 0.1; // Slowly shift colors
                    
                    if (nebula.y > config.height + nebula.size) {
                        nebula.y = -nebula.size;
                        nebula.x = Math.random() * config.width * 2 - config.width;
                    }
                });
            }
            
            draw(ctx) {
                ctx.save();
                
                // Draw nebulae first (background)
                this.nebulae.forEach(nebula => {
                    const gradient = ctx.createRadialGradient(
                        nebula.x, nebula.y, 0,
                        nebula.x, nebula.y, nebula.size
                    );
                    gradient.addColorStop(0, `hsla(${nebula.hue}, 70%, 50%, ${nebula.opacity})`);
                    gradient.addColorStop(0.5, `hsla(${nebula.hue + 30}, 60%, 40%, ${nebula.opacity * 0.5})`);
                    gradient.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(nebula.x, nebula.y, nebula.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Draw star layers (foreground to background)
                this.layers.forEach((layer, layerIndex) => {
                    layer.forEach(star => {
                        const twinkle = Math.sin(star.twinklePhase) * 0.3 + 0.7;
                        const alpha = star.brightness * twinkle * (0.4 + layerIndex * 0.2);
                        
                        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                        ctx.shadowBlur = star.size * 2;
                        ctx.shadowColor = `rgba(200, 220, 255, ${alpha * 0.8})`;
                        
                        ctx.beginPath();
                        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add star cross effect for brighter stars
                        if (star.brightness > 0.7 && twinkle > 0.8) {
                            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.6})`;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(star.x - star.size * 3, star.y);
                            ctx.lineTo(star.x + star.size * 3, star.y);
                            ctx.moveTo(star.x, star.y - star.size * 3);
                            ctx.lineTo(star.x, star.y + star.size * 3);
                            ctx.stroke();
                        }
                    });
                });
                
                ctx.restore();
            }
            
            resize(width, height) {
                // Redistribute stars when screen resizes
                this.layers.forEach(layer => {
                    layer.forEach(star => {
                        if (star.x > width) star.x = Math.random() * width;
                        if (star.y > height) star.y = Math.random() * height;
                    });
                });
                
                this.nebulae.forEach(nebula => {
                    if (nebula.x > width * 2) nebula.x = Math.random() * width * 2;
                    if (nebula.y > height) nebula.y = Math.random() * height;
                });
            }
        }
        
        // üõ∏ FORMATION FLYING ENEMIES SYSTEM (Galaga Style)
        let formationManager = null;
        
        class FormationManager {
            constructor() {
                this.formations = [];
                this.formationTimer = 0;
                this.formationSpawnRate = 300; // Spawn formation every 5 seconds
            }
            
            update() {
                this.formationTimer++;
                
                // Spawn new formations occasionally
                if (this.formationTimer > this.formationSpawnRate && Math.random() < 0.3) {
                    this.spawnFormation();
                    this.formationTimer = 0;
                }
                
                // Update existing formations
                this.formations.forEach(formation => {
                    if (formation.active) {
                        formation.update();
                    }
                });
                
                // Clean up inactive formations
                this.formations = this.formations.filter(f => f.active);
            }
            
            spawnFormation() {
                if (!gameState || gameState.enemies.length > 12) return; // Don't overcrowd
                
                const formationTypes = ['vee', 'sine_wave', 'dive_bomber'];
                const type = formationTypes[Math.floor(Math.random() * formationTypes.length)];
                
                let formation;
                switch(type) {
                    case 'vee':
                        formation = new VeeFormation();
                        break;
                    case 'sine_wave':
                        formation = new SineWaveFormation();
                        break;
                    case 'dive_bomber':
                        formation = new DiveBomberFormation();
                        break;
                }
                
                if (formation) {
                    this.formations.push(formation);
                }
            }
        }
        
        // üõ∏ V-FORMATION (Classic Galaga Style)
        class VeeFormation {
            constructor() {
                this.active = true;
                this.enemies = [];
                this.leaderId = null;
                this.centerX = Math.random() * (config.width - 200) + 100;
                this.y = -100;
                this.speed = 2;
                this.formationTimer = 0;
                
                // Create formation - leader + 4 followers
                const leaderEnemy = new Enemy(this.centerX, this.y, 'square');
                leaderEnemy.isFormationLeader = true;
                leaderEnemy.formationBonus = 500; // Extra points for leader
                leaderEnemy.color = '#ffaa00'; // Gold color for leader
                leaderEnemy.points = 400;
                this.leaderId = leaderEnemy;
                gameState.enemies.push(leaderEnemy);
                this.enemies.push(leaderEnemy);
                
                // Add formation followers
                for (let i = 1; i <= 4; i++) {
                    const side = i % 2 === 1 ? -1 : 1;
                    const distance = Math.ceil(i / 2) * 40;
                    const follower = new Enemy(
                        this.centerX + (side * distance),
                        this.y - (Math.ceil(i / 2) * 30),
                        'triangle'
                    );
                    follower.isFormationFollower = true;
                    follower.formationLeader = leaderEnemy;
                    follower.formationOffset = { x: side * distance, y: -(Math.ceil(i / 2) * 30) };
                    follower.points = 150; // Bonus for formation enemies
                    gameState.enemies.push(follower);
                    this.enemies.push(follower);
                }
                
                // üîä VOICE: "GET READY!" for challenging formation
                setTimeout(() => {
                    if (soundSystem) {
                        soundSystem.playVoiceSample('GET READY');
                    }
                }, 500);
            }
            
            update() {
                this.formationTimer++;
                
                // Move the formation as a unit
                if (this.leaderId && this.leaderId.active) {
                    this.leaderId.y += this.speed;
                    
                    // Update followers to maintain formation
                    this.enemies.forEach(enemy => {
                        if (enemy.isFormationFollower && enemy.active) {
                            enemy.x = this.leaderId.x + enemy.formationOffset.x;
                            enemy.y = this.leaderId.y + enemy.formationOffset.y;
                        }
                    });
                    
                    // Formation movement pattern
                    if (this.formationTimer > 60) {
                        this.leaderId.x += Math.sin(this.formationTimer * 0.02) * 2;
                    }
                } else {
                    // Leader destroyed - scatter formation
                    this.enemies.forEach(enemy => {
                        if (enemy.isFormationFollower && enemy.active) {
                            enemy.behavior = 'aggressive';
                            enemy.isFormationFollower = false;
                            enemy.speed += 1; // Speed up scattered enemies
                        }
                    });
                    this.active = false;
                }
                
                // Check if formation is off screen
                if (this.leaderId && this.leaderId.y > config.height + 100) {
                    this.active = false;
                }
                
                // Clean up destroyed enemies
                this.enemies = this.enemies.filter(e => e.active);
                if (this.enemies.length === 0) {
                    this.active = false;
                }
            }
        }
        
        // üõ∏ SINE WAVE FORMATION (Galaga Signature Move)
        class SineWaveFormation {
            constructor() {
                this.active = true;
                this.enemies = [];
                this.wavePhase = 0;
                this.y = -50;
                
                // Create sine wave formation
                for (let i = 0; i < 6; i++) {
                    const enemy = new Enemy(
                        50 + i * 120,
                        this.y - (i * 15),
                        i === 0 ? 'pentagon' : 'triangle'
                    );
                    enemy.sineWaveIndex = i;
                    enemy.sineWavePhase = i * (Math.PI / 3);
                    enemy.baseSineY = enemy.y;
                    enemy.behavior = 'sine_wave';
                    enemy.points = i === 0 ? 400 : 120;
                    if (i === 0) {
                        enemy.color = '#ff6600';
                        enemy.isFormationLeader = true;
                    }
                    gameState.enemies.push(enemy);
                    this.enemies.push(enemy);
                }
            }
            
            update() {
                this.wavePhase += 0.05;
                
                this.enemies.forEach(enemy => {
                    if (enemy.active) {
                        enemy.y += 1.5;
                        enemy.x += Math.sin(this.wavePhase + enemy.sineWavePhase) * 3;
                    }
                });
                
                // Clean up
                this.enemies = this.enemies.filter(e => e.active);
                if (this.enemies.length === 0 || (this.enemies[0] && this.enemies[0].y > config.height + 100)) {
                    this.active = false;
                }
            }
        }
        
        // üõ∏ DIVE BOMBER FORMATION (Kamikaze Attack)
        class DiveBomberFormation {
            constructor() {
                this.active = true;
                this.enemies = [];
                this.diveTimer = 180; // 3 seconds before dive
                this.hasDived = false;
                
                // Create formation at top
                for (let i = 0; i < 3; i++) {
                    const enemy = new Enemy(
                        config.width / 2 + (i - 1) * 80,
                        -50 - (i * 20),
                        'square'
                    );
                    enemy.behavior = 'formation_hold';
                    enemy.diveIndex = i;
                    enemy.points = 200;
                    enemy.color = '#ff0088';
                    enemy.isDiveBomber = true;
                    gameState.enemies.push(enemy);
                    this.enemies.push(enemy);
                }
                
                // üîä VOICE: Warning for incoming dive bombers
                setTimeout(() => {
                    if (soundSystem) {
                        soundSystem.playVoiceSample('OUTSTANDING');
                    }
                }, 200);
            }
            
            update() {
                this.diveTimer--;
                
                if (!this.hasDived && this.diveTimer <= 0) {
                    // Execute dive bomb attack!
                    this.enemies.forEach((enemy, index) => {
                        if (enemy.active && gameState.player) {
                            setTimeout(() => {
                                if (enemy.active) {
                                    enemy.behavior = 'kamikaze';
                                    enemy.speed = 6;
                                    enemy.targetX = gameState.player.x;
                                    enemy.targetY = gameState.player.y + 200;
                                }
                            }, index * 200); // Staggered dive
                        }
                    });
                    this.hasDived = true;
                }
                
                // Formation holding pattern before dive
                if (!this.hasDived) {
                    this.enemies.forEach(enemy => {
                        if (enemy.active) {
                            enemy.y = Math.max(-30, enemy.y + 0.5);
                            enemy.x += Math.sin(Date.now() * 0.001 + enemy.diveIndex) * 1;
                        }
                    });
                }
                
                // Clean up
                this.enemies = this.enemies.filter(e => e.active);
                if (this.enemies.length === 0) {
                    this.active = false;
                }
            }
        }
        
        // üèÜ HIGHSCORE SYSTEM (1980s Arcade Style)
        let newHighScoreIndex = -1;  // Track which position the new score is at
        let highScoreFromAttractMode = false;  // Track if highscore was accessed from attract mode
        
        // Get high scores from localStorage
        function getHighScores() {
            try {
                const scores = localStorage.getItem('geometryHighScores');
                if (scores) {
                    return JSON.parse(scores);
                }
            } catch (error) {
                console.warn('Error loading high scores:', error);
            }
            
            // Default high scores (classic arcade style)
            return [
                { initials: 'ACE', score: 50000, wave: 5 },
                { initials: 'MAX', score: 40000, wave: 4 },
                { initials: 'ZAP', score: 30000, wave: 3 },
                { initials: 'NEO', score: 25000, wave: 3 },
                { initials: 'DOT', score: 20000, wave: 2 },
                { initials: 'BIT', score: 15000, wave: 2 },
                { initials: 'HEX', score: 10000, wave: 1 },
                { initials: 'CPU', score: 8000, wave: 1 },
                { initials: 'RAM', score: 5000, wave: 1 },
                { initials: 'ROM', score: 2000, wave: 1 }
            ];
        }
        
        // Save high scores to localStorage
        function saveHighScores(scores) {
            try {
                localStorage.setItem('geometryHighScores', JSON.stringify(scores));
            } catch (error) {
                console.warn('Error saving high scores:', error);
            }
        }
        
        // Check if score qualifies for high score list
        function isHighScore(score) {
            const highScores = getHighScores();
            return score > highScores[highScores.length - 1].score;
        }
        
        // Get high score position (0-based index)
        function getHighScorePosition(score) {
            const highScores = getHighScores();
            for (let i = 0; i < highScores.length; i++) {
                if (score > highScores[i].score) {
                    return i;
                }
            }
            return -1;
        }
        
        // Sound System
        class SoundSystem {
            constructor() {
                this.enabled = true;
                this.audioContext = null;
                
                try {
                    window.AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.audioContext = new AudioContext();
                } catch (e) {
                    console.log('Web Audio API not supported');
                    this.enabled = false;
                }
            }
            
            playShoot() {
                if (!this.enabled || !this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(400, this.audioContext.currentTime + 0.1);
                
                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.1);
            }
            
            playExplosion() {
                if (!this.enabled || !this.audioContext) return;
                
                const noise = this.audioContext.createBufferSource();
                const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.2, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < buffer.length; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                noise.buffer = buffer;
                
                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(1000, this.audioContext.currentTime);
                filter.frequency.exponentialRampToValueAtTime(100, this.audioContext.currentTime + 0.2);
                
                const gainNode = this.audioContext.createGain();
                gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                
                noise.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                noise.start();
            }
            
            playPowerUp() {
                if (!this.enabled || !this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(400, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.2);
                
                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.2);
            }
            
            // üö´ Fjernet: playDash() metode
            
            playCombo(comboLevel) {
                if (!this.enabled || !this.audioContext) return;
                
                const baseFreq = 300 + (comboLevel * 50);
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(baseFreq, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(baseFreq * 2, this.audioContext.currentTime + 0.1);
                
                gainNode.gain.setValueAtTime(0.08, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.1);
            }
            
            // ü™ô COIN DROP SOUND (Classic Arcade)
            playCoinDrop() {
                if (!this.enabled || !this.audioContext) return;
                
                // Create the classic coin drop sound - two quick metallic tones
                const oscillator1 = this.audioContext.createOscillator();
                const oscillator2 = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator1.connect(gainNode);
                oscillator2.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator1.type = 'sine';
                oscillator2.type = 'sine';
                
                // First "ding"
                oscillator1.frequency.setValueAtTime(800, this.audioContext.currentTime);
                oscillator1.frequency.exponentialRampToValueAtTime(600, this.audioContext.currentTime + 0.1);
                
                // Second "ding" (slightly delayed)
                oscillator2.frequency.setValueAtTime(700, this.audioContext.currentTime + 0.15);
                oscillator2.frequency.exponentialRampToValueAtTime(500, this.audioContext.currentTime + 0.25);
                
                gainNode.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                
                oscillator1.start();
                oscillator1.stop(this.audioContext.currentTime + 0.1);
                
                oscillator2.start(this.audioContext.currentTime + 0.15);
                oscillator2.stop(this.audioContext.currentTime + 0.25);
            }
            
            // üîä VOICE SAMPLES SYSTEM (8-bit Synthesized Speech)
            playVoiceSample(message) {
                if (!this.enabled || !this.audioContext) return;
                
                // Different voice patterns for different messages
                const voicePatterns = {
                    'GET READY': [
                        {freq: 150, duration: 0.2, type: 'sawtooth'},
                        {freq: 200, duration: 0.15, type: 'sawtooth'},
                        {freq: 180, duration: 0.25, type: 'sawtooth'}
                    ],
                    'EXCELLENT': [
                        {freq: 220, duration: 0.18, type: 'square'},
                        {freq: 180, duration: 0.12, type: 'square'},
                        {freq: 200, duration: 0.15, type: 'square'},
                        {freq: 160, duration: 0.2, type: 'square'}
                    ],
                    'OUTSTANDING': [
                        {freq: 200, duration: 0.15, type: 'sawtooth'},
                        {freq: 250, duration: 0.12, type: 'sawtooth'},
                        {freq: 180, duration: 0.18, type: 'sawtooth'},
                        {freq: 220, duration: 0.15, type: 'sawtooth'}
                    ],
                    'PERFECT': [
                        {freq: 250, duration: 0.18, type: 'triangle'},
                        {freq: 200, duration: 0.15, type: 'triangle'},
                        {freq: 180, duration: 0.2, type: 'triangle'}
                    ],
                    'GAME OVER': [
                        {freq: 120, duration: 0.3, type: 'sawtooth'},
                        {freq: 100, duration: 0.25, type: 'sawtooth'},
                        {freq: 80, duration: 0.4, type: 'sawtooth'}
                    ],
                    'RADICAL': [
                        {freq: 220, duration: 0.15, type: 'square'},
                        {freq: 200, duration: 0.12, type: 'square'},
                        {freq: 180, duration: 0.18, type: 'square'}
                    ],
                    'CONTINUE': [
                        {freq: 180, duration: 0.2, type: 'triangle'},
                        {freq: 200, duration: 0.15, type: 'triangle'},
                        {freq: 160, duration: 0.25, type: 'triangle'}
                    ]
                };
                
                const pattern = voicePatterns[message];
                if (!pattern) return;
                
                let currentTime = this.audioContext.currentTime;
                
                pattern.forEach((segment, index) => {
                    setTimeout(() => {
                        if (!this.enabled || !this.audioContext) return;
                        
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        const filter = this.audioContext.createBiquadFilter();
                        
                        oscillator.connect(filter);
                        filter.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        oscillator.type = segment.type;
                        oscillator.frequency.setValueAtTime(segment.freq, this.audioContext.currentTime);
                        
                        // Add slight frequency modulation for robotic effect
                        oscillator.frequency.linearRampToValueAtTime(
                            segment.freq * 0.95, 
                            this.audioContext.currentTime + segment.duration * 0.5
                        );
                        oscillator.frequency.linearRampToValueAtTime(
                            segment.freq * 1.02, 
                            this.audioContext.currentTime + segment.duration
                        );
                        
                        // Low-pass filter for 8-bit quality
                        filter.type = 'lowpass';
                        filter.frequency.setValueAtTime(1200, this.audioContext.currentTime);
                        
                        // Volume envelope
                        gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                        gainNode.gain.linearRampToValueAtTime(0.12, this.audioContext.currentTime + 0.02);
                        gainNode.gain.linearRampToValueAtTime(0.08, this.audioContext.currentTime + segment.duration * 0.8);
                        gainNode.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + segment.duration);
                        
                        oscillator.start(this.audioContext.currentTime);
                        oscillator.stop(this.audioContext.currentTime + segment.duration);
                        
                    }, index * 150); // Slight delay between segments
                });
                
                // üîä VOICE: Visual feedback - show message on screen briefly
                this.showVoiceMessage(message);
            }
            
            // üîä VOICE: Visual feedback system
            showVoiceMessage(message) {
                // Create a temporary visual element for the voice message
                if (typeof gameState !== 'undefined' && gameState && gameState.particles) {
                    const voiceParticle = {
                        x: config.width / 2,
                        y: 80,
                        message: message,
                        life: 120, // 2 seconds at 60fps
                        maxLife: 120,
                        scale: 0.8,
                        alpha: 1,
                        active: true,
                        update() {
                            this.life--;
                            if (this.life < 30) {
                                this.alpha -= 0.03;
                            }
                            if (this.life <= 0) this.active = false;
                        },
                        draw(ctx) {
                            if (!this.active) return;
                            
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.scale(this.scale, this.scale);
                            
                            ctx.font = 'bold 24px Courier New';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            
                            // Voice message styling - different colors for different messages
                            let color = '#00ff00';
                            if (this.message === 'EXCELLENT' || this.message === 'RADICAL') color = '#ffff00';
                            if (this.message === 'OUTSTANDING') color = '#ff00ff';
                            if (this.message === 'PERFECT') color = '#00ffff';
                            if (this.message === 'GAME OVER') color = '#ff0000';
                            
                            ctx.fillStyle = color;
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = color;
                            ctx.globalAlpha = this.alpha;
                            
                            // Add speech bubble effect
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 2;
                            ctx.strokeText(`"${this.message}!"`, 0, 0);
                            ctx.fillText(`"${this.message}!"`, 0, 0);
                            
                            ctx.restore();
                        }
                    };
                    
                    gameState.particles.push(voiceParticle);
                }
            }
        }

        // Radical Slang System
        class RadicalSlang {
            constructor() {
                this.phrases = [
                    { text: "RADICAL!", minCombo: 3 },
                    { text: "TUBULAR!", minCombo: 5 },
                    { text: "GNARLY!", minCombo: 8 },
                    { text: "BODACIOUS!", minCombo: 12 },
                    { text: "WICKED!", minCombo: 15 },
                    { text: "AWESOME!", minCombo: 20 },
                    { text: "RIGHTEOUS!", minCombo: 25 },
                    { text: "GROOVY!", minCombo: 30 },
                    { text: "FAR OUT!", minCombo: 40 }
                ];
                this.activeText = null;
                this.x = config.width / 2;
                this.y = config.height / 2;
                this.scale = 0;
                this.alpha = 0;
                this.lifetime = 0;
            }
            
            trigger(combo) {
                for (let i = this.phrases.length - 1; i >= 0; i--) {
                    if (combo >= this.phrases[i].minCombo) {
                        this.activeText = this.phrases[i].text;
                        this.scale = 0.5;
                        this.alpha = 1;
                        this.lifetime = 60;
                        this.x = config.width / 2 + (Math.random() - 0.5) * 100;
                        this.y = config.height / 2 + (Math.random() - 0.5) * 100;
                        
                        // üîä VOICE: Trigger voice samples for high-tier radical phrases
                        if (soundSystem && combo >= 25) {
                            setTimeout(() => soundSystem.playVoiceSample('RADICAL'), 100);
                        }
                        
                        break;
                    }
                }
            }
            
            update() {
                if (this.lifetime > 0) {
                    this.lifetime--;
                    this.scale += 0.02;
                    if (this.lifetime < 20) {
                        this.alpha -= 0.05;
                    }
                }
            }
            
            draw(ctx) {
                if (this.lifetime > 0 && this.activeText) {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.scale(this.scale, this.scale);
                    ctx.rotate(Math.sin(this.lifetime * 0.1) * 0.1);
                    
                    ctx.font = 'bold 48px Courier New';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    const gradient = ctx.createLinearGradient(-100, 0, 100, 0);
                    gradient.addColorStop(0, '#ff00ff');
                    gradient.addColorStop(0.5, '#00ffff');
                    gradient.addColorStop(1, '#ffff00');
                    
                    ctx.fillStyle = gradient;
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = this.alpha;
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#ff00ff';
                    
                    ctx.strokeText(this.activeText, 0, 0);
                    ctx.fillText(this.activeText, 0, 0);
                    
                    ctx.restore();
                }
                
                // üõ∏ Formation bonus indicator during gameplay
                if (formationManager && formationManager.formations.length > 0 && !attractMode) {
                    ctx.save();
                    ctx.font = 'bold 16px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = '#ff8800';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff8800';
                    ctx.globalAlpha = 0.8 + Math.sin(Date.now() * 0.01) * 0.2;
                    
                    let formationText = 'FORMATION ACTIVE';
                    let leadersCount = 0;
                    formationManager.formations.forEach(f => {
                        if (f.leaderId && f.leaderId.active) leadersCount++;
                    });
                    
                    if (leadersCount > 0) {
                        formationText += ` - ${leadersCount} LEADER${leadersCount > 1 ? 'S' : ''}`;
                    }
                    
                    ctx.fillText(formationText, config.width / 2, 50);
                    ctx.restore();
                }
            }
        }

        // Particle Classes  
        class Particle {
            constructor(x, y, vx, vy, color) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = 30;
                this.maxLife = 30;
                this.size = Math.random() * 3 + 1;
                this.active = true;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life--;
                
                if (this.life <= 0) {
                    this.active = false;
                }
            }
            
            draw(ctx) {
                const alpha = this.life / this.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class MuzzleParticle extends Particle {
            constructor(x, y, vx, vy, color) {
                super(x, y, vx, vy, color);
                this.life = 10;
                this.maxLife = 10;
                this.size = 2;
            }
        }

        // Score Popup Class with improved visuals
        class ScorePopup {
            constructor(x, y, score, color, isCombo = false) {
                this.x = x;
                this.y = y;
                this.score = score;
                this.color = color;
                this.life = 60;
                this.maxLife = 60;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = -3;
                this.scale = isCombo ? 1 : 0.5;
                this.targetScale = isCombo ? 1.5 : 1;
                this.active = true;
                this.isCombo = isCombo;
            }
            
            update() {
                if (!this.active) return;
                
                this.life--;
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.1;
                
                if (this.life > 50) {
                    this.scale += (this.targetScale - this.scale) * 0.2;
                } else {
                    this.scale *= 0.98;
                }
                
                if (this.life <= 0) {
                    this.active = false;
                }
            }
            
            draw(ctx) {
                if (!this.active) return;
                
                const alpha = this.life / this.maxLife;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.scale, this.scale);
                
                ctx.font = this.isCombo ? 'bold 32px Courier New' : 'bold 24px Courier New';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.color;
                ctx.globalAlpha = alpha;
                
                // Gradient text for combo scores
                if (this.isCombo) {
                    const gradient = ctx.createLinearGradient(-50, 0, 50, 0);
                    gradient.addColorStop(0, '#ffff00');
                    gradient.addColorStop(0.5, this.color);
                    gradient.addColorStop(1, '#ff00ff');
                    ctx.fillStyle = gradient;
                } else {
                    ctx.fillStyle = '#ffffff';
                }
                
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.strokeText(`+${this.score}`, 0, 0);
                ctx.fillText(`+${this.score}`, 0, 0);
                
                ctx.restore();
            }
        }

        // Player Class
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.speed = 5.5; // üöÄ √òkt med 10% (fra 5 til 5.5)
                this.size = 20;
                this.color = config.colors.player;
                this.weaponLevel = 1;
                this.fireRate = 10;
                this.fireTimer = 0;
                this.invulnerable = false;
                this.invulnerableTimer = 0;
                this.shield = 0;
                this.shieldActive = false;
                this.autoFire = false;
                // üö´ Fjernet: dashCooldown, isDashing, dashDirection, dashTimer, lastKeyPress
            }
            
            update() {
                // üö´ Fjernet: All dash-logikk
                
                // Normal movement (now faster!)
                let dx = 0, dy = 0;
                
                if (keys['ArrowLeft'] === true || keys['a'] === true) dx -= this.speed;
                if (keys['ArrowRight'] === true || keys['d'] === true) dx += this.speed;
                if (keys['ArrowUp'] === true || keys['w'] === true) dy -= this.speed;
                if (keys['ArrowDown'] === true || keys['s'] === true) dy += this.speed;
                
                if (touchJoystick.active) {
                    const touchDx = touchJoystick.currentX - touchJoystick.startX;
                    const touchDy = touchJoystick.currentY - touchJoystick.startY;
                    const dist = Math.sqrt(touchDx * touchDx + touchDy * touchDy);
                    if (dist > 10) {
                        dx += (touchDx / dist) * this.speed;
                        dy += (touchDy / dist) * this.speed;
                    }
                }
                
                if (dx !== 0 && dy !== 0) {
                    dx *= 0.707;
                    dy *= 0.707;
                }
                
                this.x = Math.max(this.size, Math.min(config.width - this.size, this.x + dx));
                this.y = Math.max(this.size, Math.min(config.height - this.size, this.y + dy));
                
                // üö´ Fjernet: dash cooldown update
                
                // Handle shooting
                this.fireTimer++;
                if ((keys[' '] === true || touchButtons.fire || this.autoFire) && this.fireTimer > this.fireRate) {
                    this.shoot();
                    this.fireTimer = 0;
                }
                
                if (this.invulnerable) {
                    this.invulnerableTimer--;
                    if (this.invulnerableTimer <= 0) {
                        this.invulnerable = false;
                    }
                }
            }
            
            // üö´ Fjernet: dash() metode
            
            shoot() {
                switch(this.weaponLevel) {
                    case 1:
                        if (bulletPool) bulletPool.get(this.x, this.y - 20, 0, -10, true);
                        break;
                    case 2:
                        if (bulletPool) {
                            bulletPool.get(this.x - 10, this.y - 20, 0, -10, true);
                            bulletPool.get(this.x + 10, this.y - 20, 0, -10, true);
                        }
                        break;
                    case 3:
                        if (bulletPool) {
                            bulletPool.get(this.x, this.y - 20, 0, -10, true);
                            bulletPool.get(this.x - 15, this.y - 20, -2, -10, true);
                            bulletPool.get(this.x + 15, this.y - 20, 2, -10, true);
                        }
                        break;
                }
                
                if (particleSystem) {
                    particleSystem.addMuzzleFlash(this.x, this.y - 20, -Math.PI/2, this.color);
                }
                if (soundSystem) {
                    soundSystem.playShoot();
                }
            }
            
            takeDamage() {
                if (this.invulnerable) return false;
                
                if (this.shieldActive && this.shield > 0) {
                    this.shield--;
                    if (this.shield <= 0) {
                        this.shieldActive = false;
                    }
                    return false;
                }
                
                this.invulnerable = true;
                this.invulnerableTimer = 120;
                return true;
            }
            
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.shadowBlur = 30;
                ctx.shadowColor = this.color;
                ctx.globalAlpha = 0.9;
                
                ctx.beginPath();
                ctx.moveTo(0, -20);
                ctx.lineTo(-15, 20);
                ctx.lineTo(0, 10);
                ctx.lineTo(15, 20);
                ctx.closePath();
                ctx.stroke();
                
                ctx.fillStyle = this.color + '44';
                ctx.fill();
                
                ctx.globalAlpha = 1;
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.stroke();
                
                if (this.weaponLevel > 1) {
                    ctx.fillStyle = '#ffff00';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffff00';
                    for (let i = 0; i < this.weaponLevel - 1; i++) {
                        ctx.beginPath();
                        ctx.arc(-10 + i * 10, -25, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                if (this.shieldActive && this.shield > 0) {
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#00ffff';
                    ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.01) * 0.3;
                    ctx.beginPath();
                    ctx.arc(0, 0, 35, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Auto-fire indicator
                if (this.autoFire) {
                    ctx.fillStyle = '#00ff00';
                    ctx.font = 'bold 10px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText('AUTO', 0, -35);
                }
                
                ctx.restore();
            }
        }

        // Enemy Class  
        class Enemy {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.active = true;
                this.rotation = 0;
                this.moveTimer = 0;
                this.fireTimer = 0;
                this.glowPulse = 0;
                
                const currentWave = (gameState && gameState.wave) ? gameState.wave : 1;
                
                switch(type) {
                    case 'triangle':
                        this.sides = 3;
                        this.size = 15;
                        this.hp = 1;
                        this.speed = 3.5 + (currentWave * 0.2);
                        this.points = 100;
                        this.fireRate = 90;
                        this.bulletSpeed = 5;
                        this.color = '#ff0066';
                        this.behavior = 'aggressive';
                        break;
                    case 'square':
                        this.sides = 4;
                        this.size = 20;
                        this.hp = 2;
                        this.speed = 2.5 + (currentWave * 0.15);
                        this.points = 200;
                        this.fireRate = 60;
                        this.bulletSpeed = 6;
                        this.color = '#0099ff';
                        this.behavior = 'zigzag';
                        this.zigzagTimer = 0;
                        break;
                    case 'pentagon':
                        this.sides = 5;
                        this.size = 25;
                        this.hp = 3;
                        this.speed = 2 + (currentWave * 0.1);
                        this.points = 300;
                        this.fireRate = 40;
                        this.bulletSpeed = 7;
                        this.color = '#00ff66';
                        this.behavior = 'chaser';
                        break;
                }
            }
            
            update() {
                if (!this.active) return;
                
                this.moveTimer++;
                this.fireTimer++;
                this.rotation += 0.02;
                this.glowPulse += 0.05;
                
                switch(this.behavior) {
                    case 'aggressive':
                        this.y += this.speed;
                        if (gameState && gameState.player) {
                            const dx = gameState.player.x - this.x;
                            this.x += Math.sign(dx) * Math.min(2, Math.abs(dx * 0.02));
                        }
                        break;
                        
                    case 'zigzag':
                        this.y += this.speed;
                        this.zigzagTimer += 0.1;
                        this.x += Math.sin(this.zigzagTimer) * 4;
                        break;
                        
                    case 'chaser':
                        if (gameState && gameState.player) {
                            const dx = gameState.player.x - this.x;
                            const dy = gameState.player.y - this.y;
                            const angle = Math.atan2(dy, dx);
                            this.x += Math.cos(angle) * this.speed;
                            this.y += Math.sin(angle) * this.speed * 0.7;
                        } else {
                            this.y += this.speed;
                        }
                        break;
                        
                    // üõ∏ NEW FORMATION BEHAVIORS
                    case 'formation_hold':
                        // Stay in position (handled by formation manager)
                        break;
                        
                    case 'sine_wave':
                        // Handled in SineWaveFormation
                        break;
                        
                    case 'kamikaze':
                        // Dive bomb toward target
                        if (this.targetX !== undefined && this.targetY !== undefined) {
                            const dx = this.targetX - this.x;
                            const dy = this.targetY - this.y;
                            const angle = Math.atan2(dy, dx);
                            this.x += Math.cos(angle) * this.speed;
                            this.y += Math.sin(angle) * this.speed;
                            this.rotation += 0.1; // Spin while diving
                        } else {
                            this.y += this.speed * 1.5;
                        }
                        break;
                        
                    default:
                        this.y += this.speed;
                }
                
                if (this.fireTimer > this.fireRate) {
                    this.shoot();
                    const currentWave = (gameState && gameState.wave) ? gameState.wave : 1;
                    if (Math.random() < 0.3 + (currentWave * 0.05)) {
                        setTimeout(() => {
                            if (this.active) this.shoot();
                        }, 150);
                    }
                    this.fireTimer = 0;
                }
                
                if (this.y > config.height + 50 || this.x < -50 || this.x > config.width + 50) {
                    this.active = false;
                }
            }
            
            shoot() {
                if (!gameState || !gameState.player) return;
                
                const dx = gameState.player.x - this.x;
                const dy = gameState.player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    const vx = (dx / dist) * this.bulletSpeed;
                    const vy = (dy / dist) * this.bulletSpeed;
                    if (enemyBulletPool) {
                        enemyBulletPool.get(this.x, this.y, vx, vy, false);
                    }
                }
            }
            
            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) {
                    this.active = false;
                }
            }
            
            draw(ctx) {
                if (!this.active) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                const pulseIntensity = Math.sin(this.glowPulse) * 0.3 + 0.7;
                
                // üõ∏ FORMATION LEADER SPECIAL EFFECTS
                if (this.isFormationLeader) {
                    // Extra glow for formation leaders
                    ctx.shadowBlur = 40 + (pulseIntensity * 30);
                    ctx.shadowColor = this.color;
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 4;
                    
                    // Rotating crown effect
                    ctx.save();
                    ctx.rotate(this.glowPulse * 0.5);
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 * i) / 8;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(angle) * (this.size + 15), Math.sin(angle) * (this.size + 15));
                        ctx.stroke();
                    }
                    ctx.restore();
                } else if (this.isDiveBomber && this.behavior === 'kamikaze') {
                    // Flame trail effect for dive bombers
                    ctx.save();
                    ctx.translate(0, -this.size);
                    for (let i = 0; i < 5; i++) {
                        ctx.fillStyle = `hsla(${20 + i * 10}, 100%, ${70 - i * 10}%, ${0.8 - i * 0.15})`;
                        ctx.beginPath();
                        ctx.arc(
                            (Math.random() - 0.5) * 10, 
                            -i * 8, 
                            3 + i, 
                            0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                    ctx.restore();
                } else {
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 30 + (pulseIntensity * 20);
                    ctx.shadowColor = this.color;
                }
                
                ctx.globalAlpha = 0.8;
                
                ctx.beginPath();
                for (let i = 0; i < this.sides; i++) {
                    const angle = (Math.PI * 2 * i) / this.sides - Math.PI / 2;
                    const x = Math.cos(angle) * this.size;
                    const y = Math.sin(angle) * this.size;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
                
                ctx.fillStyle = this.color + '44';
                ctx.fill();
                
                ctx.globalAlpha = pulseIntensity;
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.stroke();
                
                // üõ∏ Formation follower indicator
                if (this.isFormationFollower) {
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 1;
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size + 8, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }

        // Boss Class
        class Boss {
            constructor(wave) {
                this.x = config.width / 2;
                this.y = -100;
                this.targetY = 150;
                this.wave = wave;
                this.maxHp = 20 + wave * 5;
                this.hp = this.maxHp;
                this.size = 60;
                this.speed = 1;
                this.rotation = 0;
                this.active = true;
                this.color = '#ff00ff';
                this.shieldActive = false;
                this.phaseTimer = 0;
                
                const bossTypes = ['spinner', 'divider', 'laser_eye', 'swarm_lord', 'chaos_core'];
                this.type = bossTypes[Math.min((wave - 1) % bossTypes.length, bossTypes.length - 1)];
                
                switch(this.type) {
                    case 'spinner':
                        this.spinSpeed = 0.05;
                        this.burstTimer = 0;
                        break;
                    case 'divider':
                        this.hasDivided = false;
                        this.minions = [];
                        break;
                    case 'laser_eye':
                        this.laserCharging = false;
                        this.laserTimer = 0;
                        this.eyeGlow = 0;
                        break;
                    case 'swarm_lord':
                        this.swarmTimer = 0;
                        this.auraSize = 0;
                        break;
                    case 'chaos_core':
                        this.chaosPhase = 0;
                        this.orbitals = [];
                        this.colorPhase = 0;
                        for (let i = 0; i < 3; i++) {
                            this.orbitals.push({
                                angle: (Math.PI * 2 * i) / 3,
                                distance: 80,
                                size: 15
                            });
                        }
                        break;
                }
                
                this.berserkerMode = false;
            }
            
            update() {
                if (!this.active) return;
                
                this.phaseTimer++;
                this.rotation += 0.02;
                
                if (this.y < this.targetY) {
                    this.y += 2;
                } else {
                    switch(this.type) {
                        case 'spinner':
                            this.updateSpinner();
                            break;
                        case 'divider':
                            this.updateDivider();
                            break;
                        case 'laser_eye':
                            this.updateLaserEye();
                            break;
                        case 'swarm_lord':
                            this.updateSwarmLord();
                            break;
                        case 'chaos_core':
                            this.updateChaosCore();
                            break;
                    }
                    
                    if (this.hp <= this.maxHp * 0.3 && !this.berserkerMode) {
                        this.berserkerMode = true;
                        this.speed *= 1.5;
                    }
                }
            }
            
            updateSpinner() {
                this.rotation += this.spinSpeed;
                if (this.berserkerMode) this.spinSpeed = 0.1;
                
                this.x += Math.sin(this.phaseTimer * 0.02) * this.speed * 2;
                
                this.burstTimer++;
                if (this.burstTimer > 60) {
                    this.fireBurstPattern();
                    this.burstTimer = 0;
                }
            }
            
            updateDivider() {
                this.x += Math.sin(this.phaseTimer * 0.01) * this.speed;
                
                if (this.hp <= this.maxHp * 0.5 && !this.hasDivided) {
                    this.divide();
                    this.hasDivided = true;
                }
                
                if (this.phaseTimer % 80 === 0) {
                    this.fireSpreadPattern();
                }
            }
            
            updateLaserEye() {
                if (!this.laserCharging) {
                    this.x += Math.sin(this.phaseTimer * 0.015) * this.speed * 1.5;
                }
                
                this.laserTimer++;
                if (this.laserTimer > 120) {
                    this.laserCharging = true;
                    this.eyeGlow = Math.min(1, this.eyeGlow + 0.02);
                    
                    if (this.eyeGlow >= 1) {
                        this.fireLaserBeam();
                        this.laserCharging = false;
                        this.laserTimer = 0;
                        this.eyeGlow = 0;
                    }
                } else {
                    this.eyeGlow = Math.max(0, this.eyeGlow - 0.05);
                }
            }
            
            updateSwarmLord() {
                this.x = config.width / 2 + Math.sin(this.phaseTimer * 0.01) * 150;
                this.auraSize = 20 + Math.sin(this.phaseTimer * 0.05) * 10;
                
                this.swarmTimer++;
                if (this.swarmTimer > 100) {
                    this.spawnSwarm();
                    this.swarmTimer = 0;
                }
                
                if (this.phaseTimer % 40 === 0) {
                    this.fireCircularPattern();
                }
            }
            
            updateChaosCore() {
                this.colorPhase++;
                this.x = config.width / 2 + Math.cos(this.phaseTimer * 0.02) * 100;
                this.y = this.targetY + Math.sin(this.phaseTimer * 0.03) * 50;
                
                this.orbitals.forEach((orbital, i) => {
                    orbital.angle += 0.05 + i * 0.01;
                    orbital.distance = 80 + Math.sin(this.phaseTimer * 0.02 + i) * 20;
                });
                
                if (this.phaseTimer % 30 === 0) {
                    this.fireChaosPattern();
                }
            }
            
            fireBurstPattern() {
                const numBullets = this.berserkerMode ? 16 : 12;
                for (let i = 0; i < numBullets; i++) {
                    const angle = (Math.PI * 2 * i) / numBullets + this.rotation;
                    const speed = 4;
                    enemyBulletPool.get(
                        this.x + Math.cos(angle) * 30,
                        this.y + Math.sin(angle) * 30,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        false
                    );
                }
                soundSystem.playExplosion();
            }
            
            fireSpreadPattern() {
                const angles = [-0.5, -0.25, 0, 0.25, 0.5];
                angles.forEach(offset => {
                    const angle = Math.atan2(gameState.player.y - this.y, gameState.player.x - this.x) + offset;
                    enemyBulletPool.get(
                        this.x, this.y,
                        Math.cos(angle) * 5,
                        Math.sin(angle) * 5,
                        false
                    );
                });
            }
            
            fireCircularPattern() {
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 * i) / 8;
                    enemyBulletPool.get(
                        this.x + Math.cos(angle) * this.size,
                        this.y + Math.sin(angle) * this.size,
                        Math.cos(angle) * 3,
                        Math.sin(angle) * 3,
                        false
                    );
                }
            }
            
            fireChaosPattern() {
                this.orbitals.forEach(orbital => {
                    const x = this.x + Math.cos(orbital.angle) * orbital.distance;
                    const y = this.y + Math.sin(orbital.angle) * orbital.distance;
                    
                    for (let i = 0; i < 4; i++) {
                        const angle = (Math.PI * 2 * i) / 4 + this.phaseTimer * 0.05;
                        enemyBulletPool.get(
                            x, y,
                            Math.cos(angle) * 4,
                            Math.sin(angle) * 4,
                            false
                        );
                    }
                });
            }
            
            divide() {
                for (let i = 0; i < 2; i++) {
                    const idx = i; // Capture i value for closure
                    const minion = {
                        x: this.x + (idx === 0 ? -50 : 50),
                        y: this.y,
                        size: 30,
                        hp: 5,
                        active: true,
                        rotation: 0,
                        isMinion: true,
                        color: '#ff00ff',
                        points: 100,
                        update() {
                            if (!this.active) return;
                            this.rotation += 0.03;
                            this.x += (idx === 0 ? -1 : 1) * Math.sin(Date.now() * 0.002) * 2;
                            
                            if (Math.random() < 0.02 && gameState && gameState.player) {
                                const angle = Math.atan2(gameState.player.y - this.y, gameState.player.x - this.x);
                                if (enemyBulletPool) {
                                    enemyBulletPool.get(
                                        this.x, this.y,
                                        Math.cos(angle) * 4,
                                        Math.sin(angle) * 4,
                                        false
                                    );
                                }
                            }
                        },
                        takeDamage(amount) {
                            this.hp -= amount;
                            if (this.hp <= 0) {
                                this.active = false;
                                if (particleSystem) {
                                    particleSystem.addExplosion(this.x, this.y, '#ff00ff', 15);
                                }
                            }
                        },
                        draw(ctx) {
                            if (!this.active) return;
                            ctx.save();
                            ctx.translate(this.x, this.y);
                            ctx.rotate(this.rotation);
                            ctx.strokeStyle = '#ff00ff';
                            ctx.lineWidth = 2;
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = '#ff00ff';
                            ctx.strokeRect(-this.size/2, -this.size/2, this.size, this.size);
                            ctx.restore();
                        }
                    };
                    gameState.enemies.push(minion);
                }
                
                particleSystem.addExplosion(this.x, this.y, this.color, 20);
            }
            
            spawnSwarm() {
                for (let i = 0; i < 5; i++) {
                    const angle = (Math.PI * 2 * i) / 5;
                    const spawnX = this.x + Math.cos(angle) * (this.size + 40);
                    const spawnY = this.y + Math.sin(angle) * (this.size + 40);
                    
                    const enemy = new Enemy(spawnX, spawnY, 'triangle');
                    enemy.hp = 1;
                    enemy.points = 50;
                    enemy.size = 10;
                    enemy.speed = 3;
                    gameState.enemies.push(enemy);
                }
                
                particleSystem.addExplosion(this.x, this.y, this.color, 10);
            }
            
            fireLaserBeam() {
                if (!gameState.player) return;
                
                const angle = Math.atan2(
                    gameState.player.y - this.y,
                    gameState.player.x - this.x
                );
                
                for (let i = 0; i < 20; i++) {
                    setTimeout(() => {
                        if (this.active) {
                            for (let j = -2; j <= 2; j++) {
                                enemyBulletPool.get(
                                    this.x + j * 5, this.y,
                                    Math.cos(angle) * 8,
                                    Math.sin(angle) * 8,
                                    false
                                );
                            }
                        }
                    }, i * 50);
                }
                
                if (gameState.screenShake) {
                    gameState.screenShake.intensity = 15;
                    gameState.screenShake.duration = 30;
                }
                
                soundSystem.playExplosion();
            }
            
            draw(ctx) {
                ctx.save();
                
                switch(this.type) {
                    case 'spinner':
                        this.drawSpinner(ctx);
                        break;
                    case 'divider':
                        this.drawDivider(ctx);
                        break;
                    case 'laser_eye':
                        this.drawLaserEye(ctx);
                        break;
                    case 'swarm_lord':
                        this.drawSwarmLord(ctx);
                        break;
                    case 'chaos_core':
                        this.drawChaosCore(ctx);
                        break;
                }
                
                // Health bar
                const barWidth = 100;
                const barHeight = 8;
                const barX = this.x - barWidth / 2;
                const barY = this.y - this.size - 20;
                
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
                
                const healthPercent = this.hp / this.maxHp;
                ctx.fillStyle = healthPercent > 0.3 ? '#00ff00' : '#ff0000';
                ctx.fillRect(barX + 1, barY + 1, (barWidth - 2) * healthPercent, barHeight - 2);
                
                ctx.restore();
            }
            
            drawSpinner(ctx) {
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.shadowBlur = 30;
                ctx.shadowColor = this.color;
                
                for (let i = 0; i < 4; i++) {
                    ctx.save();
                    ctx.rotate((Math.PI / 2) * i);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(this.size, 0);
                    ctx.lineTo(this.size * 0.8, this.size * 0.3);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.fillStyle = this.color + '33';
                    ctx.fill();
                    ctx.restore();
                }
                
                ctx.beginPath();
                ctx.arc(0, 0, 20, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fill();
            }
            
            drawDivider(ctx) {
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 5;
                ctx.shadowBlur = 40;
                ctx.shadowColor = this.color;
                ctx.globalAlpha = 0.5;
                
                ctx.strokeRect(-this.size, -this.size, this.size * 2, this.size * 2);
                
                ctx.globalAlpha = 1;
                ctx.strokeStyle = this.color;
                ctx.fillStyle = this.color + '33';
                ctx.lineWidth = 3;
                
                ctx.fillRect(-this.size, -this.size, this.size * 2, this.size * 2);
                ctx.strokeRect(-this.size, -this.size, this.size * 2, this.size * 2);
                
                if (!this.hasDivided && !this.isMinion && this.hp <= this.maxHp * 0.6) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(0, -this.size);
                    ctx.lineTo(0, this.size);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            
            drawLaserEye(ctx) {
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                ctx.strokeStyle = this.color;
                ctx.fillStyle = this.color + '33';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 30;
                ctx.shadowColor = this.color;
                
                ctx.beginPath();
                ctx.moveTo(0, -this.size);
                ctx.lineTo(-this.size * 0.866, this.size * 0.5);
                ctx.lineTo(this.size * 0.866, this.size * 0.5);
                ctx.closePath();
                ctx.stroke();
                ctx.fill();
                
                const eyeRadius = 15;
                const eyeColor = this.laserCharging ? 
                    `rgba(255, ${Math.floor(255 * (1 - this.eyeGlow))}, 0, 1)` : 
                    '#ffffff';
                
                ctx.strokeStyle = eyeColor;
                ctx.lineWidth = 2;
                ctx.shadowBlur = 20 + this.eyeGlow * 30;
                ctx.shadowColor = eyeColor;
                
                ctx.beginPath();
                ctx.arc(0, 0, eyeRadius, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.fillStyle = eyeColor;
                ctx.beginPath();
                ctx.arc(0, 0, eyeRadius * 0.3 + this.eyeGlow * 10, 0, Math.PI * 2);
                ctx.fill();
            }
            
            drawSwarmLord(ctx) {
                ctx.translate(this.x, this.y);
                
                ctx.save();
                ctx.globalAlpha = 0.3;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.shadowBlur = 40;
                ctx.shadowColor = this.color;
                
                ctx.rotate(this.rotation * 0.5);
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (Math.PI * 2 * i) / 5 - Math.PI / 2;
                    const px = Math.cos(angle) * (this.size + this.auraSize);
                    const py = Math.sin(angle) * (this.size + this.auraSize);
                    
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.restore();
                
                ctx.rotate(this.rotation);
                ctx.strokeStyle = this.color;
                ctx.fillStyle = this.color + '33';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 30;
                ctx.shadowColor = this.color;
                
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (Math.PI * 2 * i) / 5 - Math.PI / 2;
                    const px = Math.cos(angle) * this.size;
                    const py = Math.sin(angle) * this.size;
                    
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.fill();
            }
            
            drawChaosCore(ctx) {
                ctx.translate(this.x, this.y);
                
                const hue = (this.colorPhase * 2) % 360;
                const coreColor = `hsl(${hue}, 100%, 50%)`;
                
                this.orbitals.forEach((orbital, i) => {
                    const x = Math.cos(orbital.angle) * orbital.distance;
                    const y = Math.sin(orbital.angle) * orbital.distance;
                    
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(this.rotation * 2);
                    
                    const orbitalColor = `hsl(${(hue + i * 120) % 360}, 100%, 50%)`;
                    ctx.strokeStyle = orbitalColor;
                    ctx.fillStyle = orbitalColor + '33';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = orbitalColor;
                    
                    ctx.beginPath();
                    ctx.arc(0, 0, orbital.size, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fill();
                    ctx.restore();
                });
                
                ctx.rotate(this.rotation);
                ctx.strokeStyle = coreColor;
                ctx.fillStyle = coreColor + '33';
                ctx.lineWidth = 4;
                ctx.shadowBlur = 40;
                ctx.shadowColor = coreColor;
                
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI * 2 * i) / 6;
                    const px = Math.cos(angle) * this.size;
                    const py = Math.sin(angle) * this.size;
                    
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.fill();
            }
            
            takeDamage(amount) {
                try {
                    this.hp -= amount;
                    
                    if (this.hp <= 0) {
                        this.active = false;
                        gameState.score += 1000 * this.wave;
                        gameState.boss = null;
                        
                        if (particleSystem) {
                            for (let i = 0; i < 50; i++) {
                                particleSystem.particles.push(new Particle(
                                    this.x + (Math.random() - 0.5) * this.size,
                                    this.y + (Math.random() - 0.5) * this.size,
                                    (Math.random() - 0.5) * 15,
                                    (Math.random() - 0.5) * 15,
                                    `hsl(${Math.random() * 360}, 100%, 70%)`
                                ));
                            }
                        }
                        
                        if (gameState.screenShake) {
                            gameState.screenShake.intensity = 20;
                            gameState.screenShake.duration = 40;
                        }
                        
                        if (soundSystem) soundSystem.playExplosion();
                        gameState.combo = 0;
                        updateUI();
                        
                        if (enemyBulletPool) enemyBulletPool.clear();
                        
                        if (bossDeathTimeoutId) {
                            clearTimeout(bossDeathTimeoutId);
                        }
                        
                        bossDeathTimeoutId = setTimeout(() => {
                            if (gameState && gameState.running) {
                                if (waveManager && typeof waveManager.nextWave === 'function') {
                                    waveManager.nextWave();
                                } else {
                                    gameState.wave++;
                                    if (waveManager) {
                                        waveManager.enemiesKilled = 0;
                                        waveManager.bossSpawned = false;
                                    }
                                }
                                updateUI();
                            }
                        }, 2000);
                    }
                } catch (error) {
                    console.error('Boss take damage error:', error);
                }
            }
        }

        // Particle System
        class ParticleSystem {
            constructor() {
                this.particles = [];
            }
            
            addMuzzleFlash(x, y, direction, color) {
                for (let i = 0; i < 3; i++) {
                    const angle = direction + (Math.random() - 0.5) * 0.3;
                    const speed = 2 + Math.random() * 2;
                    this.particles.push(new MuzzleParticle(
                        x + Math.cos(direction) * 10,
                        y + Math.sin(direction) * 10,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        color
                    ));
                }
            }
            
            addExplosion(x, y, color, count = 30) {
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 12 + 3;
                    const particleColor = i % 3 === 0 ? '#ffffff' : color;
                    
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        color: particleColor,
                        life: 40 + Math.random() * 20,
                        maxLife: 60,
                        size: Math.random() * 4 + 2,
                        gravity: 0.15,
                        bounce: 0.7,
                        friction: 0.95,
                        active: true,
                        type: 'explosion',
                        trail: [],
                        update() {
                            this.vy += this.gravity;
                            this.vx *= this.friction;
                            this.vy *= this.friction;
                            
                            if (this.life % 2 === 0) {
                                this.trail.push({ x: this.x, y: this.y, life: 10 });
                            }
                            
                            this.x += this.vx;
                            this.y += this.vy;
                            
                            this.trail = this.trail.filter(t => {
                                t.life--;
                                return t.life > 0;
                            });
                            
                            if (this.y > config.height - this.size && this.vy > 0) {
                                this.vy *= -this.bounce;
                                this.vx *= 0.8;
                            }
                            
                            this.life--;
                            if (this.life <= 0) this.active = false;
                        },
                        draw(ctx) {
                            if (!this.active) return;
                            
                            const alpha = this.life / this.maxLife;
                            
                            ctx.save();
                            if (this.trail) {
                                this.trail.forEach((t, i) => {
                                    const trailAlpha = (t.life / 10) * alpha * 0.5;
                                    ctx.globalAlpha = trailAlpha;
                                    ctx.fillStyle = this.color;
                                    ctx.shadowBlur = 10;
                                    ctx.shadowColor = this.color;
                                    ctx.fillRect(t.x - 1, t.y - 1, 2, 2);
                                });
                            }
                            ctx.restore();
                            
                            ctx.save();
                            ctx.globalAlpha = alpha;
                            ctx.fillStyle = this.color;
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = this.color;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                            ctx.fill();
                            
                            ctx.globalAlpha = alpha * 0.8;
                            ctx.fillStyle = '#ffffff';
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.size * 0.5, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }
                    });
                }
            }
            
            update() {
                this.particles = this.particles.filter(p => {
                    p.update();
                    return p.active;
                });
            }
            
            draw(ctx) {
                this.particles.forEach(p => p.draw(ctx));
            }
        }

        // Bullet Pool
        class BulletPool {
            constructor() {
                this.bullets = [];
                this.maxBullets = 200;
            }
            
            get(x, y, vx, vy, isPlayerBullet) {
                for (let bullet of this.bullets) {
                    if (!bullet.active) {
                        bullet.reset(x, y, vx, vy, isPlayerBullet);
                        return bullet;
                    }
                }
                
                if (this.bullets.length < this.maxBullets) {
                    const bullet = new Bullet(x, y, vx, vy, isPlayerBullet);
                    this.bullets.push(bullet);
                    return bullet;
                }
                
                return null;
            }
            
            update() {
                this.bullets.forEach(bullet => bullet.update());
            }
            
            draw(ctx) {
                this.bullets.forEach(bullet => {
                    if (bullet.active) bullet.draw(ctx);
                });
            }
            
            clear() {
                this.bullets.forEach(bullet => bullet.active = false);
            }
            
            getActiveBullets() {
                return this.bullets.filter(b => b.active);
            }
        }

        // Bullet Class
        class Bullet {
            constructor(x, y, vx, vy, isPlayerBullet) {
                this.reset(x, y, vx, vy, isPlayerBullet);
            }
            
            reset(x, y, vx, vy, isPlayerBullet) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.isPlayerBullet = isPlayerBullet;
                this.active = true;
                this.damage = isPlayerBullet ? 1 : 1;
            }
            
            update() {
                if (!this.active) return;
                
                this.x += this.vx;
                this.y += this.vy;
                
                if (this.x < -10 || this.x > config.width + 10 || 
                    this.y < -10 || this.y > config.height + 10) {
                    this.active = false;
                }
            }
            
            draw(ctx) {
                if (!this.active) return;
                
                ctx.save();
                
                const color = this.isPlayerBullet ? '#00ff00' : '#ff0066';
                
                ctx.fillStyle = color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = color;
                ctx.globalAlpha = 0.8;
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.isPlayerBullet ? 4 : 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#ffffff';
                ctx.globalAlpha = 1;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.isPlayerBullet ? 2 : 1.5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x - this.vx * 2, this.y - this.vy * 2);
                ctx.stroke();
                
                ctx.restore();
            }
        }

        // Wave Manager
        class WaveManager {
            constructor() {
                this.enemiesKilled = 0;
                this.enemiesPerWave = 10;
                this.bossSpawned = false;
                this.enemySpawnTimer = 0;
            }
            
            update(deltaTime) {
                if (!gameState.boss) {
                    if (this.enemiesKilled >= this.enemiesPerWave && !this.bossSpawned) {
                        this.spawnBoss();
                        this.bossSpawned = true;
                    } else if (!this.bossSpawned) {
                        this.updateEnemySpawns(deltaTime);
                    }
                }
            }
            
            updateEnemySpawns(deltaTime) {
                if (!gameState.boss && !this.bossSpawned) {
                    this.enemySpawnTimer += deltaTime;
                    
                    const baseSpawnRate = 60;
                    const waveModifier = Math.max(0.3, 1 - (gameState.wave * 0.1));
                    let adjustedSpawnRate = baseSpawnRate * waveModifier;
                    
                    // üõ∏ Reduce spawn rate when formations are active
                    if (formationManager && formationManager.formations.length > 0) {
                        adjustedSpawnRate *= 1.5; // Slower spawns during formations
                    }
                    
                    const maxEnemies = Math.min(8 + Math.floor(gameState.wave / 1.5), 15);
                    
                    if (this.enemySpawnTimer > adjustedSpawnRate && gameState.enemies.length < maxEnemies) {
                        this.spawnEnemy();
                        
                        if (gameState.wave > 2 && Math.random() < 0.4 + (gameState.wave * 0.05)) {
                            setTimeout(() => this.spawnEnemy(), 300);
                            if (gameState.wave > 4) {
                                setTimeout(() => this.spawnEnemy(), 600);
                            }
                        }
                        
                        this.enemySpawnTimer = 0;
                    }
                }
            }
            
            spawnEnemy() {
                try {
                    let availableTypes = ['triangle'];
                    if (gameState.wave >= 2) availableTypes.push('square');
                    if (gameState.wave >= 4) availableTypes.push('pentagon');
                    
                    let type;
                    if (gameState.wave >= 6 && Math.random() < 0.5) {
                        type = 'pentagon';
                    } else if (gameState.wave >= 3 && Math.random() < 0.4) {
                        type = 'square';
                    } else {
                        type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
                    }
                    
                    const x = Math.random() * (config.width - 100) + 50;
                    gameState.enemies.push(new Enemy(x, -50, type));
                } catch (error) {
                    console.error('Error spawning enemy:', error);
                }
            }
            
            onEnemyKilled() {
                this.enemiesKilled++;
            }
            
            spawnBoss() {
                try {
                    if (!Boss || typeof Boss !== 'function') {
                        console.error('Boss class not defined');
                        this.bossSpawned = false;
                        return;
                    }
                    
                    gameState.boss = new Boss(gameState.wave);
                    
                    if (!gameState.boss || !gameState.boss.update) {
                        console.error('Boss creation failed');
                        gameState.boss = null;
                        this.bossSpawned = false;
                    }
                } catch (error) {
                    console.error('Error spawning boss:', error);
                    this.bossSpawned = false;
                    gameState.boss = null;
                }
            }
            
            nextWave() {
                try {
                    gameState.wave++;
                    this.enemiesKilled = 0;
                    this.bossSpawned = false;
                    this.enemiesPerWave = Math.min(10 + gameState.wave * 2, 30);
                    
                    if (gameState.wave % 5 === 0) {
                        gameState.lives++;
                        updateUI();
                    }
                } catch (error) {
                    console.error('Error advancing wave:', error);
                }
            }
        }

        // PowerUp Class
        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.active = true;
                this.lifetime = 300;
                this.pulseTimer = 0;
                
                switch(type) {
                    case 'weapon':
                        this.color = '#ffff00';
                        this.symbol = 'W';
                        break;
                    case 'shield':
                        this.color = '#00ffff';
                        this.symbol = 'S';
                        break;
                    case 'bomb':
                        this.color = '#ff00ff';
                        this.symbol = 'B';
                        break;
                    case 'rapid':
                        this.color = '#ff8800';
                        this.symbol = 'R';
                        break;
                    case 'health':
                        this.color = '#ff0000';
                        this.symbol = '‚ô•';
                        break;
                }
            }
            
            update() {
                this.lifetime--;
                this.pulseTimer += 0.1;
                
                if (this.lifetime <= 0) {
                    this.active = false;
                }
                
                this.y += 0.5;
                
                if (this.y > config.height + 30) {
                    this.active = false;
                }
            }
            
            draw(ctx) {
                const pulse = Math.sin(this.pulseTimer) * 0.3 + 0.7;
                const alpha = this.lifetime < 60 ? this.lifetime / 60 : 1;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                
                if (this.type === 'health') {
                    // Special draw for health
                    ctx.rotate(Math.sin(this.pulseTimer * 0.5) * 0.1);
                    ctx.fillStyle = this.color;
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 20 * pulse;
                    ctx.shadowColor = this.color;
                    ctx.globalAlpha = alpha;
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.symbol, 0, 0);
                    ctx.strokeText(this.symbol, 0, 0);
                } else {
                    // Original draw for other powerups
                    ctx.rotate(this.pulseTimer * 0.5);
                    
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 20 * pulse;
                    ctx.shadowColor = this.color;
                    ctx.globalAlpha = alpha;
                    
                    ctx.beginPath();
                    ctx.moveTo(0, -15);
                    ctx.lineTo(15, 0);
                    ctx.lineTo(0, 15);
                    ctx.lineTo(-15, 0);
                    ctx.closePath();
                    ctx.stroke();
                    
                    ctx.fillStyle = this.color + '33';
                    ctx.fill();
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 16px Courier New';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.symbol, 0, 0);
                }
                
                ctx.restore();
            }
        }

        // Attract Mode AI
        class AttractModeAI {
            constructor() {
                this.targetEnemy = null;
                this.dodgeDirection = 0;
                this.shootCooldown = 0;
            }
            
            update(player, enemies, enemyBullets) {
                if (!player) return;
                
                this.targetEnemy = null;
                let closestDist = Infinity;
                
                enemies.forEach(enemy => {
                    if (enemy.active) {
                        const dist = Math.hypot(enemy.x - player.x, enemy.y - player.y);
                        if (dist < closestDist) {
                            closestDist = dist;
                            this.targetEnemy = enemy;
                        }
                    }
                });
                
                keys = {};
                
                let closestBullet = null;
                let bulletDist = Infinity;
                
                enemyBullets.forEach(bullet => {
                    if (bullet.active) {
                        const dist = Math.hypot(bullet.x - player.x, bullet.y - player.y);
                        if (dist < 100 && dist < bulletDist) {
                            bulletDist = dist;
                            closestBullet = bullet;
                        }
                    }
                });
                
                if (closestBullet) {
                    const bulletAngle = Math.atan2(closestBullet.vy, closestBullet.vx);
                    const dodgeAngle = bulletAngle + Math.PI / 2;
                    
                    if (Math.cos(dodgeAngle) > 0.3) keys['d'] = true;
                    else if (Math.cos(dodgeAngle) < -0.3) keys['a'] = true;
                    
                    if (Math.sin(dodgeAngle) > 0.3) keys['s'] = true;
                    else if (Math.sin(dodgeAngle) < -0.3) keys['w'] = true;
                } else if (this.targetEnemy) {
                    const dx = this.targetEnemy.x - player.x;
                    const dy = this.targetEnemy.y - player.y;
                    
                    if (Math.abs(dx) > 30) {
                        if (dx > 0) keys['d'] = true;
                        else keys['a'] = true;
                    }
                    
                    if (player.y > config.height * 0.6) {
                        keys['w'] = true;
                    } else if (player.y < 100 && dy > 0) {
                        keys['s'] = true;
                    }
                }
                
                this.shootCooldown--;
                if (this.targetEnemy && closestDist < 300 && this.shootCooldown <= 0) {
                    keys[' '] = true;
                    this.shootCooldown = 10;
                } else {
                    keys[' '] = false;
                }
            }
        }

        // Game Functions - Made globally accessible for onclick handlers
        window.startGame = function() {
            // ü™ô CHECK CREDITS BEFORE STARTING
            if (credits <= 0) {
                // Flash "INSERT COIN" message
                const insertCoinEl = document.getElementById('insertCoinText');
                insertCoinEl.style.color = '#ff0000';
                insertCoinEl.style.animation = 'blink 0.2s ease-in-out 6';
                setTimeout(() => {
                    insertCoinEl.style.color = '#ffff00';
                    insertCoinEl.style.animation = 'blink 1s ease-in-out infinite';
                }, 1200);
                return; // Don't start game without credits
            }
            
            // Use one credit
            credits--;
            updateCreditsDisplay();
            
            // üé∂ MUSIKK: Stopp meny-musikk, start spill-musikk
            if (musicEnabled && menuMusic && gameMusic) {
                try {
                    menuMusic.pause();
                    menuMusic.currentTime = 0;
                    gameMusic.play().catch(err => console.warn("Game music play failed:", err));
                } catch (error) {
                    console.warn("Music control failed:", error);
                }
            }
            
            // Stop any existing game loop
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            document.getElementById('menuScreen').style.display = 'none';
            document.getElementById('gameUI').style.display = 'block';
            
            keys = {};
            
            bulletPool = new BulletPool();
            enemyBulletPool = new BulletPool();
            particleSystem = new ParticleSystem();
            soundSystem = new SoundSystem();
            waveManager = new WaveManager();
            
            // üåü Initialize starfield and formation systems
            starfield = new Starfield();
            formationManager = new FormationManager();
            
            gameState = {
                running: true,
                paused: false,
                score: 0,
                lastScoreIncrease: 0,
                lives: 3,
                bombs: 3,
                wave: 1,
                combo: 0,
                maxCombo: 0,
                comboTimer: 0,
                comboTimeout: 180,
                enemies: [],
                particles: [],
                powerUps: [],
                boss: null,
                player: new Player(config.width / 2, config.height - 100),
                radicalSlang: new RadicalSlang(),
                screenShake: { x: 0, y: 0, intensity: 0, duration: 0 },
                slowMotion: 0,
                promoTexts: null,
                currentPromoIndex: 0,
                promoTimer: 0
            };
            
            updateUI();
            gameLoop();
            
            resetAttractModeTimeout();
        }
        
        window.gameOver = function() {
            if (!gameState) return;
            
            // üé∂ MUSIKK: Stopp spill-musikk n√•r spillet er over
            if (musicEnabled && gameMusic) {
                try {
                    gameMusic.pause();
                    gameMusic.currentTime = 0;
                } catch (error) {
                    console.warn("Music control failed:", error);
                }
            }
            
            gameState.paused = true;
            gameState.running = false;  // Stop the game loop
            
            // Cancel animation frame
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            // ü™ô SHOW CONTINUE SCREEN INSTEAD OF IMMEDIATE GAME OVER
            showContinueScreen();
            
            keys = {};
            
            if (soundSystem) soundSystem.enabled = false;
            
            resetAttractModeTimeout();
        }
        
        window.restartGame = function() {
            // Cancel any existing game loop
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            if (soundSystem) soundSystem.enabled = true;
            
            document.getElementById('gameOverScreen').style.display = 'none';
            startGame();
        }
        
        window.backToMenu = function() {
            // üé∂ MUSIKK: Stopp spill-musikk, start meny-musikk
            if (musicEnabled && menuMusic && gameMusic) {
                try {
                    gameMusic.pause();
                    gameMusic.currentTime = 0;
                    menuMusic.play().catch(err => console.warn("Menu music play failed:", err));
                } catch (error) {
                    console.warn("Music control failed:", error);
                }
            }
            
            // Cancel any existing game loop
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('menuScreen').style.display = 'flex';
            document.getElementById('gameUI').style.display = 'none';
            
            // üîä VOICE: Velkommen tilbake til menyen
            setTimeout(() => {
                if (soundSystem) {
                    soundSystem.playVoiceSample('GET READY');
                }
            }, 1000);
            
            if (gameState) {
                gameState.running = false;
                gameState = null;
            }
            
            if (bulletPool) bulletPool.clear();
            if (enemyBulletPool) enemyBulletPool.clear();
            
            keys = {};
            
            if (bossDeathTimeoutId) {
                clearTimeout(bossDeathTimeoutId);
                bossDeathTimeoutId = null;
            }
            
            resetAttractModeTimeout();
        }
        
        window.showHighScores = function() {
            // This function is now replaced by showHighScoreList()
            showHighScoreList();
        }
        
        // üèÜ Show high score entry screen
        window.showHighScoreEntry = function() {
            document.getElementById('newHighScoreValue').textContent = gameState.score.toLocaleString();
            document.getElementById('highScoreEntryScreen').style.display = 'flex';
            document.getElementById('gameUI').style.display = 'none';
            
            // Clear any existing input values
            document.getElementById('initial1').value = '';
            document.getElementById('initial2').value = '';
            document.getElementById('initial3').value = '';
            
            // Set up initial input handling FIRST
            setupInitialInputs();
            
            // Focus on first initial input after a short delay
            setTimeout(() => {
                const firstInput = document.getElementById('initial1');
                firstInput.focus();
                firstInput.select();
                console.log('üèÜ High score entry ready - type your initials!');
            }, 200);
        }
        
        // üèÜ Setup initial input handling (3-letter arcade style)
        function setupInitialInputs() {
            const inputs = ['initial1', 'initial2', 'initial3'];
            
            // Remove any existing event listeners first
            inputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                const newInput = input.cloneNode(true);
                input.parentNode.replaceChild(newInput, input);
            });
            
            // Now add fresh event listeners
            inputs.forEach((inputId, index) => {
                const input = document.getElementById(inputId);
                input.value = '';
                input.maxLength = 1;
                
                // Input event for typing
                input.addEventListener('input', function(e) {
                    console.log('üèÜ Input detected:', e.target.value);
                    
                    // Only allow A-Z letters
                    let value = e.target.value.toUpperCase().replace(/[^A-Z]/g, '');
                    e.target.value = value;
                    
                    // Move to next field if we have a letter and not on last field
                    if (value.length === 1 && index < 2) {
                        const nextInput = document.getElementById(inputs[index + 1]);
                        setTimeout(() => {
                            nextInput.focus();
                            nextInput.select();
                        }, 50);
                    }
                });
                
                // Keydown event for navigation and submit
                input.addEventListener('keydown', function(e) {
                    console.log('üèÜ Key pressed:', e.key);
                    
                    if (e.key === 'Backspace' && e.target.value === '' && index > 0) {
                        // Move to previous field on backspace if current is empty
                        const prevInput = document.getElementById(inputs[index - 1]);
                        setTimeout(() => {
                            prevInput.focus();
                            prevInput.select();
                        }, 50);
                    } else if (e.key === 'Enter') {
                        e.preventDefault();
                        submitHighScore();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        skipHighScore();
                    } else if (e.key === 'ArrowLeft' && index > 0) {
                        e.preventDefault();
                        document.getElementById(inputs[index - 1]).focus();
                    } else if (e.key === 'ArrowRight' && index < 2) {
                        e.preventDefault();
                        document.getElementById(inputs[index + 1]).focus();
                    }
                });
                
                // Focus event
                input.addEventListener('focus', function(e) {
                    e.target.select();
                });
            });
            
            console.log('üèÜ Initial inputs setup complete');
        }
        
        // üèÜ Submit high score with initials
        window.submitHighScore = function() {
            const initial1 = document.getElementById('initial1').value || 'A';
            const initial2 = document.getElementById('initial2').value || 'A';
            const initial3 = document.getElementById('initial3').value || 'A';
            const initials = initial1 + initial2 + initial3;
            
            const highScores = getHighScores();
            const newEntry = {
                initials: initials,
                score: gameState.score,
                wave: gameState.wave
            };
            
            // Insert the new score at the correct position
            highScores.splice(newHighScoreIndex, 0, newEntry);
            
            // Keep only top 10 scores
            highScores.splice(10);
            
            // Save to localStorage
            saveHighScores(highScores);
            
            // Hide entry screen and show high score list
            document.getElementById('highScoreEntryScreen').style.display = 'none';
            showHighScoreList();
        }
        
        // üèÜ Skip high score entry
        function skipHighScore() {
            document.getElementById('highScoreEntryScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'flex';
        }
        
        // üèÜ Show high score list (1980s arcade style)
        window.showHighScoreList = function() {
            // Mark if we're coming from attract mode
            if (attractMode) {
                highScoreFromAttractMode = true;
            }
            
            const highScores = getHighScores();
            const listElement = document.getElementById('highScoreList');
            
            let html = '<div style="display: flex; justify-content: space-between; width: 500px; margin-bottom: 20px; padding: 10px 20px; border-bottom: 2px solid #00ffff; font-weight: 900; color: #ffff00;">';
            html += '<div class="rank">RANK</div>';
            html += '<div class="initials">NAME</div>';
            html += '<div class="score">SCORE</div>';
            html += '</div>';
            
            highScores.forEach((entry, index) => {
                const isNewEntry = (index === newHighScoreIndex);
                const entryClass = isNewEntry ? 'high-score-entry new-entry' : 'high-score-entry';
                
                html += `<div class="${entryClass}">`;
                html += `<div class="rank">${String(index + 1).padStart(2, '0')}.</div>`;
                html += `<div class="initials">${entry.initials}</div>`;
                html += `<div class="score">${entry.score.toLocaleString()}</div>`;
                html += '</div>';
            });
            
            listElement.innerHTML = html;
            document.getElementById('highScoreListScreen').style.display = 'flex';
            document.getElementById('gameUI').style.display = 'none';
            
            // üïπÔ∏è ATTRACT MODE: Auto-close high scores after 5 seconds if from attract mode
            if (highScoreFromAttractMode) {
                setTimeout(() => {
                    if (document.getElementById('highScoreListScreen').style.display === 'flex') {
                        closeHighScores();
                    }
                }, 5000);
            }
        }
        
        // üèÜ Close high score list
        window.closeHighScores = function() {
            document.getElementById('highScoreListScreen').style.display = 'none';
            
            // üïπÔ∏è If we came from attract mode, go back to menu
            if (highScoreFromAttractMode) {
                highScoreFromAttractMode = false;
                attractMode = false;
                attractModeAI = null;
                document.getElementById('menuScreen').style.display = 'flex';
                document.getElementById('gameUI').style.display = 'none';
                resetAttractModeTimeout();
                return;
            }
            
            // If we came from a game over with new high score, show game over screen
            if (newHighScoreIndex >= 0) {
                document.getElementById('gameOverScreen').style.display = 'flex';
                newHighScoreIndex = -1; // Reset
            } else {
                // Otherwise go back to menu
                backToMenu();
            }
        }
        
        function updateUI() {
            if (!gameState) return;
            
            // Check for extra life milestone (PATCH 4)
            const oldLifeThreshold = Math.floor((gameState.lastScoreIncrease || 0) / 100000);
            const newLifeThreshold = Math.floor(gameState.score / 100000);
            
            if (newLifeThreshold > oldLifeThreshold && gameState.lives < 5) {
                gameState.lives++;
                
                // üîä VOICE: "EXCELLENT!" for extra life
                if (soundSystem) {
                    setTimeout(() => soundSystem.playVoiceSample('EXCELLENT'), 300);
                }
                
                // Celebration effect
                if (particleSystem) {
                    for (let i = 0; i < 50; i++) {
                        const angle = (Math.PI * 2 * i) / 50;
                        particleSystem.particles.push({
                            x: config.width / 2,
                            y: config.height / 2,
                            vx: Math.cos(angle) * 10,
                            vy: Math.sin(angle) * 10,
                            color: `hsl(${i * 7}, 100%, 50%)`,
                            life: 60,
                            maxLife: 60,
                            size: 4,
                            active: true,
                            update() {
                                this.x += this.vx;
                                this.y += this.vy;
                                this.vx *= 0.95;
                                this.vy *= 0.95;
                                this.life--;
                                if (this.life <= 0) this.active = false;
                            },
                            draw(ctx) {
                                const alpha = this.life / this.maxLife;
                                ctx.save();
                                ctx.globalAlpha = alpha;
                                ctx.fillStyle = this.color;
                                ctx.shadowBlur = 20;
                                ctx.shadowColor = this.color;
                                ctx.beginPath();
                                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.restore();
                            }
                        });
                    }
                }
                if (soundSystem) soundSystem.playPowerUp();
            }
            
            gameState.lastScoreIncrease = gameState.score;
            
            document.getElementById('scoreDisplay').textContent = gameState.score.toLocaleString();
            document.getElementById('waveDisplay').textContent = gameState.wave;
            document.getElementById('livesDisplay').textContent = gameState.lives;
            document.getElementById('bombsDisplay').textContent = gameState.bombs;
            
            // üèÜ Show highest score from the high score list
            const highScores = getHighScores();
            const topScore = highScores.length > 0 ? highScores[0].score : 0;
            document.getElementById('highScoreDisplay').textContent = topScore.toLocaleString();
        }

        // Collision Detection
        function checkCollisions() {
            if (!gameState || !gameState.player) return;
            
            bulletPool.getActiveBullets().forEach(bullet => {
                if (bullet.isPlayerBullet && bullet.active) {
                    if (gameState.boss && gameState.boss.active) {
                        const dist = Math.hypot(
                            bullet.x - gameState.boss.x,
                            bullet.y - gameState.boss.y
                        );
                        
                        if (dist < gameState.boss.size) {
                            bullet.active = false;
                            if (gameState.boss && gameState.boss.takeDamage) {
                                gameState.boss.takeDamage(bullet.damage);
                            }
                            if (particleSystem) {
                                particleSystem.addExplosion(bullet.x, bullet.y, gameState.boss.color || '#ff00ff', 5);
                            }
                        }
                    }
                    
                    gameState.enemies.forEach(enemy => {
                        if (enemy && enemy.active) {
                            const dist = Math.hypot(
                                bullet.x - enemy.x,
                                bullet.y - enemy.y
                            );
                            
                            if (dist < enemy.size) {
                                bullet.active = false;
                                const damage = bullet.damage || 1;
                                enemy.takeDamage(damage);
                                
                                if (!enemy.active) {
                                    const scoreValue = enemy.points * (gameState.combo > 0 ? gameState.combo : 1);
                                    
                                    // üõ∏ FORMATION LEADER BONUS
                                    let finalScore = scoreValue;
                                    if (enemy.isFormationLeader && enemy.formationBonus) {
                                        finalScore += enemy.formationBonus;
                                        // Special effect for formation leader kill
                                        if (particleSystem) {
                                            for (let i = 0; i < 20; i++) {
                                                const angle = (Math.PI * 2 * i) / 20;
                                                particleSystem.particles.push({
                                                    x: enemy.x,
                                                    y: enemy.y,
                                                    vx: Math.cos(angle) * 8,
                                                    vy: Math.sin(angle) * 8,
                                                    color: '#ffff00',
                                                    life: 30,
                                                    maxLife: 30,
                                                    size: 3,
                                                    active: true,
                                                    update() {
                                                        this.x += this.vx;
                                                        this.y += this.vy;
                                                        this.vx *= 0.95;
                                                        this.vy *= 0.95;
                                                        this.life--;
                                                        if (this.life <= 0) this.active = false;
                                                    },
                                                    draw(ctx) {
                                                        const alpha = this.life / this.maxLife;
                                                        ctx.save();
                                                        ctx.globalAlpha = alpha;
                                                        ctx.fillStyle = this.color;
                                                        ctx.shadowBlur = 15;
                                                        ctx.shadowColor = this.color;
                                                        ctx.beginPath();
                                                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                                        ctx.fill();
                                                        ctx.restore();
                                                    }
                                                });
                                            }
                                        }
                                        
                                        // üîä VOICE: "EXCELLENT!" for formation leader kill
                                        setTimeout(() => {
                                            if (soundSystem) {
                                                soundSystem.playVoiceSample('EXCELLENT');
                                            }
                                        }, 100);
                                    }
                                    
                                    gameState.score += finalScore;
                                    gameState.combo++;
                                    gameState.comboTimer = 0;
                                    
                                    const popup = new ScorePopup(
                                        enemy.x, 
                                        enemy.y, 
                                        finalScore,
                                        enemy.color || '#ffffff',
                                        gameState.combo > 5 || enemy.isFormationLeader
                                    );
                                    gameState.particles.push(popup);
                                    
                                    if (particleSystem && enemy && enemy.color) {
                                        particleSystem.addExplosion(enemy.x, enemy.y, enemy.color, 20);
                                    }
                                    
                                    if (gameState.combo > gameState.maxCombo) {
                                        gameState.maxCombo = gameState.combo;
                                    }
                                    
                                    if (gameState.radicalSlang) {
                                        gameState.radicalSlang.trigger(gameState.combo);
                                    }
                                    
                                    // Play combo sound with increasing pitch
                                    if (soundSystem && gameState.combo > 2) {
                                        soundSystem.playCombo(Math.min(gameState.combo / 5, 10));
                                        
                                        // üîä VOICE: Different voice samples for different combo levels
                                        if (gameState.combo >= 20) {
                                            setTimeout(() => soundSystem.playVoiceSample('RADICAL'), 200);
                                        } else if (gameState.combo >= 10) {
                                            setTimeout(() => soundSystem.playVoiceSample('EXCELLENT'), 200);
                                        } else if (gameState.combo >= 5 && gameState.combo % 5 === 0) {
                                            setTimeout(() => soundSystem.playVoiceSample('PERFECT'), 200);
                                        }
                                    }
                                    
                                    if (gameState.screenShake) {
                                        gameState.screenShake.intensity = 5 + Math.min(gameState.combo, 10);
                                        gameState.screenShake.duration = 10;
                                    }
                                    
                                    if (soundSystem) soundSystem.playExplosion();
                                    
                                    if (waveManager) waveManager.onEnemyKilled();
                                    
                                    // Spawn powerups with health chance
                                    if (Math.random() < 0.15) {
                                        const types = ['weapon', 'shield', 'bomb', 'rapid', 'health'];
                                        let type;
                                        
                                        // Higher chance for health if low on lives
                                        if (gameState.lives <= 1 && Math.random() < 0.4) {
                                            type = 'health';
                                        } else {
                                            type = types[Math.floor(Math.random() * types.length)];
                                        }
                                        
                                        gameState.powerUps.push(new PowerUp(enemy.x, enemy.y, type));
                                    }
                                }
                                
                                updateUI();
                            }
                        }
                    });
                }
            });
            
            if (!gameState.player.invulnerable) {
                enemyBulletPool.getActiveBullets().forEach(bullet => {
                    if (!bullet.isPlayerBullet && bullet.active) {
                        const dist = Math.hypot(
                            bullet.x - gameState.player.x,
                            bullet.y - gameState.player.y
                        );
                        
                        if (dist < gameState.player.size) {
                            bullet.active = false;
                            
                            if (gameState.player.takeDamage()) {
                                gameState.lives--;
                                gameState.combo = 0;
                                updateUI();
                                
                                if (gameState.lives <= 0) {
                                    // Massive explosion for final death
                                    for (let i = 0; i < 100; i++) {
                                        const angle = (Math.PI * 2 * i) / 100;
                                        const speed = Math.random() * 20 + 5;
                                        particleSystem.particles.push({
                                            x: gameState.player.x,
                                            y: gameState.player.y,
                                            vx: Math.cos(angle) * speed,
                                            vy: Math.sin(angle) * speed,
                                            color: i % 3 === 0 ? '#ff0000' : (i % 3 === 1 ? '#ffff00' : gameState.player.color),
                                            life: 60 + Math.random() * 40,
                                            maxLife: 100,
                                            size: Math.random() * 6 + 2,
                                            active: true,
                                            update() {
                                                this.x += this.vx;
                                                this.y += this.vy;
                                                this.vx *= 0.98;
                                                this.vy *= 0.98;
                                                this.life--;
                                                if (this.life <= 0) this.active = false;
                                            },
                                            draw(ctx) {
                                                const alpha = this.life / this.maxLife;
                                                ctx.save();
                                                ctx.globalAlpha = alpha;
                                                ctx.fillStyle = this.color;
                                                ctx.shadowBlur = 20;
                                                ctx.shadowColor = this.color;
                                                ctx.beginPath();
                                                ctx.arc(this.x, this.y, this.size * (1 + (1 - alpha) * 2), 0, Math.PI * 2);
                                                ctx.fill();
                                                ctx.restore();
                                            }
                                        });
                                    }
                                    
                                    if (gameState.screenShake) {
                                        gameState.screenShake.intensity = 30;
                                        gameState.screenShake.duration = 60;
                                    }
                                    
                                    if (enemyBulletPool) enemyBulletPool.clear();
                                    
                                    if (soundSystem) {
                                        soundSystem.playExplosion();
                                        setTimeout(() => soundSystem.playExplosion(), 100);
                                        setTimeout(() => soundSystem.playExplosion(), 200);
                                    }
                                    
                                    gameOver();
                                } else {
                                    if (gameState.screenShake) {
                                        gameState.screenShake.intensity = 15;
                                        gameState.screenShake.duration = 30;
                                    }
                                    
                                    particleSystem.addExplosion(
                                        gameState.player.x,
                                        gameState.player.y,
                                        gameState.player.color,
                                        15
                                    );
                                }
                            }
                        }
                    }
                });
            }
            
            if (!gameState.player.invulnerable) {
                gameState.enemies.forEach(enemy => {
                    if (enemy && enemy.active) {
                        const dist = Math.hypot(
                            enemy.x - gameState.player.x,
                            enemy.y - gameState.player.y
                        );
                        
                        if (dist < enemy.size + gameState.player.size) {
                            if (gameState.player.takeDamage()) {
                                gameState.lives--;
                                enemy.active = false;
                                gameState.combo = 0;
                                updateUI();
                                
                                if (gameState.lives <= 0) {
                                    // Same massive explosion effect
                                    for (let i = 0; i < 100; i++) {
                                        const angle = (Math.PI * 2 * i) / 100;
                                        const speed = Math.random() * 20 + 5;
                                        particleSystem.particles.push({
                                            x: gameState.player.x,
                                            y: gameState.player.y,
                                            vx: Math.cos(angle) * speed,
                                            vy: Math.sin(angle) * speed,
                                            color: i % 3 === 0 ? '#ff0000' : (i % 3 === 1 ? '#ffff00' : gameState.player.color),
                                            life: 60 + Math.random() * 40,
                                            maxLife: 100,
                                            size: Math.random() * 6 + 2,
                                            active: true,
                                            update() {
                                                this.x += this.vx;
                                                this.y += this.vy;
                                                this.vx *= 0.98;
                                                this.vy *= 0.98;
                                                this.life--;
                                                if (this.life <= 0) this.active = false;
                                            },
                                            draw(ctx) {
                                                const alpha = this.life / this.maxLife;
                                                ctx.save();
                                                ctx.globalAlpha = alpha;
                                                ctx.fillStyle = this.color;
                                                ctx.shadowBlur = 20;
                                                ctx.shadowColor = this.color;
                                                ctx.beginPath();
                                                ctx.arc(this.x, this.y, this.size * (1 + (1 - alpha) * 2), 0, Math.PI * 2);
                                                ctx.fill();
                                                ctx.restore();
                                            }
                                        });
                                    }
                                    
                                    if (gameState.screenShake) {
                                        gameState.screenShake.intensity = 30;
                                        gameState.screenShake.duration = 60;
                                    }
                                    
                                    if (enemyBulletPool) enemyBulletPool.clear();
                                    
                                    if (soundSystem) {
                                        soundSystem.playExplosion();
                                        setTimeout(() => soundSystem.playExplosion(), 100);
                                        setTimeout(() => soundSystem.playExplosion(), 200);
                                    }
                                    
                                    gameOver();
                                } else {
                                    if (particleSystem && enemy && enemy.color) {
                                        particleSystem.addExplosion(enemy.x, enemy.y, enemy.color, 15);
                                    }
                                    if (particleSystem && gameState.player.color) {
                                        particleSystem.addExplosion(
                                            gameState.player.x,
                                            gameState.player.y,
                                            gameState.player.color,
                                            10
                                        );
                                    }
                                }
                            }
                        }
                    }
                });
            }
            
            gameState.powerUps.forEach(powerUp => {
                if (powerUp && powerUp.active) {
                    const dist = Math.hypot(
                        powerUp.x - gameState.player.x,
                        powerUp.y - gameState.player.y
                    );
                    
                    if (dist < 30) {
                        powerUp.active = false;
                        
                        switch(powerUp.type) {
                            case 'weapon':
                                gameState.player.weaponLevel = Math.min(3, gameState.player.weaponLevel + 1);
                                break;
                            case 'shield':
                                gameState.player.shield = 3;
                                gameState.player.shieldActive = true;
                                break;
                            case 'bomb':
                                gameState.bombs = Math.min(5, gameState.bombs + 1);
                                break;
                            case 'rapid':
                                gameState.player.fireRate = Math.max(3, gameState.player.fireRate - 2);
                                break;
                            case 'health':
                                gameState.lives = Math.min(5, gameState.lives + 1);
                                // Add visual feedback
                                if (particleSystem) {
                                    particleSystem.addExplosion(powerUp.x, powerUp.y, '#ff0000', 20);
                                }
                                break;
                        }
                        
                        if (soundSystem) {
                            soundSystem.playPowerUp();
                            // üîä VOICE: "OUTSTANDING!" for power-ups
                            setTimeout(() => {
                                soundSystem.playVoiceSample('OUTSTANDING');
                            }, 100);
                        }
                        updateUI();
                        
                        if (particleSystem && powerUp && powerUp.color) {
                            particleSystem.addExplosion(powerUp.x, powerUp.y, powerUp.color, 10);
                        }
                    }
                }
            });
        }

        // Attract Mode Functions
        function resetAttractModeTimeout() {
            if (attractModeTimer) {
                clearTimeout(attractModeTimer);
            }
            
            // üïπÔ∏è ATTRACT MODE: Start etter 10 sekunder inaktivitet (som gamle arkade-spill)
            attractModeTimer = setTimeout(() => {
                if (!gameState || !gameState.running) {
                    startAttractMode();
                }
            }, 10000); // 10 sekunder i stedet for 15
        }
        
        function startAttractMode() {
            if (attractMode || (gameState && gameState.running)) return;
            
            console.log('üïπÔ∏è Starting attract mode - classic arcade demo!');
            
            // üé∂ MUSIKK: Start meny-musikk i attract mode
            if (musicEnabled && menuMusic && gameMusic) {
                try {
                    gameMusic.pause();
                    gameMusic.currentTime = 0;
                    menuMusic.play().catch(err => console.warn("Attract mode menu music play failed:", err));
                } catch (error) {
                    console.warn("Music control failed:", error);
                }
            }
            
            attractMode = true;
            attractModeAI = new AttractModeAI();
            
            document.getElementById('menuScreen').style.display = 'none';
            document.getElementById('gameUI').style.display = 'block';
            
            particleSystem = new ParticleSystem();
            soundSystem = new SoundSystem();
            soundSystem.enabled = false;
            bulletPool = new BulletPool();
            enemyBulletPool = new BulletPool();
            
            // üåüüõ∏ Initialize starfield and formation manager for attract mode
            if (!starfield) starfield = new Starfield();
            if (!formationManager) formationManager = new FormationManager();
            
            const newRadicalSlang = new RadicalSlang();
            
            gameState = {
                running: true,
                paused: false,
                score: Math.floor(Math.random() * 50000),
                lastScoreIncrease: 0,
                lives: 3,
                bombs: 3,
                wave: Math.floor(Math.random() * 5) + 1,
                combo: 0,
                maxCombo: 0,
                comboTimer: 0,
                comboTimeout: 180,
                enemies: [],
                particles: [],
                powerUps: [],
                boss: null,
                player: new Player(config.width / 2, config.height - 100),
                radicalSlang: newRadicalSlang,
                screenShake: { x: 0, y: 0, intensity: 0, duration: 0 },
                // PATCH 5: Add promotional texts with more arcade-style messages
                promoTexts: [
                    "INSERT COIN TO PLAY",
                    "HIGH SCORE: " + (getHighScores()[0]?.score?.toLocaleString() || '0'),
                    "*** GEOMETRY 3044 ***",
                    "DEFEAT THE GEOMETRIC MENACE",
                    "COLLECT POWER-UPS FOR MAXIMUM FIREPOWER",
                    "USE BOMBS WISELY - CLEAR THE SCREEN",
                    "CHAIN COMBOS FOR RADICAL SCORES",
                    "FASTER SHIP FOR SUPERIOR MANEUVERS", // üöÄ Oppdatert fra dash til hastighet
                    "EVERY 100,000 POINTS = EXTRA LIFE",
                    "PRESS C TO INSERT COIN", // Updated for new coin system
                    "üèÜ HIGH SCORES üèÜ",  // This will trigger high score display
                    "¬© 2024 NEON ARCADE SYSTEMS",
                    "CHALLENGE THE VOID..."
                ],
                currentPromoIndex: 0,
                promoTimer: 0
            };
            
            gameState.player.weaponLevel = Math.floor(Math.random() * 3) + 1;
            
            waveManager = new WaveManager();
            updateUI();
            
            document.getElementById('scoreDisplay').textContent = 'DEMO';
            
            requestAnimationFrame(attractModeLoop);
        }
        
        function exitAttractMode() {
            if (!attractMode) return;
            
            console.log('üïπÔ∏è Exiting attract mode - player interaction detected!');
            
            attractMode = false;
            attractModeAI = null;
            highScoreFromAttractMode = false; // Reset flag
            
            if (gameState) {
                gameState.running = false;
            }
            
            if (bulletPool) bulletPool.clear();
            if (enemyBulletPool) enemyBulletPool.clear();
            
            document.getElementById('menuScreen').style.display = 'flex';
            document.getElementById('gameUI').style.display = 'none';
            
            if (soundSystem) soundSystem.enabled = true;
            
            resetAttractModeTimeout();
        }
        
        function attractModeLoop() {
            if (!attractMode || !gameState || !gameState.running) {
                // Stop the attract mode loop if conditions aren't met
                return;
            }
            
            if (attractModeAI && gameState.player) {
                const enemyBullets = enemyBulletPool ? enemyBulletPool.getActiveBullets() : [];
                attractModeAI.update(gameState.player, gameState.enemies, enemyBullets);
            }
            
            update();
            render();
            
            if (attractMode && gameState && gameState.running) {
                requestAnimationFrame(attractModeLoop);
            }
        }

        // Game Loop
        function gameLoop() {
            try {
                if (gameState && gameState.running) {
                    if (!gameState.paused || gameState.lives <= 0) {
                        update();
                        render();
                    }
                    
                    gameLoopId = requestAnimationFrame(gameLoop);
                }
            } catch (error) {
                console.error('Game loop error:', error);
                console.error('Stack trace:', error.stack);
                if (gameState && gameState.running) {
                    gameLoopId = requestAnimationFrame(gameLoop);
                }
            }
        }

        function update() {
            try {
                if (!gameState || !gameState.running) return;
                
                // Apply slow motion effect
                const timeScale = gameState.slowMotion > 0 ? 0.3 : 1.0;
                if (gameState.slowMotion > 0) gameState.slowMotion--;
                
                // PATCH 5: Update promo text timer in attract mode (faster like arcade games)
                if (attractMode) {
                    gameState.promoTimer++;
                    if (gameState.promoTimer > 90) { // 1.5 seconds at 60fps (faster than before)
                        gameState.currentPromoIndex = (gameState.currentPromoIndex + 1) % gameState.promoTexts.length;
                        gameState.promoTimer = 0;
                        
                        // üèÜ Show high scores when that text appears in attract mode
                        if (gameState.promoTexts[gameState.currentPromoIndex] === "üèÜ HIGH SCORES üèÜ") {
                            showHighScoreList();
                            return; // Exit update early since we're showing high scores
                        }
                    }
                }
                
                if (gameState.radicalSlang) gameState.radicalSlang.update();
                if (particleSystem) particleSystem.update();
                if (bulletPool) bulletPool.update();
                if (enemyBulletPool && timeScale === 1) enemyBulletPool.update();
                
                // üåü Update starfield
                if (starfield) starfield.update();
                
                // üõ∏ Update formation manager
                if (formationManager && timeScale === 1) formationManager.update();
                
                if (gameState.combo > 0) {
                    gameState.comboTimer++;
                    if (gameState.comboTimer > gameState.comboTimeout) {
                        gameState.combo = 0;
                        gameState.comboTimer = 0;
                        updateUI();
                    }
                }
                
                if (gameState.player) gameState.player.update();
                
                if (gameState.enemies && timeScale === 1) {
                    gameState.enemies = gameState.enemies.filter(enemy => {
                        if (enemy && enemy.active) {
                            enemy.update();
                            return true;
                        }
                        return false;
                    });
                }
                
                if (gameState.boss && gameState.boss.active && timeScale === 1) {
                    gameState.boss.update();
                }
                
                if (gameState.particles) {
                    gameState.particles = gameState.particles.filter(p => {
                        if (p && typeof p.update === 'function') {
                            p.update();
                            return p.active;
                        }
                        return false;
                    });
                }
                
                if (gameState.powerUps) {
                    gameState.powerUps = gameState.powerUps.filter(p => {
                        if (p && typeof p.update === 'function') {
                            p.update();
                            return p.active;
                        }
                        return false;
                    });
                }
                
                if (waveManager && timeScale === 1) waveManager.update(1);
                
                if (gameState.screenShake && gameState.screenShake.duration > 0) {
                    gameState.screenShake.duration--;
                    const intensity = gameState.screenShake.intensity * (gameState.screenShake.duration / 30);
                    gameState.screenShake.x = (Math.random() - 0.5) * intensity;
                    gameState.screenShake.y = (Math.random() - 0.5) * intensity;
                } else if (gameState.screenShake) {
                    gameState.screenShake.x = 0;
                    gameState.screenShake.y = 0;
                }
                
                checkCollisions();
                
            } catch (error) {
                console.error('Update error:', error);
                console.error('Stack trace:', error.stack);
            }
        }

        function render() {
            if (!ctx || !gameState) return;
            
            try {
                ctx.save();
                
                if (gameState.screenShake) {
                    ctx.translate(gameState.screenShake.x || 0, gameState.screenShake.y || 0);
                }
                
                // üåü STARFIELD BACKGROUND (replaces gradient)
                if (starfield) {
                    // Deep space base
                    const bgGradient = ctx.createLinearGradient(0, 0, 0, config.height);
                    bgGradient.addColorStop(0, '#000011'); // Very dark blue/navy
                    bgGradient.addColorStop(1, '#000833'); // Slightly lighter blue
                    ctx.fillStyle = bgGradient;
                    ctx.fillRect(0, 0, config.width, config.height);
                    
                    // Draw animated starfield
                    starfield.draw(ctx);
                } else {
                    // Fallback gradient background
                    const bgGradient = ctx.createLinearGradient(0, 0, 0, config.height);
                    bgGradient.addColorStop(0, '#000428'); // Very dark blue/navy
                    bgGradient.addColorStop(1, '#004e92'); // Medium blue
                    ctx.fillStyle = bgGradient;
                    ctx.fillRect(0, 0, config.width, config.height);
                }
                
                drawGrid();
                
                if (particleSystem) {
                    particleSystem.draw(ctx);
                }
                
                if (gameState.particles) {
                    gameState.particles.forEach(p => {
                        try {
                            if (p && p.draw) p.draw(ctx);
                        } catch (err) {}
                    });
                }
                
                if (gameState.enemies) {
                    gameState.enemies.forEach(e => {
                        try {
                            if (e && e.draw) e.draw(ctx);
                        } catch (err) {}
                    });
                }
                
                if (gameState.boss) {
                    try {
                        gameState.boss.draw(ctx);
                    } catch (err) {}
                }
                
                if (bulletPool) bulletPool.draw(ctx);
                if (enemyBulletPool) enemyBulletPool.draw(ctx);
                
                if (gameState.powerUps) {
                    gameState.powerUps.forEach(p => {
                        try {
                            if (p && p.draw) p.draw(ctx);
                        } catch (err) {}
                    });
                }
                
                if (gameState.player) {
                    if (!gameState.player.invulnerable || Math.floor(Date.now() / 100) % 2) {
                        gameState.player.draw(ctx);
                    }
                }
                
                if (gameState.radicalSlang) {
                    gameState.radicalSlang.draw(ctx);
                }
                
                ctx.restore();
                
                // PATCH 5: Draw promotional text in attract mode
                if (attractMode && gameState.promoTexts) {
                    ctx.save();
                    
                    // Main promo text
                    ctx.font = 'bold 24px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = '#00ffff';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#00ffff';
                    ctx.globalAlpha = 0.8 + Math.sin(Date.now() * 0.005) * 0.2;
                    ctx.fillText(
                        gameState.promoTexts[gameState.currentPromoIndex], 
                        config.width / 2, 
                        config.height * 0.85
                    );
                    
                    // üïπÔ∏è ARCADE STYLE: "DEMO MODE" indicator
                    ctx.font = 'bold 16px Courier New';
                    ctx.fillStyle = '#ff00ff';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff00ff';
                    ctx.globalAlpha = 0.6 + Math.sin(Date.now() * 0.01) * 0.4;
                    ctx.fillText('DEMO MODE', config.width / 2, 30);
                    
                    // Blinking "PRESS ANY KEY" when showing that message
                    if (gameState.promoTexts[gameState.currentPromoIndex].includes('PRESS ANY KEY') || 
                        gameState.promoTexts[gameState.currentPromoIndex].includes('PRESS C TO INSERT')) {
                        ctx.font = 'bold 20px Courier New';
                        ctx.fillStyle = '#ffff00';
                        ctx.shadowBlur = 25;
                        ctx.shadowColor = '#ffff00';
                        ctx.globalAlpha = Math.sin(Date.now() * 0.008) > 0 ? 1 : 0.3;
                        ctx.fillText('PRESS C TO INSERT COIN', config.width / 2, config.height * 0.92);
                    }
                    
                    // üõ∏ Formation bonus indicator
                    if (formationManager && formationManager.formations.length > 0) {
                        ctx.font = 'bold 16px Courier New';
                        ctx.fillStyle = '#ff8800';
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#ff8800';
                        ctx.globalAlpha = 0.7 + Math.sin(Date.now() * 0.01) * 0.3;
                        ctx.fillText(`FORMATION BONUS ACTIVE x${formationManager.formations.length}`, config.width / 2, 60);
                    }
                    
                    ctx.restore();
                }
                
                // Draw combo meter with synthwave colors
                if (gameState.combo > 0) {
                    ctx.save();
                    
                    // Combo meter bar
                    const meterWidth = Math.min(250, config.width * 0.3);
                    const meterHeight = 12;
                    const meterX = config.width / 2 - meterWidth / 2;
                    const meterY = config.height * 0.15;
                    const comboPercent = Math.min(gameState.comboTimer / gameState.comboTimeout, 1);
                    
                    // Background bar
                    ctx.fillStyle = 'rgba(30, 0, 50, 0.8)';
                    ctx.fillRect(meterX - 2, meterY - 2, meterWidth + 4, meterHeight + 4);
                    
                    // Gradient for synthwave colors (pink to cyan)
                    const gradient = ctx.createLinearGradient(meterX, 0, meterX + meterWidth, 0);
                    gradient.addColorStop(0, '#ff00ff');
                    gradient.addColorStop(0.3, '#ff006e');
                    gradient.addColorStop(0.6, '#8b00ff');
                    gradient.addColorStop(1, '#00ffff');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(meterX, meterY, meterWidth * (1 - comboPercent), meterHeight);
                    
                    // Neon border
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#00ffff';
                    ctx.strokeRect(meterX, meterY, meterWidth, meterHeight);
                    
                    // Combo text with synthwave gradient
                    const comboSize = Math.min(36 + gameState.combo * 2, 48);
                    ctx.font = `bold ${comboSize}px Courier New`;
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#ff00ff';
                    
                    const textGradient = ctx.createLinearGradient(config.width / 2 - 100, 0, config.width / 2 + 100, 0);
                    textGradient.addColorStop(0, '#ff00ff');
                    textGradient.addColorStop(0.5, '#00ffff');
                    textGradient.addColorStop(1, '#ff00ff');
                    
                    ctx.fillStyle = textGradient;
                    ctx.globalAlpha = 0.9 + Math.sin(Date.now() * 0.01) * 0.1;
                    
                    const comboText = `${gameState.combo}x COMBO`;
                    ctx.fillText(comboText, config.width / 2, meterY - 15);
                    
                    // Score multiplier with neon glow
                    ctx.font = 'bold 20px Courier New';
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffffff';
                    ctx.globalAlpha = 0.9;
                    ctx.fillText(`Score √ó${gameState.combo}`, config.width / 2, meterY + meterHeight + 25);
                    
                    ctx.restore();
                }
                
                if (gameState.lives <= 0 && gameState.paused) {
                    ctx.save();
                    ctx.fillStyle = '#ff0000';
                    ctx.font = 'bold 72px Courier New';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#ff0000';
                    ctx.globalAlpha = 0.8 + Math.sin(Date.now() * 0.01) * 0.2;
                    ctx.fillText('GAME OVER', config.width / 2, config.height / 2);
                    ctx.restore();
                }
                
                drawCRTEffect(ctx);
                
            } catch (error) {
                console.error('Render error:', error);
            }
        }

        function drawGrid() {
            if (!ctx) return;
            
            ctx.save();
            
            const pulse = Math.sin(Date.now() * 0.001) * 0.3 + 0.7;
            const colorShift = Math.sin(Date.now() * 0.0005) * 30;
            
            const hue = 180 + colorShift;
            ctx.strokeStyle = `hsla(${hue}, 100%, 50%, ${0.15 * pulse})`;
            ctx.lineWidth = 1;
            ctx.shadowBlur = 5 * pulse;
            ctx.shadowColor = `hsla(${hue}, 100%, 50%, 0.3)`;
            
            const gridSize = 60;
            const offset = (Date.now() * 0.02) % gridSize;
            
            // Draw fewer grid lines for better performance
            for (let x = -gridSize; x < config.width + gridSize; x += gridSize) {
                const perspectiveFactor = 1 + (config.height - 400) / config.height * 0.5;
                const startX = x + offset;
                const endX = (x - config.width/2) * perspectiveFactor + config.width/2 + offset;
                
                ctx.beginPath();
                ctx.moveTo(startX, 0);
                ctx.lineTo(endX, config.height);
                ctx.stroke();
            }
            
            // Horizontal lines with less detail
            for (let y = 0; y < config.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(config.width, y);
                ctx.stroke();
            }
            
            // Bottom gradient
            ctx.globalAlpha = 0.1;
            const gradient = ctx.createLinearGradient(0, config.height - 150, 0, config.height);
            gradient.addColorStop(0, 'transparent');
            gradient.addColorStop(0.5, `hsla(${180 + colorShift}, 100%, 50%, 0.2)`);
            gradient.addColorStop(1, `hsla(${300 + colorShift}, 100%, 50%, 0.3)`);
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, config.height - 150, config.width, 150);
            
            ctx.restore();
        }

        function drawCRTEffect(ctx) {
            ctx.save();
            
            // Reduce CRT line frequency for better performance
            ctx.globalAlpha = 0.03;
            ctx.fillStyle = '#000000';
            
            for (let y = 0; y < config.height; y += 6) {
                ctx.fillRect(0, y, config.width, 3);
            }
            
            // Vignette effect
            const gradient = ctx.createRadialGradient(
                config.width/2, config.height/2, Math.min(config.width, config.height)/3,
                config.width/2, config.height/2, Math.max(config.width, config.height)/2
            );
            gradient.addColorStop(0, 'rgba(0,0,0,0)');
            gradient.addColorStop(1, 'rgba(0,0,0,0.3)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, config.width, config.height);
            
            // Random flicker effect (less frequent)
            if (Math.random() < 0.01) {
                ctx.globalAlpha = 0.015;
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(0, 0, config.width, config.height);
            }
            
            ctx.restore();
        }

        // Bomb function with enhanced visuals
        window.useBomb = function() {
            if (!gameState || gameState.bombs <= 0) return;
            
            gameState.bombs--;
            updateUI();
            
            // Create expanding shockwave effect
            gameState.particles.push({
                x: gameState.player.x,
                y: gameState.player.y,
                radius: 0,
                maxRadius: Math.max(config.width, config.height),
                life: 30,
                maxLife: 30,
                active: true,
                update() {
                    this.radius += (this.maxRadius / this.maxLife) * 2;
                    this.life--;
                    if (this.life <= 0) this.active = false;
                },
                draw(ctx) {
                    const alpha = this.life / this.maxLife;
                    ctx.save();
                    
                    // Multiple rings for cooler effect
                    for (let i = 0; i < 3; i++) {
                        const ringRadius = this.radius - (i * 20);
                        if (ringRadius > 0) {
                            ctx.strokeStyle = i === 0 ? '#ffffff' : (i === 1 ? '#00ffff' : '#0099ff');
                            ctx.lineWidth = 5 - i;
                            ctx.globalAlpha = alpha * (1 - i * 0.3);
                            ctx.shadowBlur = 30;
                            ctx.shadowColor = ctx.strokeStyle;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, ringRadius, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                    }
                    
                    // Flash effect
                    if (this.life > 25) {
                        ctx.fillStyle = '#ffffff';
                        ctx.globalAlpha = (this.life - 25) / 5;
                        ctx.fillRect(0, 0, config.width, config.height);
                    }
                    
                    ctx.restore();
                }
            });
            
            enemyBulletPool.clear();
            
            // Destroy enemies with delay based on distance
            gameState.enemies.forEach(enemy => {
                if (enemy.active) {
                    const dist = Math.hypot(enemy.x - gameState.player.x, enemy.y - gameState.player.y);
                    const delay = Math.min(dist / 20, 15);
                    
                    setTimeout(() => {
                        if (enemy.active) {
                            enemy.takeDamage(5);
                            if (!enemy.active) {
                                gameState.score += enemy.points;
                                particleSystem.addExplosion(enemy.x, enemy.y, enemy.color, 15);
                            }
                        }
                    }, delay * 16);
                }
            });
            
            if (gameState.boss && gameState.boss.active) {
                gameState.boss.takeDamage(5);
            }
            
            // Radial bullets
            for (let i = 0; i < 16; i++) {
                const angle = (Math.PI * 2 * i) / 16;
                const speed = 12;
                bulletPool.get(
                    gameState.player.x,
                    gameState.player.y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    true
                );
            }
            
            gameState.screenShake.intensity = 25;
            gameState.screenShake.duration = 40;
            
            particleSystem.addExplosion(gameState.player.x, gameState.player.y, '#ffffff', 50);
            soundSystem.playExplosion();
            
            // üîä VOICE: "EXCELLENT!" for successful bomb use
            setTimeout(() => {
                if (soundSystem) {
                    soundSystem.playVoiceSample('EXCELLENT');
                }
            }, 300);
            
            // Slow motion effect
            gameState.slowMotion = 30;
        }

        // Initialize everything when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            try {
                canvas = document.getElementById('gameCanvas');
                if (!canvas) {
                    console.error('Canvas not found!');
                    return;
                }
                
                ctx = canvas.getContext('2d');
                if (!ctx) {
                    console.error('Could not get canvas context!');
                    return;
                }
                
                // Make canvas responsive
                function resizeCanvas() {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    
                    // Update config with new dimensions
                    config.width = canvas.width;
                    config.height = canvas.height;
                    
                    // üåü Update starfield for new dimensions
                    if (starfield) {
                        starfield.resize(canvas.width, canvas.height);
                    }
                }
                
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                
                const highScores = getHighScores();
                const topScore = highScores.length > 0 ? highScores[0].score : 0;
                document.getElementById('highScoreDisplay').textContent = topScore.toLocaleString();
                
                // ü™ô Initialize sound system early for coin sounds
                soundSystem = new SoundSystem();
                
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                if (isMobile) {
                    document.getElementById('mobileControls').style.display = 'block';
                    setupTouchControls();
                }
                
                keys = {};
                
                resetAttractModeTimeout();
                
                // üé∂ MUSIKK: Start meny-musikk n√•r bruker klikker f√∏rste gang
                let musicStarted = false;
                function startMenuMusicOnFirstInteraction() {
                    if (!musicStarted && musicEnabled && menuMusic) {
                        try {
                            musicStarted = true;
                            menuMusic.play().catch(err => console.warn("Initial menu music play failed:", err));
                            document.removeEventListener('click', startMenuMusicOnFirstInteraction);
                            document.removeEventListener('keydown', startMenuMusicOnFirstInteraction);
                        } catch (error) {
                            console.warn("Music initialization failed:", error);
                        }
                    }
                }
                document.addEventListener('click', startMenuMusicOnFirstInteraction);
                document.addEventListener('keydown', startMenuMusicOnFirstInteraction);
                
                // ü™ô Initialize credits display
                setTimeout(() => {
                    updateCreditsDisplay();
                }, 100);
                
                console.log('Game initialized successfully');
            } catch (error) {
                console.error('Initialization error:', error);
            }
        });

        // Input handling with PATCH 2 and PATCH 3
        window.addEventListener('keydown', (e) => {
            // Don't prevent default if we're typing in input fields
            if (e.target.tagName === 'INPUT' && e.target.classList.contains('initial-letter')) {
                // Let the input field handle its own events
                return;
            }
            
            e.preventDefault();
            
            const key = e.key.toLowerCase();
            
            if (attractMode) {
                exitAttractMode();
                // üé∂ Start meny-musikk n√•r vi forlater attract mode
                if (musicEnabled && menuMusic && gameMusic) {
                    try {
                        gameMusic.pause();
                        gameMusic.currentTime = 0;
                        menuMusic.play().catch(err => console.warn("Menu music play failed:", err));
                    } catch (error) {
                        console.warn("Music control failed:", error);
                    }
                }
                return;
            }
            
            // Handle high score screen navigation - but not if typing in inputs
            if (document.getElementById('highScoreEntryScreen').style.display === 'flex') {
                // Only handle these keys if NOT focused on an input
                if (!e.target.classList.contains('initial-letter')) {
                    if (key === 'enter') {
                        submitHighScore();
                    } else if (key === 'escape') {
                        skipHighScore();
                    }
                }
                return; // Don't process other keys in high score entry
            }
            
            if (document.getElementById('highScoreListScreen').style.display === 'flex') {
                if (key === 'enter' || key === 'escape' || key === ' ') {
                    closeHighScores();
                }
                return; // Don't process other keys in high score list
            }
            keys[key] = true;
            
            if (e.key.startsWith('Arrow')) {
                keys[e.key] = true;
            }
            
            // üö´ Fjernet: PATCH 2 double-tap dash detection logikk
            
            if (key === 'p') {
                if (gameState && gameState.running) {
                    gameState.paused = !gameState.paused;
                    document.getElementById('pauseOverlay').style.display = 
                        gameState.paused ? 'block' : 'none';
                }
            }
            
            if (key === 'b' && gameState && gameState.bombs > 0) {
                useBomb();
            }
            
            // PATCH 3: Q key auto-fire toggle
            if (key === 'q' && gameState && gameState.player) {
                gameState.player.autoFire = !gameState.player.autoFire;
                // Visual feedback
                if (particleSystem) {
                    const color = gameState.player.autoFire ? '#00ff00' : '#ff0000';
                    particleSystem.addExplosion(
                        gameState.player.x, 
                        gameState.player.y, 
                        color, 
                        10
                    );
                }
            }
            
            // üé∂ MUSIKK: M key for mute/unmute
            if (key === 'm') {
                musicMuted = !musicMuted;
                if (musicMuted) {
                    menuMusic.volume = 0;
                    gameMusic.volume = 0;
                } else {
                    menuMusic.volume = 0.5;
                    gameMusic.volume = 0.5;
                }
                // Visual feedback for mute toggle
                if (particleSystem && gameState && gameState.player) {
                    const color = musicMuted ? '#ff0000' : '#00ff00';
                    particleSystem.addExplosion(
                        gameState.player.x, 
                        gameState.player.y, 
                        color, 
                        10
                    );
                }
            }
            
            // ü™ô INSERT COIN with C key
            if (key === 'c') {
                insertCoin();
            }
            
            resetAttractModeTimeout();
        });

        // üïπÔ∏è ARCADE STYLE: Reset attract mode p√• mouse bevegelse ogs√•
        window.addEventListener('mousemove', (e) => {
            if (!gameState || !gameState.running) {
                resetAttractModeTimeout();
            }
        });

        // üïπÔ∏è ARCADE STYLE: Reset attract mode p√• klikk
        window.addEventListener('click', (e) => {
            if (attractMode) {
                exitAttractMode();
            } else if (!gameState || !gameState.running) {
                resetAttractModeTimeout();
            }
        });

        window.addEventListener('keyup', (e) => {
            e.preventDefault();
            
            const key = e.key.toLowerCase();
            keys[key] = false;
            delete keys[key];
            
            if (e.key.startsWith('Arrow')) {
                keys[e.key] = false;
                delete keys[e.key];
            }
            
            if (e.key === ' ') {
                keys[' '] = false;
                delete keys[' '];
            }
        });

        // Touch controls setup
        function setupTouchControls() {
            const joystick = document.getElementById('touchJoystick');
            const fireBtn = document.getElementById('touchFire');
            const bombBtn = document.getElementById('touchBomb');
            
            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystick.getBoundingClientRect();
                touchJoystick.active = true;
                touchJoystick.startX = touch.clientX - rect.left - rect.width/2;
                touchJoystick.startY = touch.clientY - rect.top - rect.height/2;
            });
            
            joystick.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (touchJoystick.active) {
                    const touch = e.touches[0];
                    const rect = joystick.getBoundingClientRect();
                    touchJoystick.currentX = touch.clientX - rect.left - rect.width/2;
                    touchJoystick.currentY = touch.clientY - rect.top - rect.height/2;
                }
            });
            
            joystick.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchJoystick.active = false;
            });
            
            fireBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchButtons.fire = true;
            });
            
            fireBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                touchButtons.fire = false;
            });
            
            bombBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameState && gameState.bombs > 0) {
                    useBomb();
                }
            });
        }

        // Prevent scrolling on mobile
        document.addEventListener('touchmove', (e) => {
            if (e.target.closest('#gameContainer')) {
                e.preventDefault();
            }
        }, { passive: false });
    </script>
</body>
</html>
